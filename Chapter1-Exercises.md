# 第一章：實數系統 練習題

這份教材包含第一章的練習題，每題都附有詳細的證明步驟和說明。

---

## 體公設與順序公設語法說明

在進行練習題之前，我們需要先了解實數系統的基本公設及其在 Lean 中的語法表達。實數滿足有序域（Ordered Field）的所有公理，這些公理構成了我們證明所有定理的基礎。

### 一、體公設（Field Axioms）

體公設定義了實數的加法、乘法和它們之間的關係。

#### 1. 加法公理

**公設 1.1：加法交換律（Additive Commutativity）**
- **語法**：`∀ a b : ℝ, a + b = b + a`
- **說明**：`∀ a b : ℝ` 是 `∀ a : ℝ, ∀ b : ℝ` 的簡寫
- **Lean 定理**：`add_comm`
- **完整語法範例**：`example (a b : ℝ) : a + b = b + a := add_comm a b`

**公設 1.2：加法結合律（Additive Associativity）**
- **語法**：`∀ a b c : ℝ, (a + b) + c = a + (b + c)`
- **說明**：括號表示運算順序，無論先加哪兩個，結果都相同
- **Lean 定理**：`add_assoc`
- **完整語法範例**：`example (a b c : ℝ) : (a + b) + c = a + (b + c) := add_assoc a b c`

**公設 1.3：加法單位元（零元）（Additive Identity）**
- **語法**：`∀ a : ℝ, a + 0 = a` 和 `∀ a : ℝ, 0 + a = a`
- **說明**：`0 : ℝ` 表示實數零，零是加法的單位元
- **Lean 定理**：`add_zero : a + 0 = a` 和 `zero_add : 0 + a = a`

**公設 1.4：加法逆元（負元）（Additive Inverse）**
- **語法**：`∀ a : ℝ, a + (-a) = 0` 和 `∀ a : ℝ, (-a) + a = 0`
- **說明**：`-a` 表示 a 的加法逆元（負數），每個數都有加法逆元
- **Lean 定理**：`add_neg_cancel : a + (-a) = 0` 和 `neg_add_cancel : (-a) + a = 0`

#### 2. 乘法公理

**公設 2.1：乘法交換律（Multiplicative Commutativity）**
- **語法**：`∀ a b : ℝ, a * b = b * a`
- **Lean 定理**：`mul_comm`

**公設 2.2：乘法結合律（Multiplicative Associativity）**
- **語法**：`∀ a b c : ℝ, (a * b) * c = a * (b * c)`
- **Lean 定理**：`mul_assoc`

**公設 2.3：乘法單位元（Multiplicative Identity）**
- **語法**：`∀ a : ℝ, a * 1 = a` 和 `∀ a : ℝ, 1 * a = a`
- **說明**：`1 : ℝ` 表示實數一，一是乘法的單位元
- **Lean 定理**：`mul_one : a * 1 = a` 和 `one_mul : 1 * a = a`

**公設 2.4：乘法逆元（倒數，對非零元）（Multiplicative Inverse）**
- **語法**：`∀ a : ℝ, a ≠ 0 → a * a⁻¹ = 1`
- **說明**：
  - `a⁻¹` 或 `1 / a` 表示 a 的乘法逆元（倒數）
  - `a ≠ 0` 表示 a 不等於零
  - `→` 表示蘊含（implies），這裡表示"如果 a ≠ 0，則..."
- **Lean 定理**：`mul_inv_cancel`（透過類型類解析自動應用）
- **注意**：`a / a = 1` 等價於 `a * a⁻¹ = 1`，因為 `a / a = a * a⁻¹`

#### 3. 分配律（Distributivity）

**公設 3.1：左分配律**
- **語法**：`∀ a b c : ℝ, a * (b + c) = a * b + a * c`
- **Lean 定理**：`mul_add`

**公設 3.2：右分配律**
- **語法**：`∀ a b c : ℝ, (a + b) * c = a * c + b * c`
- **Lean 定理**：`add_mul`

### 二、順序公設（Order Axioms）

順序公設定義了實數之間的大小關係。

**公設 4.1：全序性（Total Order）**
- **語法**：`∀ a b : ℝ, a ≤ b ∨ b ≤ a`
- **說明**：
  - `≤` 表示小於等於關係
  - `∨` 表示邏輯或（or）
  - 表示任意兩個實數都可以比較大小
- **Lean 定理**：`le_total`

**公設 4.2：傳遞性（Transitivity）**
- **語法**：`∀ a b c : ℝ, a ≤ b → b ≤ c → a ≤ c`
- **說明**：`→` 表示蘊含，可以鏈式使用。如果 a ≤ b 且 b ≤ c，則 a ≤ c
- **Lean 定理**：`le_trans`

**公設 4.3：反身性（Reflexivity）**
- **語法**：`∀ a : ℝ, a ≤ a`
- **說明**：每個數都小於等於自己
- **Lean 定理**：`le_refl`

**公設 4.4：加法保序（Order Preservation under Addition）**
- **語法**：`∀ a b c : ℝ, a ≤ b → a + c ≤ b + c`
- **說明**：如果 a ≤ b，則兩邊同時加 c 後仍保持 ≤
- **Lean 定理**：`add_le_add_right`

**公設 4.5：乘法保序（正數）（Order Preservation under Multiplication by Positive）**
- **語法**：`∀ a b c : ℝ, 0 ≤ c → a ≤ b → a * c ≤ b * c`
- **說明**：如果 c ≥ 0 且 a ≤ b，則 a * c ≤ b * c
- **Lean 定理**：`mul_le_mul_of_nonneg_right`

### 三、常用語法符號

在 Lean 中，我們會用到以下符號：

- **全稱量詞**：`∀` 表示"對於所有"（for all）
- **存在量詞**：`∃` 表示"存在"（exists）
- **蘊含**：`→` 表示"如果...則..."（implies）
- **雙向蘊含**：`↔` 表示"若且唯若"（iff）
- **邏輯與**：`∧` 表示"且"（and）
- **邏輯或**：`∨` 表示"或"（or）
- **邏輯非**：`¬` 表示"非"（not）
- **等於**：`=` 表示等於
- **小於等於**：`≤` 表示小於等於
- **大於等於**：`≥` 表示大於等於
- **小於**：`<` 表示小於
- **大於**：`>` 表示大於

### 四、在證明中使用公設

在 Lean 中，這些公設通常以定理的形式存在，我們可以直接使用：

```lean
-- 使用加法交換律
example (a b : ℝ) : a + b = b + a := add_comm a b

-- 使用加法結合律
example (a b c : ℝ) : (a + b) + c = a + (b + c) := add_assoc a b c

-- 使用分配律
example (a b c : ℝ) : a * (b + c) = a * b + a * c := mul_add a b c
example (a b c : ℝ) : (a + b) * c = a * c + b * c := add_mul a b c
```

在證明中，我們可以使用 `rw`（rewrite）策略來應用這些定理：

```lean
example (a : ℝ) : a + 0 = a := by
   rw [add_zero]  -- 使用 add_zero 定理
```

或者使用 `←` 來反向應用：

```lean
example (a : ℝ) : a = a + 0 := by
   rw [← add_zero]  -- 反向使用 add_zero 定理
```

---

## 練習題 1：證明 0 · a = 0

### 題目

**定理**：對於任意實數 \(a\)，有 \(0 \cdot a = 0\)

**說明**：這個定理說明零乘以任何數都等於零。這是實數系統中一個重要的基本性質。

### 證明思路

使用以下基本公理：
- 分配律（公設 3）
- 加法結合律（公設 1.2）
- 加法單位元（公設 1.3）
- 加法逆元（公設 1.4）

### 完整證明

```lean
example (a : ℝ) : 0 * a = 0 := by
   -- 步驟 1：使用加法單位元公理（公設 1.3）
   -- `add_zero` 定理：`a + 0 = a`
   -- 這裡將 `0 * a` 寫成 `0 * a + 0` 的形式
   have h0a_add_0 : 0 * a = 0 * a + 0 := by
      rw [add_zero]

   -- 步驟 2：使用加法逆元公理（公設 1.4）
   -- `add_neg_cancel` 定理：`a + (-a) = 0`
   -- 取其對稱形式：`0 = a + (-a)`
   -- 這裡 `a` 是 `0 * a`，所以 `0 = 0 * a + (- (0 * a))`
   have h0_eq_0a_add_0a : 0 = 0 * a + (- (0 * a)) :=
      (add_neg_cancel (0 * a)).symm

   -- 步驟 3：將步驟 1 中的 `0` 替換成步驟 2 中的表達式
   -- 從 `0 * a = 0 * a + 0` 得到 `0 * a = 0 * a + (0 * a + (- (0 * a)))`
   -- 使用 `convert` 和 `rw [← h0_eq_0a_add_0a]` 來替換
   have h3 : 0 * a = 0 * a + (0 * a + (- (0 * a))) := by
      -- 從 h0a_add_0: 0 * a = 0 * a + 0
      -- 把右邊的 0 替換成 0 * a + (- (0 * a))（用 h0_eq_0a_add_0a 的反向）
      convert h0a_add_0 using 2
      rw [← h0_eq_0a_add_0a]

   -- 步驟 4：使用加法結合律（公設 1.2）
   -- `add_assoc` 定理：`(a + b) + c = a + (b + c)`
   -- 取其對稱形式：`a + (b + c) = (a + b) + c`
   -- 這裡將 `0 * a + (0 * a + (- (0 * a)))` 重組為 `(0 * a + 0 * a) + (- (0 * a))`
   have h4 : 0 * a + (0 * a + - (0 * a)) = (0 * a + 0 * a) + (- (0 * a)) :=
      (add_assoc (0 * a) (0 * a) (- (0 * a))).symm

   -- 步驟 5：使用分配律（公設 3）和加法單位元
   -- 首先用右分配律將 `0 * a + 0 * a` 寫成 `(0 + 0) * a`
   -- 然後用 `add_zero` 將 `(0 + 0) * a` 簡化為 `0 * a`
   -- 最終得到 `(0 * a + 0 * a) + (- (0 * a)) = 0 * a + (-(0 * a))`
   have h5 : (0 * a + 0 * a) + (- (0 * a)) = 0 * a + (-(0 * a)) := by
      -- 子步驟 5.1：使用右分配律 `add_mul` 的逆方向
      -- `add_mul` 定理：`(a + b) * c = a * c + b * c`
      -- 逆方向：`a * c + b * c = (a + b) * c`
      -- 這裡 `a = 0`, `b = 0`, `c = a`，所以 `0 * a + 0 * a = (0 + 0) * a`
      have h6 : 0 * a + 0 * a = (0 + 0) * a := by
         rw [← add_mul]
      -- 子步驟 5.2：使用加法單位元 `add_zero`
      -- `add_zero` 定理：`a + 0 = a`
      -- 這裡 `0 + 0 = 0`，所以 `(0 + 0) * a = 0 * a`
      rw [h6]
      rw [add_zero]

   -- 步驟 6：使用加法逆元公理（公設 1.4）
   -- `add_neg_cancel` 定理：`a + (-a) = 0`
   -- 這裡 `a` 是 `0 * a`，所以 `0 * a + (-(0 * a)) = 0`
   have h7 : 0 * a + (-(0 * a)) = 0 := add_neg_cancel (0 * a)

   -- 最終步驟：使用 `calc` 將以上所有步驟串聯起來
   -- 這是一個等式鏈式證明，每一步都使用前面建立的引理
   calc
      0 * a = 0 * a + (0 * a + - (0 * a)) := h3
      _ = (0 * a + 0 * a) + (- (0 * a)) := h4
      _ = 0 * a + (-(0 * a)) := h5
      _ = 0 := h7
```

### 證明步驟說明

#### 步驟 1：引入加法單位元
我們從 `0 * a = 0 * a + 0` 開始，這是加法單位元公理（`add_zero`）的直接應用。

#### 步驟 2：建立零的等價表達
使用加法逆元公理，我們知道 `0 = 0 * a + (-(0 * a))`。這為後續的替換做準備。

#### 步驟 3：替換零
將步驟 1 中的 `0` 替換成步驟 2 中的表達式，得到：
\[
0 \cdot a = 0 \cdot a + (0 \cdot a + (-(0 \cdot a)))
\]

#### 步驟 4：應用結合律
使用加法結合律重組表達式：
\[
0 \cdot a + (0 \cdot a + (-(0 \cdot a))) = (0 \cdot a + 0 \cdot a) + (-(0 \cdot a))
\]

#### 步驟 5：應用分配律
這是關鍵步驟：
1. 使用右分配律的逆方向：`0 \cdot a + 0 \cdot a = (0 + 0) \cdot a`
2. 使用加法單位元：`(0 + 0) \cdot a = 0 \cdot a`

因此得到：`(0 \cdot a + 0 \cdot a) + (-(0 \cdot a)) = 0 \cdot a + (-(0 \cdot a))`

#### 步驟 6：應用加法逆元
使用加法逆元公理：`0 \cdot a + (-(0 \cdot a)) = 0`

#### 最終：鏈式證明
使用 `calc` 將所有步驟串聯起來，完成證明。

### 使用的公理和定理

1. **加法單位元（公設 1.3）**：`add_zero : a + 0 = a`
2. **加法逆元（公設 1.4）**：`add_neg_cancel : a + (-a) = 0`
3. **加法結合律（公設 1.2）**：`add_assoc : (a + b) + c = a + (b + c)`
4. **右分配律（公設 3）**：`add_mul : (a + b) * c = a * c + b * c`

### 學習重點

1. **分配律的應用**：這是證明中最重要的步驟，展示了如何將 `0 \cdot a + 0 \cdot a` 轉換為 `(0 + 0) \cdot a`。

2. **等式鏈式證明**：使用 `calc` 可以清晰地展示證明的每一步。

3. **公理的組合使用**：這個證明展示了如何組合使用多個基本公理來證明一個看似簡單但重要的定理。

### 相關練習

- 嘗試證明 `a · 0 = 0`（使用類似的方法）
- 思考為什麼需要分配律來證明這個定理
- 比較這個證明與直接使用 `zero_mul` 定理的差異

---

## 練習題 2：證明 -a = (-1) · a

### 題目

**定理**：對於任意實數 \(a\)，有 \(-a = (-1) \cdot a\)

**說明**：這個定理說明一個數的負數等於 -1 乘以這個數。這是實數系統中另一個重要的基本性質，展示了負數與乘法的關係。

### 證明思路

使用以下基本公理和定理：
- 乘法單位元（公設 2.3）
- 右分配律（公設 3.2）
- 加法逆元（公設 1.4）
- 零乘任何數等於零（練習題 1 的結果）
- `eq_neg_of_add_eq_zero_right` 定理

### 完整證明

```lean
example (a : ℝ) : -a = (-1) * a := by
   -- 步驟 1：證明 a + (-1) * a = 0
   -- 這是證明的關鍵中間步驟，我們將使用分配律和加法逆元
   have h1 : a + (-1) * a = 0 := by
      calc
         a + (-1) * a
         -- 子步驟 1.1：使用乘法單位元（公設 2.3）
         -- `one_mul` 定理：`1 * a = a`
         -- 將 `a` 寫成 `1 * a` 的形式，以便後續使用分配律
         _ = 1 * a + (-1) * a := by rw [one_mul a]
         -- 子步驟 1.2：使用右分配律（公設 3.2）的逆方向
         -- `add_mul` 定理：`(a + b) * c = a * c + b * c`
         -- 逆方向：`a * c + b * c = (a + b) * c`
         -- 這裡 `a = 1`, `b = -1`, `c = a`，所以 `1 * a + (-1) * a = (1 + (-1)) * a`
         _ = (1 + (-1)) * a := by rw [← add_mul]
         -- 子步驟 1.3：使用加法逆元（公設 1.4）
         -- `add_neg_cancel` 定理：`a + (-a) = 0`
         -- 這裡 `a = 1`，所以 `1 + (-1) = 0`
         _ = 0 * a := by rw [add_neg_cancel (1 : ℝ)]
         -- 子步驟 1.4：使用零乘任何數等於零（前面已證明的定理）
         -- `zero_mul` 定理：`0 * a = 0`
         _ = 0 := by rw [zero_mul]
   
   -- 步驟 2：從 a + (-1) * a = 0 推導出 -a = (-1) * a
   -- 使用 `eq_neg_of_add_eq_zero_right` 定理
   -- 這個定理說：如果 `a + b = 0`，則 `b = -a`
   -- 這裡 `a = a`, `b = (-1) * a`，所以 `(-1) * a = -a`
   -- 然後使用 `eq_comm` 交換等式的兩邊，得到 `-a = (-1) * a`
   rw [eq_comm]
   exact eq_neg_of_add_eq_zero_right h1
```

### 證明步驟說明

#### 步驟 1：證明 a + (-1) · a = 0

這是證明的關鍵中間步驟。我們使用 `calc` 來建立等式鏈：

1. **子步驟 1.1**：使用乘法單位元將 `a` 寫成 `1 * a`
   - 這使得我們可以將 `a + (-1) * a` 寫成 `1 * a + (-1) * a`
   - 為後續使用分配律做準備

2. **子步驟 1.2**：使用右分配律的逆方向
   - 將 `1 * a + (-1) * a` 合併為 `(1 + (-1)) * a`
   - 這是分配律的逆應用

3. **子步驟 1.3**：使用加法逆元
   - `1 + (-1) = 0`，所以 `(1 + (-1)) * a = 0 * a`

4. **子步驟 1.4**：使用零乘任何數等於零
   - 這是練習題 1 的結果：`0 * a = 0`

#### 步驟 2：推導出最終結果

從 `a + (-1) * a = 0` 推導出 `-a = (-1) * a`：

1. 使用 `eq_neg_of_add_eq_zero_right` 定理
   - 這個定理說：如果 `a + b = 0`，則 `b = -a`
   - 這裡 `b = (-1) * a`，所以 `(-1) * a = -a`

2. 使用 `eq_comm` 交換等式的兩邊
   - 從 `(-1) * a = -a` 得到 `-a = (-1) * a`

### 使用的公理和定理

1. **乘法單位元（公設 2.3）**：`one_mul : 1 * a = a`
2. **右分配律（公設 3.2）**：`add_mul : (a + b) * c = a * c + b * c`
3. **加法逆元（公設 1.4）**：`add_neg_cancel : a + (-a) = 0`
4. **零乘任何數等於零**：`zero_mul : 0 * a = 0`（練習題 1 的結果）
5. **等式交換律**：`eq_comm : a = b ↔ b = a`
6. **加法逆元的推論**：`eq_neg_of_add_eq_zero_right : a + b = 0 → b = -a`

### 學習重點

1. **分配律的逆應用**：這個證明展示了如何將 `1 * a + (-1) * a` 合併為 `(1 + (-1)) * a`，這是分配律的逆方向應用。

2. **中間步驟的重要性**：證明 `a + (-1) * a = 0` 是關鍵的中間步驟，它連接了分配律和最終結果。

3. **定理的組合使用**：這個證明展示了如何組合使用多個基本公理和已證明的定理來證明新的定理。

4. **等式變換的技巧**：使用 `eq_comm` 來交換等式的兩邊，這是在證明中常用的技巧。

### 相關練習

- 嘗試證明 `(-a) * b = -(a * b)`（使用類似的方法）
- 思考為什麼需要先證明 `a + (-1) * a = 0`
- 比較這個證明與直接使用 `neg_one_mul` 定理的差異（如果存在）

---

## 練習題 3：證明 -(-a) = a

### 題目

**定理**：對於任意實數 \(a\)，有 \(-(-a) = a\)

**說明**：這個定理說明一個數的負數的負數等於原數。這是實數系統中一個重要的基本性質，展示了負數運算的基本規則。

### 證明思路

使用以下基本公理：
- 加法逆元（公設 1.4）
- 加法交換律（公設 1.1）
- 加法消去律（可從體公設推導）

### 完整證明

```lean
example (a : ℝ) : -(-a) = a := by
   -- 步驟 1：使用加法逆元公理（公設 1.4）
   -- `add_neg_cancel` 定理：`a + (-a) = 0`
   -- 對 `a` 應用：`a + (-a) = 0`
   have h1 : a + (-a) = 0 := add_neg_cancel a
   -- 對 `-a` 應用：`(-a) + (-(-a)) = 0`
   -- 這表示 `-a` 的加法逆元是 `-(-a)`
   have h2 : (-a) + (-(-a)) = 0 := add_neg_cancel (-a)
   
   -- 步驟 2：使用加法交換律（公設 1.1）
   -- `add_comm` 定理：`a + b = b + a`
   -- 將 h1 轉換為 `(-a) + a = 0` 的形式
   -- 這樣我們就有兩個以 `-a` 開頭的等式，方便後續使用消去律
   have h3 : (-a) + a = 0 := by rw [add_comm, h1]
   
   -- 步驟 3：使用加法消去律
   -- 如果 `x + y = 0` 且 `x + z = 0`，則 `y = z`
   -- 這裡 `x = -a`, `y = a`, `z = -(-a)`
   -- 從 `(-a) + a = 0` 和 `(-a) + (-(-a)) = 0` 得到 `a = -(-a)`
   -- 然後使用 `eq_comm` 交換等式的兩邊，得到 `-(-a) = a`
   have h5 : a = -(-a) := by
      -- 子步驟 3.1：建立等式 `(-a) + a = (-a) + (-(-a))`
      -- 我們有 `(-a) + a = 0`（h3）和 `(-a) + (-(-a)) = 0`（h2）
      -- 因為兩邊都等於 0，所以 `(-a) + a = (-a) + (-(-a))`
      have h6 : (-a) + a = (-a) + (-(-a)) := by
         rw [h3, h2]
      -- 子步驟 3.2：使用左消去律 `add_left_cancel`
      -- `add_left_cancel` 定理：如果 `a + b = a + c`，則 `b = c`
      -- 這裡 `a = -a`, `b = a`, `c = -(-a)`
      -- 從 `(-a) + a = (-a) + (-(-a))` 得到 `a = -(-a)`
      exact add_left_cancel h6
   
   -- 步驟 4：交換等式的兩邊
   -- 使用 `eq_comm` 從 `a = -(-a)` 得到 `-(-a) = a`
   rw [eq_comm]
   exact h5
```

### 證明步驟說明

#### 步驟 1：建立兩個加法逆元等式

使用加法逆元公設（公設 1.4）建立兩個關鍵等式：

1. **對 `a` 應用**：`a + (-a) = 0`
   - 這表示 `-a` 是 `a` 的加法逆元

2. **對 `-a` 應用**：`(-a) + (-(-a)) = 0`
   - 這表示 `-(-a)` 是 `-a` 的加法逆元

#### 步驟 2：使用交換律統一形式

使用加法交換律（公設 1.1）將第一個等式轉換為：
\[
(-a) + a = 0
\]

這樣我們就有兩個以 `-a` 開頭的等式，為後續使用消去律做準備。

#### 步驟 3：應用加法消去律

這是證明的關鍵步驟：

1. **建立等式**：從 `(-a) + a = 0` 和 `(-a) + (-(-a)) = 0`，我們得到：
   \[
   (-a) + a = (-a) + (-(-a))
   \]

2. **應用左消去律**：使用 `add_left_cancel` 定理
   - 如果 `a + b = a + c`，則 `b = c`
   - 這裡 `a = -a`, `b = a`, `c = -(-a)`
   - 因此得到：`a = -(-a)`

#### 步驟 4：交換等式兩邊

使用 `eq_comm` 從 `a = -(-a)` 得到最終結果：`-(-a) = a`

### 使用的公理和定理

1. **加法逆元（公設 1.4）**：`add_neg_cancel : a + (-a) = 0`
2. **加法交換律（公設 1.1）**：`add_comm : a + b = b + a`
3. **加法消去律**：`add_left_cancel : a + b = a + c → b = c`
4. **等式交換律**：`eq_comm : a = b ↔ b = a`

### 學習重點

1. **消去律的應用**：這個證明展示了如何使用加法消去律來比較兩個表達式。當我們有 `x + y = 0` 和 `x + z = 0` 時，可以推導出 `y = z`。

2. **交換律的戰略使用**：通過使用交換律將等式轉換為相同的形式（都以 `-a` 開頭），我們可以應用消去律。

3. **只使用基本公設**：這個證明完全基於體公設，沒有使用高階定理，展示了如何從基本公設推導出重要的性質。

4. **負數運算的基本規則**：這個定理是負數運算的基礎，在後續的證明中會經常使用。

### 相關練習

- 嘗試證明 `(-a) * b = -(a * b)`（使用類似的方法）
- 思考為什麼需要交換律來統一等式的形式
- 證明加法消去律可以從體公設推導出來

---

## 練習題 4：證明 -(a - b) = b - a

### 題目

**定理**：對於任意實數 \(a, b\)，有 \(-(a - b) = b - a\)

**說明**：這個定理說明一個減法的負數等於交換被減數和減數後的減法。這是實數系統中減法運算的一個重要性質。

### 證明思路

使用以下基本公理和已證明的定理：
- 減法轉加法的性質：`sub_eq_add_neg`
- 負數與乘法的關係（練習題 2）：`-a = (-1) * a`
- 左分配律（公設 3.1）
- 負數的負數等於原數（練習題 3）：`-(-a) = a`
- 加法交換律（公設 1.1）

### 完整證明

```lean
example (a b : ℝ) : -(a - b) = b - a := by
   calc
      -(a - b)
      -- 步驟 1：將減法轉換為加法形式
      -- `sub_eq_add_neg` 定理：`a - b = a + (-b)`
      -- 所以 `-(a - b) = -(a + (-b))`
      _ = -(a + (-b)) := by rw [sub_eq_add_neg]
      
      -- 步驟 2：使用負數與乘法的關係（練習題 2 的結果）
      -- `neg_one_mul` 定理：`-a = (-1) * a`
      -- 逆方向：`-x = (-1) * x`
      -- 這裡 `x = a + (-b)`，所以 `-(a + (-b)) = (-1) * (a + (-b))`
      _ = (-1) * (a + (-b)) := by rw [← neg_one_mul]
      
      -- 步驟 3：使用左分配律（公設 3.1）
      -- `mul_add` 定理：`a * (b + c) = a * b + a * c`
      -- 這裡 `a = -1`, `b = a`, `c = -b`
      -- 所以 `(-1) * (a + (-b)) = (-1) * a + (-1) * (-b)`
      _ = (-1) * a + (-1) * (-b) := by rw [mul_add]
      
      -- 步驟 4：使用負數與乘法的關係
      -- `neg_one_mul` 定理：`(-1) * a = -a`
      -- 所以 `(-1) * a + (-1) * (-b) = (-a) + (-1) * (-b)`
      _ = (-a) + (-1) * (-b) := by rw [neg_one_mul]
      
      -- 步驟 5：使用負數的負數等於原數（練習題 3 的結果）
      -- `neg_one_mul` 定理：`(-1) * (-b) = -(-b)`
      -- `neg_neg` 定理：`-(-b) = b`
      -- 所以 `(-a) + (-1) * (-b) = (-a) + b`
      _ = (-a) + b := by rw [neg_one_mul, neg_neg]
      
      -- 步驟 6：使用加法交換律（公設 1.1）
      -- `add_comm` 定理：`a + b = b + a`
      -- 所以 `(-a) + b = b + (-a)`
      _ = b + (-a) := by rw [add_comm]
      
      -- 步驟 7：轉換回減法形式
      -- `sub_eq_add_neg` 定理的逆方向：`a + (-b) = a - b`
      -- 所以 `b + (-a) = b - a`
      _ = b - a := by rw [← sub_eq_add_neg]
```

### 證明步驟說明

#### 步驟 1：將減法轉換為加法

使用 `sub_eq_add_neg` 將 `a - b` 轉換為 `a + (-b)`，這樣我們就可以使用加法的性質。

#### 步驟 2：使用負數與乘法的關係

使用練習題 2 的結果：`-x = (-1) * x`，將 `-(a + (-b))` 轉換為 `(-1) * (a + (-b))`。

#### 步驟 3：應用左分配律

使用左分配律（公設 3.1）將 `(-1) * (a + (-b))` 展開為 `(-1) * a + (-1) * (-b)`。

#### 步驟 4：簡化第一項

使用 `neg_one_mul` 將 `(-1) * a` 簡化為 `-a`。

#### 步驟 5：簡化第二項

使用 `neg_one_mul` 和 `neg_neg`（練習題 3 的結果）將 `(-1) * (-b)` 簡化為 `b`。

#### 步驟 6：使用交換律

使用加法交換律（公設 1.1）將 `(-a) + b` 轉換為 `b + (-a)`。

#### 步驟 7：轉換回減法

使用 `sub_eq_add_neg` 的逆方向將 `b + (-a)` 轉換回 `b - a`。

### 使用的公理和定理

1. **減法轉加法**：`sub_eq_add_neg : a - b = a + (-b)`
2. **負數與乘法的關係（練習題 2）**：`neg_one_mul : -a = (-1) * a`
3. **左分配律（公設 3.1）**：`mul_add : a * (b + c) = a * b + a * c`
4. **負數的負數等於原數（練習題 3）**：`neg_neg : -(-a) = a`
5. **加法交換律（公設 1.1）**：`add_comm : a + b = b + a`

### 學習重點

1. **calc 的清晰性**：使用 `calc` 建立等式鏈比大量 `rw` 更清晰，每一步的轉換都清楚可見。

2. **定理的組合使用**：這個證明展示了如何組合使用多個已證明的定理（練習題 2 和 3）來證明新的定理。

3. **減法與加法的轉換**：通過在減法和加法之間轉換，我們可以利用加法的性質來處理減法問題。

4. **負數運算的性質**：這個定理是負數運算的重要性質，在後續的證明中會經常使用。

### 相關練習

- 嘗試證明 `(a - b) - c = a - (b + c)`（使用類似的方法）
- 思考為什麼需要將減法轉換為加法
- 比較這個證明與使用消去律的證明方法的差異

---

## 練習題 5：證明 ab = 0 → a = 0 ∨ b = 0（零乘積性質）

### 題目

**定理**：對於任意實數 \(a, b\)，如果 \(a \cdot b = 0\)，則 \(a = 0\) 或 \(b = 0\)

**說明**：這個定理說明如果兩個數的乘積為零，則至少有一個為零。這是實數系統中一個重要的性質，在解方程時經常使用。

### 證明思路

使用反證法：
1. 假設結論不成立：\(a \neq 0\) 且 \(b \neq 0\)
2. 從 \(a \cdot b = 0\) 和 \(a \neq 0\) 推導出 \(b = 0\)
3. 這與 \(b \neq 0\) 矛盾
4. 因此原結論成立

### 完整證明

```lean
example (a b : ℝ) : a * b = 0 → a = 0 ∨ b = 0 := by
   -- 步驟 1：引入前提
   -- 假設 a * b = 0
   intro h
   
   -- 步驟 2：使用反證法
   -- 假設結論不成立：a ≠ 0 且 b ≠ 0
   by_contra h_not
   -- h_not 是 ¬(a = 0 ∨ b = 0)，即 a ≠ 0 且 b ≠ 0
   
   -- 步驟 3：使用德摩根定律展開否定
   -- `push_neg` 將 ¬(a = 0 ∨ b = 0) 轉換為 a ≠ 0 ∧ b ≠ 0
   push_neg at h_not
   
   -- 步驟 4：分解假設
   -- 從 h_not : a ≠ 0 ∧ b ≠ 0 得到兩個假設
   have ha_neq_0 : a ≠ 0 := h_not.left
   have hb_neq_0 : b ≠ 0 := h_not.right
   
   -- 步驟 5：從 a * b = 0 和 a ≠ 0 推導出 b = 0
   -- 這是反證法的關鍵步驟
   have hb_eq_0 : b = 0 := by
      calc
         b
         -- 子步驟 5.1：使用乘法單位元（公設 2.3）
         -- `one_mul` 定理：`1 * b = b`
         _ = 1 * b := by rw [one_mul]
         -- 子步驟 5.2：使用乘法逆元（公設 2.4）
         -- 因為 a ≠ 0，所以 a 有乘法逆元 a⁻¹
         -- `mul_inv_cancel` 定理：`a * a⁻¹ = 1`
         -- 使用 `field_simp` 自動處理類型推斷，將 1 替換為 a * a⁻¹
         _ = (a * a⁻¹) * b := by
            field_simp [ha_neq_0]
         -- 子步驟 5.3：使用乘法交換律和結合律（公設 2.1, 2.2）
         -- `mul_comm` 定理：`a * a⁻¹ = a⁻¹ * a`
         -- `mul_assoc` 定理：`(a⁻¹ * a) * b = a⁻¹ * (a * b)`
         _ = a⁻¹ * (a * b) := by rw [mul_comm a a⁻¹, mul_assoc]
         -- 子步驟 5.4：使用前提 h : a * b = 0
         -- 將 a * b 替換為 0
         _ = a⁻¹ * 0 := by rw [h]
         -- 子步驟 5.5：使用零乘任何數等於零（練習題 1 的結果）
         -- `mul_zero` 定理：`a * 0 = 0`
         _ = 0 := by rw [mul_zero]
   
   -- 步驟 6：得出矛盾
   -- 我們有 hb_neq_0 : b ≠ 0 和 hb_eq_0 : b = 0
   -- 這兩個命題矛盾，因此原假設不成立
   -- 所以 a = 0 ∨ b = 0 成立
   exact hb_neq_0 hb_eq_0
```

### 證明步驟說明

#### 步驟 1：引入前提

使用 `intro h` 引入前提 `a * b = 0`。

#### 步驟 2：使用反證法

使用 `by_contra h_not` 開始反證法，假設結論 `a = 0 ∨ b = 0` 不成立。

#### 步驟 3：展開否定

使用 `push_neg` 將 `¬(a = 0 ∨ b = 0)` 轉換為 `a ≠ 0 ∧ b ≠ 0`。

#### 步驟 4：分解假設

從 `a ≠ 0 ∧ b ≠ 0` 中提取兩個假設：
- `ha_neq_0 : a ≠ 0`
- `hb_neq_0 : b ≠ 0`

#### 步驟 5：推導矛盾

這是證明的關鍵步驟。從 `a * b = 0` 和 `a ≠ 0` 推導出 `b = 0`：

1. **使用乘法單位元**：將 `b` 寫成 `1 * b`
2. **使用乘法逆元**：因為 `a ≠ 0`，所以 `a` 有乘法逆元 `a⁻¹`，且 `a * a⁻¹ = 1`
3. **重組表達式**：使用交換律和結合律將 `(a * a⁻¹) * b` 重組為 `a⁻¹ * (a * b)`
4. **使用前提**：將 `a * b` 替換為 `0`
5. **使用零乘性質**：`a⁻¹ * 0 = 0`

因此得到 `b = 0`。

#### 步驟 6：得出矛盾

我們有 `hb_neq_0 : b ≠ 0` 和 `hb_eq_0 : b = 0`，這兩個命題矛盾。因此原假設不成立，所以 `a = 0 ∨ b = 0` 成立。

### 使用的公理和定理

1. **乘法單位元（公設 2.3）**：`one_mul : 1 * a = a`
2. **乘法逆元（公設 2.4）**：`mul_inv_cancel : a ≠ 0 → a * a⁻¹ = 1`
3. **乘法交換律（公設 2.1）**：`mul_comm : a * b = b * a`
4. **乘法結合律（公設 2.2）**：`mul_assoc : (a * b) * c = a * (b * c)`
5. **零乘任何數等於零（練習題 1）**：`mul_zero : a * 0 = 0`
6. **反證法策略**：`by_contra`、`push_neg`

### 學習重點

1. **反證法的使用**：這個證明展示了如何使用反證法來證明一個"或"命題。當直接證明困難時，反證法是一個有力的工具。

2. **乘法逆元的應用**：當我們有 `a * b = 0` 且 `a ≠ 0` 時，可以使用乘法逆元來"消去" `a`，從而得到 `b = 0`。

3. **field_simp 的使用**：`field_simp` 可以自動處理類型類實例的推斷，特別是在處理域（Field）相關的運算時非常有用。

4. **零乘積性質的重要性**：這個定理在解方程時非常重要，例如解 `(x - 1)(x - 2) = 0` 時，我們知道 `x - 1 = 0` 或 `x - 2 = 0`。

### 相關練習

- 嘗試證明：如果 `a * b = 0` 且 `a ≠ 0`，則 `b = 0`（不使用反證法）
- 思考為什麼需要 `a ≠ 0` 才能使用乘法逆元
- 證明：如果 `a * b * c = 0`，則 `a = 0` 或 `b = 0` 或 `c = 0`

---

## 練習題 6：證明 a ≠ 0 → a² > 0（平方的正性）

### 題目

**定理**：對於任意實數 \(a\)，如果 \(-1 < a < 1\) 且 \(a \neq 0\)，則 \(a^2 > 0\)

**說明**：這個定理說明在區間 \((-1, 1)\) 內的非零實數，其平方必為正數。實際上，對於任意非零實數，其平方都為正數，這個條件只是題目給出的額外限制。

### 證明思路

使用以下基本公理和定理：
- 全序性（公設 4.1）：將 \(a \neq 0\) 轉換為 \(a < 0\) 或 \(a > 0\)
- 分情況證明：分別處理 \(a < 0\) 和 \(a > 0\) 兩種情況
- 乘法保序性質：正數的乘積為正，負數的乘積也為正

### 完整證明

```lean
example (a : ℝ) : -1 < a → a < 1 → a ≠ 0 → a^2 > 0 := by
   -- 步驟 1：引入前提
   -- h1 : -1 < a（雖然在證明中不需要用到，但這是題目給出的條件）
   -- h2 : a < 1（雖然在證明中不需要用到，但這是題目給出的條件）
   -- h3 : a ≠ 0（這是證明的關鍵條件）
   intro h1 h2 h3
   
   -- 步驟 2：使用全序性（公設 4.1）將 a ≠ 0 轉換為 a < 0 或 a > 0
   -- `ne_iff_lt_or_gt` 定理：`a ≠ 0 ↔ a < 0 ∨ a > 0`
   -- 使用 `.mp` 得到：如果 a ≠ 0，則 a < 0 或 a > 0
   have h4 : a < 0 ∨ a > 0 := ne_iff_lt_or_gt.mp h3
   
   -- 步驟 3：建立 a² 與 a * a 的等價關係
   -- `pow_two` 定理：`a^2 = a * a`
   -- 這允許我們在 a² 和 a * a 之間轉換
   have h5 : a^2 = a * a := pow_two a
   
   -- 步驟 4：分情況證明
   -- 使用 `cases` 對 h4 進行分情況討論
   cases h4 with
   -- 情況 1：a < 0
   | inl h_neg => 
      -- 子步驟 4.1：證明 a * a > 0（當 a < 0 時）
      -- `mul_pos_of_neg_of_neg` 定理：如果 a < 0 且 b < 0，則 a * b > 0
      -- 這裡 a < 0 且 a < 0，所以 a * a > 0
      have h6 : a * a > 0 := mul_pos_of_neg_of_neg h_neg h_neg
      -- 子步驟 4.2：使用 calc 建立不等式鏈
      calc 
         a^2
         -- 將 a² 轉換為 a * a
         _ = a * a := by rw [h5]
         -- 使用 h6 得到 a * a > 0
         _ > 0 := by exact h6
   -- 情況 2：a > 0
   | inr h_pos => 
      -- 子步驟 4.3：證明 a * a > 0（當 a > 0 時）
      -- `mul_pos` 定理：如果 a > 0 且 b > 0，則 a * b > 0
      -- 這裡 a > 0 且 a > 0，所以 a * a > 0
      have h6 : a * a > 0 := mul_pos h_pos h_pos
      -- 子步驟 4.4：使用 calc 建立不等式鏈
      calc 
         a^2
         -- 將 a² 轉換為 a * a
         _ = a * a := by rw [h5]
         -- 使用 h6 得到 a * a > 0
         _ > 0 := by exact h6
```

### 證明步驟說明

#### 步驟 1：引入前提

使用 `intro` 引入三個前提：
- `h1 : -1 < a`
- `h2 : a < 1`
- `h3 : a ≠ 0`

**注意**：雖然 `h1` 和 `h2` 給出了 `a` 的範圍限制，但在證明 `a^2 > 0` 時實際上不需要用到這兩個條件，因為只要 `a \neq 0` 就有 `a^2 > 0`。

#### 步驟 2：使用全序性轉換

使用 `ne_iff_lt_or_gt.mp` 將 `a ≠ 0` 轉換為 `a < 0 ∨ a > 0`。這是全序性的應用：對於任意實數，要麼小於 0，要麼等於 0，要麼大於 0。由於 `a ≠ 0`，所以只能是 `a < 0` 或 `a > 0`。

#### 步驟 3：建立等價關係

使用 `pow_two` 建立 `a^2 = a * a` 的等價關係，這樣我們就可以在平方和乘積之間轉換。

#### 步驟 4：分情況證明

使用 `cases` 對 `a < 0 ∨ a > 0` 進行分情況討論：

**情況 1：a < 0**
- 使用 `mul_pos_of_neg_of_neg` 定理：如果兩個負數相乘，結果為正數
- 因此 `a * a > 0`，即 `a^2 > 0`

**情況 2：a > 0**
- 使用 `mul_pos` 定理：如果兩個正數相乘，結果為正數
- 因此 `a * a > 0`，即 `a^2 > 0`

### 使用的公理和定理

1. **全序性（公設 4.1）**：`ne_iff_lt_or_gt : a ≠ 0 ↔ a < 0 ∨ a > 0`
2. **平方的定義**：`pow_two : a^2 = a * a`
3. **正數乘積為正**：`mul_pos : a > 0 → b > 0 → a * b > 0`
4. **負數乘積為正**：`mul_pos_of_neg_of_neg : a < 0 → b < 0 → a * b > 0`

### 學習重點

1. **分情況證明**：當我們有 `P ∨ Q` 時，可以使用 `cases` 分別證明每種情況，這是處理"或"命題的標準方法。

2. **全序性的應用**：`ne_iff_lt_or_gt` 是將不等於關係轉換為嚴格不等式的有用工具。

3. **平方的正性**：這個定理說明非零實數的平方總是正數，這是實數系統的一個重要性質。

4. **calc 用於不等式**：`calc` 不僅可以用於等式，也可以用於不等式鏈式證明。

### 相關練習

- 嘗試證明：對於任意實數 \(a\)，有 \(a^2 \geq 0\)（不需要 \(a \neq 0\) 的條件）
- 思考為什麼 `-1 < a < 1` 這個條件在證明中不需要用到
- 證明：如果 \(a^2 = 0\)，則 \(a = 0\)

---

## 練習題 7：證明 0 < a < 1 → 0 < a² < a

### 題目

**定理**：對於任意實數 \(a\)，如果 \(0 < a < 1\)，則 \(0 < a^2 < a\)

**說明**：這個定理說明在區間 \((0, 1)\) 內的實數，其平方也在 \((0, a)\) 內，即平方比原數小。這是實數系統中一個重要的不等式性質。

### 證明思路

分別證明兩個部分：
1. **a² > 0**：使用正數乘積為正的性質
2. **a² < a**：使用乘法保序性質，因為 \(a < 1\) 且 \(a > 0\)

### 完整證明

```lean
example (a : ℝ) : 0 < a → a < 1 → 0 < a^2 ∧ a^2 < a := by
   -- 步驟 1：引入前提
   -- h1 : 0 < a（a 是正數）
   -- h2 : a < 1（a 小於 1）
   intro h1 h2
   
   -- 步驟 2：建立 a² 與 a * a 的等價關係
   -- `pow_two` 定理：`a^2 = a * a`
   -- 這允許我們在 a² 和 a * a 之間轉換
   have h3 : a^2 = a * a := pow_two a
   
   -- 步驟 3：證明 a * a > 0
   -- `mul_pos` 定理：如果 a > 0 且 b > 0，則 a * b > 0
   -- 這裡 a > 0 (h1) 且 a > 0 (h1)，所以 a * a > 0
   have h4 : a * a > 0 := mul_pos h1 h1
   
   -- 步驟 4：證明 a² > 0
   -- 使用 calc 從 a² = a * a 和 a * a > 0 得到 a² > 0
   have h5 : a^2 > 0 := by 
      calc 
         a^2
         -- 將 a² 轉換為 a * a
         _ = a * a := h3 
         -- 使用 h4：a * a > 0
         _ > 0 := h4 
   
   -- 步驟 5：證明 a² < a
   -- 這是證明的關鍵步驟，需要使用乘法保序性質
   have h6 : a^2 < a := by
      -- 先將 a² 轉換為 a * a
      rw [h3]
      calc 
         a * a
         -- 子步驟 5.1：使用乘法保序（公設 4.5）
         -- `mul_lt_mul_of_pos_right` 定理：如果 a < b 且 0 < c，則 c * a < c * b
         -- 這裡 a < 1 (h2) 且 0 < a (h1)，所以 a * a < a * 1
         -- 但我們需要 a * a < 1 * a，所以使用 mul_lt_mul_of_pos_right
         _ < 1 * a := mul_lt_mul_of_pos_right h2 h1
         -- 子步驟 5.2：使用乘法單位元（公設 2.3）
         -- `one_mul` 定理：`1 * a = a`
         _ = a := by rw [one_mul]
   
   -- 步驟 6：組合兩個結果
   -- 使用 `⟨h5, h6⟩` 將 `a^2 > 0` 和 `a^2 < a` 組合成 `0 < a^2 ∧ a^2 < a`
   exact ⟨h5, h6⟩
```

### 證明步驟說明

#### 步驟 1：引入前提

使用 `intro` 引入兩個前提：
- `h1 : 0 < a`：a 是正數
- `h2 : a < 1`：a 小於 1

#### 步驟 2：建立等價關係

使用 `pow_two` 建立 `a^2 = a * a` 的等價關係，這樣我們就可以在平方和乘積之間轉換。

#### 步驟 3：證明 a * a > 0

使用 `mul_pos` 定理：如果兩個正數相乘，結果為正數。因為 `a > 0`，所以 `a * a > 0`。

#### 步驟 4：證明 a² > 0

使用 `calc` 從 `a^2 = a * a` 和 `a * a > 0` 得到 `a^2 > 0`。

#### 步驟 5：證明 a² < a

這是證明的關鍵步驟：

1. **使用乘法保序**：`mul_lt_mul_of_pos_right` 定理說：如果 `a < b` 且 `0 < c`，則 `c * a < c * b`
   - 這裡 `a < 1` (h2) 且 `0 < a` (h1)
   - 所以 `a * a < a * 1`

2. **使用乘法單位元**：`one_mul` 將 `1 * a` 簡化為 `a`

因此得到 `a^2 < a`。

#### 步驟 6：組合結果

使用 `⟨h5, h6⟩` 將兩個結果組合成 `0 < a^2 ∧ a^2 < a`。

### 使用的公理和定理

1. **平方的定義**：`pow_two : a^2 = a * a`
2. **正數乘積為正**：`mul_pos : a > 0 → b > 0 → a * b > 0`
3. **乘法保序（右側）**：`mul_lt_mul_of_pos_right : a < b → 0 < c → c * a < c * b`
4. **乘法單位元（公設 2.3）**：`one_mul : 1 * a = a`

### 學習重點

1. **分步證明合取命題**：當需要證明 `P ∧ Q` 時，可以分別證明 `P` 和 `Q`，然後使用 `⟨hP, hQ⟩` 組合。

2. **乘法保序的應用**：`mul_lt_mul_of_pos_right` 和 `mul_lt_mul_of_pos_left` 是處理不等式乘法的有力工具。

3. **區間 (0, 1) 的性質**：這個定理說明在開區間 (0, 1) 內，平方函數是遞減的（相對於原數）。

4. **calc 用於不等式**：`calc` 不僅可以用於等式，也可以用於不等式鏈式證明。

### 相關練習

- 嘗試證明：如果 \(a > 1\)，則 \(a^2 > a\)
- 思考為什麼需要 \(0 < a\) 這個條件
- 證明：如果 \(0 < a < b < 1\)，則 \(a^2 < b^2\)

---

## 練習題 8：證明 |a · b| = |a| · |b|（絕對值的乘性）

### 題目

**定理**：對於任意實數 \(a, b\)，有 \(|a \cdot b| = |a| \cdot |b|\)

**說明**：這個定理說明絕對值對乘法是保持的，即乘積的絕對值等於絕對值的乘積。這是絕對值運算的一個重要性質。

### 證明思路

使用分情況證明：
1. 對 \(a\) 分情況：\(a \leq 0\) 或 \(a \geq 0\)
2. 對 \(b\) 分情況：\(b \leq 0\) 或 \(b \geq 0\)
3. 總共有四種情況組合，分別證明每種情況

### 完整證明

```lean
example (a b : ℝ) : |a * b| = |a| * |b| := by 
   have h_a : a ≤ 0 ∨ 0 ≤ a := le_total a 0  -- 對 a 分情況：a ≤ 0 或 a ≥ 0
   have h_b : b ≤ 0 ∨ 0 ≤ b := le_total b 0  -- 對 b 分情況：b ≤ 0 或 b ≥ 0
   cases h_a with  -- 對 a 的情況進行分情況討論
   | inl ha_neg =>  -- 情況 1：a ≤ 0
      cases h_b with  -- 對 b 的情況進行分情況討論
         | inl hb_neg =>  -- 情況 1.1：a ≤ 0 且 b ≤ 0
            have h_ab : a * b ≥ 0 := mul_nonneg_of_nonpos_of_nonpos ha_neg hb_neg
            have h1 : |a * b| = a * b := by rw [abs_of_nonneg h_ab]
            have h2 : |a| = -a := by rw [abs_of_nonpos ha_neg]
            have h3 : |b| = -b := by rw [abs_of_nonpos hb_neg]
            have h4 : |a| * |b| = -a * -b := by rw [h2, h3]
            have h5 : -a * -b = a * b := by rw [neg_mul_neg]
            have h6 : |a| * |b| = a * b := by 
               calc 
                  |a| * |b|
                  _ = -a * -b := h4 
                  _ = a * b := h5 
            have h7 :|a * b| = |a| * |b| := by 
               calc 
                  |a * b|
                  _ = a * b := h1 
                  _ = |a| * |b| := h6.symm
            exact h7
         | inr hb_pos =>  -- 情況 1.2：a ≤ 0 且 b ≥ 0
            have h_ab : a * b ≤ 0 := mul_nonpos_of_nonpos_of_nonneg ha_neg hb_pos
            have h1 : |a * b| = - (a * b) := by rw [abs_of_nonpos h_ab]
            have h2 : |a| = -a := by rw [abs_of_nonpos ha_neg]
            have h3 : |b| = b := by rw [abs_of_nonneg hb_pos]
            have h4 : |a| * |b| = (-a) * b := by rw [h2, h3]
            have h5 : -(a * b) = (-a) * b := by rw [neg_mul]
            have h6 : |a * b| = |a| * |b| := by 
               calc 
                  |a * b|
                  _ = - (a * b) := h1
                  _ = (-a) * b := h5 
                  _ = |a| * |b| := h4.symm
            exact h6
   | inr ha_pos =>  -- 情況 2：a ≥ 0
      cases h_b with
      | inl hb_neg =>  -- 情況 2.1：a ≥ 0 且 b ≤ 0
         have h_ab : b * a ≤ 0 := mul_nonpos_of_nonpos_of_nonneg hb_neg ha_pos
         have h1 : a * b = b * a := by rw [mul_comm]
         have h2 : a * b ≤ 0 := by 
            calc
               a * b
               _ = b * a := h1
               _ ≤ 0 := h_ab
         have h3 : |a * b| = - (a * b) := by rw [abs_of_nonpos h2]
         have h4 : |a| = a := by rw [abs_of_nonneg ha_pos]
         have h5 : |b| = -b := by rw [abs_of_nonpos hb_neg]
         have h6 : |a| * |b| = a * (-b) := by rw [h4, h5]
         have h7 : - (a * b) = a * (-b) := by rw [← mul_neg]
         have h8 : |a * b| = |a| * |b| := by 
            calc 
               |a * b|
               _ = - (a * b) := h3
               _ = a * (-b) := h7 
               _ = |a| * |b| := h6.symm
         exact h8
      | inr hb_pos =>  -- 情況 2.2：a ≥ 0 且 b ≥ 0
         have h_ab : a * b ≥ 0 := mul_nonneg ha_pos hb_pos
         have h1 : |a * b| = a * b := by rw [abs_of_nonneg h_ab]
         have h2 : |a| = a := by rw [abs_of_nonneg ha_pos]
         have h3 : |b| = b := by rw [abs_of_nonneg hb_pos]
         have h4 : |a| * |b| = a * b := by rw [h2, h3]
         have h6 : |a * b| = |a| * |b| := by 
            calc 
               |a * b|
               _ = a * b := h1 
               _ = |a| * |b| := h4.symm
         exact h6
```

### 證明步驟說明

#### 整體結構：分情況證明

這個證明使用嵌套的分情況討論，總共有四種情況：

1. **情況 1.1**：\(a \leq 0\) 且 \(b \leq 0\)
2. **情況 1.2**：\(a \leq 0\) 且 \(b \geq 0\)
3. **情況 2.1**：\(a \geq 0\) 且 \(b \leq 0\)
4. **情況 2.2**：\(a \geq 0\) 且 \(b \geq 0\)

#### 情況 1.1：a ≤ 0 且 b ≤ 0

**步驟說明：**
1. **確定 a * b 的符號**：使用 `mul_nonneg_of_nonpos_of_nonpos` 得到 `a * b ≥ 0`（兩個非正數相乘為非負數）
2. **計算 |a * b|**：因為 `a * b ≥ 0`，所以 `|a * b| = a * b`
3. **計算 |a| 和 |b|**：因為 `a ≤ 0` 和 `b ≤ 0`，所以 `|a| = -a` 和 `|b| = -b`
4. **計算 |a| * |b|**：`|a| * |b| = (-a) * (-b) = a * b`（使用 `neg_mul_neg`）
5. **組合結果**：`|a * b| = a * b = |a| * |b|`

#### 情況 1.2：a ≤ 0 且 b ≥ 0

**步驟說明：**
1. **確定 a * b 的符號**：使用 `mul_nonpos_of_nonpos_of_nonneg` 得到 `a * b ≤ 0`（非正數乘以非負數為非正數）
2. **計算 |a * b|**：因為 `a * b ≤ 0`，所以 `|a * b| = -(a * b)`
3. **計算 |a| 和 |b|**：`|a| = -a` 和 `|b| = b`
4. **計算 |a| * |b|**：`|a| * |b| = (-a) * b`
5. **使用負數的分配**：`-(a * b) = (-a) * b`（使用 `neg_mul`）
6. **組合結果**：`|a * b| = -(a * b) = (-a) * b = |a| * |b|`

#### 情況 2.1：a ≥ 0 且 b ≤ 0

**步驟說明：**
1. **確定 a * b 的符號**：先證明 `b * a ≤ 0`，然後使用交換律得到 `a * b ≤ 0`
2. **計算 |a * b|**：因為 `a * b ≤ 0`，所以 `|a * b| = -(a * b)`
3. **計算 |a| 和 |b|**：`|a| = a` 和 `|b| = -b`
4. **計算 |a| * |b|**：`|a| * |b| = a * (-b)`
5. **使用負數的分配**：`-(a * b) = a * (-b)`（使用 `mul_neg` 的逆方向）
6. **組合結果**：`|a * b| = -(a * b) = a * (-b) = |a| * |b|`

#### 情況 2.2：a ≥ 0 且 b ≥ 0

**步驟說明：**
1. **確定 a * b 的符號**：使用 `mul_nonneg` 得到 `a * b ≥ 0`（兩個非負數相乘為非負數）
2. **計算 |a * b|**：因為 `a * b ≥ 0`，所以 `|a * b| = a * b`
3. **計算 |a| 和 |b|**：`|a| = a` 和 `|b| = b`
4. **計算 |a| * |b|**：`|a| * |b| = a * b`
5. **組合結果**：`|a * b| = a * b = |a| * |b|`

### 使用的公理和定理

1. **全序性（公設 4.1）**：`le_total : a ≤ b ∨ b ≤ a`
2. **絕對值的性質**：
   - `abs_of_nonneg : a ≥ 0 → |a| = a`
   - `abs_of_nonpos : a ≤ 0 → |a| = -a`
3. **乘法的符號性質**：
   - `mul_nonneg : a ≥ 0 → b ≥ 0 → a * b ≥ 0`
   - `mul_nonneg_of_nonpos_of_nonpos : a ≤ 0 → b ≤ 0 → a * b ≥ 0`
   - `mul_nonpos_of_nonpos_of_nonneg : a ≤ 0 → b ≥ 0 → a * b ≤ 0`
   - `mul_nonpos_of_nonneg_of_nonpos : a ≥ 0 → b ≤ 0 → a * b ≤ 0`
4. **負數的乘法性質**：
   - `neg_mul_neg : (-a) * (-b) = a * b`
   - `neg_mul : (-a) * b = -(a * b)`
   - `mul_neg : a * (-b) = -(a * b)`
5. **乘法交換律（公設 2.1）**：`mul_comm : a * b = b * a`

### 學習重點

1. **分情況證明的嵌套結構**：當需要對多個變數分情況時，可以使用嵌套的 `cases` 語句。

2. **絕對值的計算規則**：
   - 如果 \(a \geq 0\)，則 \(|a| = a\)
   - 如果 \(a \leq 0\)，則 \(|a| = -a\)

3. **乘法的符號規則**：
   - 正數 × 正數 = 正數
   - 負數 × 負數 = 正數
   - 正數 × 負數 = 負數
   - 負數 × 正數 = 負數

4. **負數的分配性質**：`-(a * b) = (-a) * b = a * (-b)`

5. **calc 用於等式鏈**：使用 `calc` 可以清晰地展示每一步的轉換。

### 相關練習

- 嘗試證明：\(|a / b| = |a| / |b|\)（當 \(b \neq 0\) 時）
- 思考為什麼需要分四種情況
- 證明：\(|a^n| = |a|^n\)（對任意自然數 \(n\)）

---

## 練習題 9：證明 |a| ≤ M ↔ -M ≤ a ≤ M（絕對值不等式的等價形式）

### 題目

**定理 1.6**：對於任意實數 \(a\) 和 \(M \geq 0\)，有 \(|a| \leq M\) 若且唯若 \(-M \leq a \leq M\)

**說明**：這個定理說明絕對值不等式 \(|a| \leq M\) 等價於 \(a\) 在區間 \([-M, M]\) 內。這是絕對值運算的一個重要性質，在分析學中經常使用。

### 證明思路

使用雙向等價證明：
1. **方向 1**：證明 \(|a| \leq M \to -M \leq a \leq M\)
   - 分情況討論 \(a\) 的符號（\(a \leq 0\) 或 \(a \geq 0\)）
   - 每種情況分別證明 \(-M \leq a\) 和 \(a \leq M\)
2. **方向 2**：證明 \(-M \leq a \leq M \to |a| \leq M\)
   - 同樣分情況討論 \(a\) 的符號
   - 每種情況分別證明 \(|a| \leq M\)

### 完整證明

```lean
theorem Theorem_1_6 (a M : ℝ) (hM : M ≥ 0): |a| ≤ M ↔ -M ≤ a ∧ a ≤ M := by
   constructor  -- 分別處理雙向等價的兩個方向
   · intro h  -- 方向 1：假設 |a| ≤ M
      have h_a : a ≤ 0 ∨ 0 ≤ a := le_total a 0  -- 對 a 分情況
      cases h_a with
      | inl ha_neg =>  -- 情況 1.1：a ≤ 0
         have h1 : |a| = -a := by rw [abs_of_nonpos ha_neg]  -- 因為 a ≤ 0，所以 |a| = -a
         have h2 : -a ≤ M := by  -- 從 |a| ≤ M 得到 -a ≤ M
            calc
               -a
               _ = |a| := h1.symm
               _ ≤ M := h
         have h3 : (-1 : ℝ) ≤ 0 := by norm_num  -- 證明 -1 ≤ 0
         have h4 : M * (-1) ≤ (-a) * (-1) := mul_le_mul_of_nonpos_right h2 h3  -- 使用負數乘法保序
         have h5 : -M = M * (-1) := by rw [mul_neg_one]  -- M * (-1) = -M
         have h6 : (-a) * (-1) = a := by  -- 證明 (-a) * (-1) = a
            calc
               (-a) * (-1)
               _ = (-1) * (-a) := by rw [mul_comm]
               _ = -(-a) := by rw [neg_one_mul]
               _ = a := by rw [neg_neg]
         have h7 : -M ≤ a := by  -- 組合得到 -M ≤ a
            calc
               -M
               _ = M * (-1) := h5
               _ ≤ (-a) * (-1) := h4
               _ = a := h6
         have h8 : a ≤ M := by  -- 因為 a ≤ 0 且 M ≥ 0
            calc
               a
               _ ≤ 0 := ha_neg
               _ ≤ M := hM
         exact ⟨h7, h8⟩  -- 組合得到 -M ≤ a ∧ a ≤ M
      | inr ha_pos =>  -- 情況 1.2：a ≥ 0
         have h1 : |a| = a := by rw [abs_of_nonneg ha_pos]  -- 因為 a ≥ 0，所以 |a| = a
         have h2 : a ≤ M := by  -- 從 |a| ≤ M 得到 a ≤ M
            calc
               a
               _ = |a| := h1.symm
               _ ≤ M := h
         have h3 : -M ≤ a := by  -- 因為 a ≥ 0 且 M ≥ 0
            calc
               -M
               _ ≤ 0 := neg_nonpos.mpr hM  -- 因為 M ≥ 0，所以 -M ≤ 0
               _ ≤ a := ha_pos  -- 因為 a ≥ 0，所以 0 ≤ a
         have h4 : a ≤ M := by  -- 從 |a| ≤ M 得到 a ≤ M
            calc
               a
               _ = |a| := h1.symm
               _ ≤ M := h
         exact ⟨h3, h4⟩  -- 組合得到 -M ≤ a ∧ a ≤ M
   · intro h  -- 方向 2：假設 -M ≤ a ∧ a ≤ M
      rcases h with ⟨h1, h2⟩  -- 分解為 h1 : -M ≤ a 和 h2 : a ≤ M
      have h_a : a ≤ 0 ∨ 0 ≤ a := le_total a 0  -- 對 a 分情況
      cases h_a with
      | inl ha_neg =>  -- 情況 2.1：a ≤ 0
         have h3 : |a| = -a := by rw [abs_of_nonpos ha_neg]  -- 因為 a ≤ 0，所以 |a| = -a
         have h4 : |a| ≤ M := by  -- 證明 |a| ≤ M
            have h4a : -a ≤ M := by  -- 從 -M ≤ a 得到 -a ≤ M
               have h4a1 : (-1 : ℝ) ≤ 0 := by norm_num  -- 證明 -1 ≤ 0
               calc
                  -a
                  _ = a * (-1) := by rw [mul_neg_one]  -- -a = a * (-1)
                  _ ≤ -M * (-1) := mul_le_mul_of_nonpos_right h1 h4a1  -- 使用負數乘法保序
                  _ = -(-M) := by rw [mul_neg_one]  -- -M * (-1) = -(-M)
                  _ = M := by rw [neg_neg]  -- -(-M) = M
            calc
               |a|
               _ = -a := h3
               _ ≤ M := h4a
         exact h4
      | inr ha_pos =>  -- 情況 2.2：a ≥ 0
         have h1 : |a| = a := by rw [abs_of_nonneg ha_pos]  -- 因為 a ≥ 0，所以 |a| = a
         have h2 : |a| ≤ M := by  -- 從 a ≤ M 得到 |a| ≤ M
            calc
               |a|
               _ = a := h1
               _ ≤ M := h2
         exact h2
```

### 證明步驟說明

#### 整體結構：雙向等價證明

這個證明使用 `constructor` 將雙向等價分成兩個方向分別證明。

#### 方向 1：|a| ≤ M → -M ≤ a ≤ M

**情況 1.1：a ≤ 0**

**步驟說明：**
1. **計算 |a|**：因為 `a ≤ 0`，所以 `|a| = -a`
2. **證明 -a ≤ M**：從 `|a| ≤ M` 得到 `-a ≤ M`
3. **證明 -M ≤ a**：
   - 使用負數乘法保序：從 `-a ≤ M` 和 `-1 ≤ 0`，得到 `M * (-1) ≤ (-a) * (-1)`
   - 簡化：`M * (-1) = -M`，`(-a) * (-1) = a`
   - 因此 `-M ≤ a`
4. **證明 a ≤ M**：因為 `a ≤ 0` 且 `M ≥ 0`，所以 `a ≤ M`
5. **組合結果**：`-M ≤ a ∧ a ≤ M`

**情況 1.2：a ≥ 0**

**步驟說明：**
1. **計算 |a|**：因為 `a ≥ 0`，所以 `|a| = a`
2. **證明 a ≤ M**：從 `|a| ≤ M` 得到 `a ≤ M`
3. **證明 -M ≤ a**：因為 `a ≥ 0` 且 `M ≥ 0`，所以 `-M ≤ 0 ≤ a`，即 `-M ≤ a`
4. **組合結果**：`-M ≤ a ∧ a ≤ M`

#### 方向 2：-M ≤ a ≤ M → |a| ≤ M

**情況 2.1：a ≤ 0**

**步驟說明：**
1. **計算 |a|**：因為 `a ≤ 0`，所以 `|a| = -a`
2. **證明 -a ≤ M**：
   - 從 `-M ≤ a`，使用負數乘法保序：`a * (-1) ≤ -M * (-1)`
   - 簡化：`a * (-1) = -a`，`-M * (-1) = M`
   - 因此 `-a ≤ M`
3. **得到結果**：`|a| = -a ≤ M`

**情況 2.2：a ≥ 0**

**步驟說明：**
1. **計算 |a|**：因為 `a ≥ 0`，所以 `|a| = a`
2. **證明 a ≤ M**：從前提 `a ≤ M` 直接得到
3. **得到結果**：`|a| = a ≤ M`

### 使用的公理和定理

1. **全序性（公設 4.1）**：`le_total : a ≤ b ∨ b ≤ a`
2. **絕對值的性質**：
   - `abs_of_nonneg : a ≥ 0 → |a| = a`
   - `abs_of_nonpos : a ≤ 0 → |a| = -a`
3. **負數乘法保序**：
   - `mul_le_mul_of_nonpos_right : c ≤ 0 → a ≤ b → b * c ≤ a * c`
4. **負數的運算性質**：
   - `mul_neg_one : a * (-1) = -a`
   - `neg_one_mul : (-1) * a = -a`
   - `neg_neg : -(-a) = a`
   - `neg_nonpos : M ≥ 0 → -M ≤ 0`
5. **乘法交換律（公設 2.1）**：`mul_comm : a * b = b * a`

### 學習重點

1. **雙向等價的證明結構**：使用 `constructor` 將 `↔` 分成兩個 `→` 分別證明。

2. **分情況證明的應用**：根據 `a` 的符號（正、負、零）分別處理，每種情況使用不同的絕對值計算規則。

3. **負數乘法保序的使用**：
   - 當乘以負數時，不等式的方向會反轉
   - `mul_le_mul_of_nonpos_right`：如果 `c ≤ 0` 且 `a ≤ b`，則 `b * c ≤ a * c`

4. **負數運算的簡化**：
   - `a * (-1) = -a`
   - `(-a) * (-1) = a`
   - 這些性質在處理絕對值不等式時非常有用

5. **區間表示**：這個定理將絕對值不等式轉換為區間表示，在分析學中非常重要。

### 相關練習

- 證明：\(|a| < M \leftrightarrow -M < a < M\)（當 \(M > 0\) 時）
- 證明：\(|a| \geq M \leftrightarrow a \leq -M \vee a \geq M\)（當 \(M \geq 0\) 時）
- 思考：為什麼需要條件 \(M \geq 0\)？

---

## 練習題 10：證明 |a| ≥ 0 且 |a| = 0 ↔ a = 0（絕對值的非負性與零性）

### 題目

**定理 1.7(1)**：對於任意實數 \(a\)，有 \(|a| \geq 0\) 且 \(|a| = 0\) 若且唯若 \(a = 0\)

**說明**：這個定理說明絕對值非負，且絕對值為零當且僅當數本身為零。這是絕對值運算的基本性質。

### 證明思路

使用雙向等價證明：
1. **方向 1**：證明 \(|a| \geq 0 \wedge |a| = 0 \to a = 0\)
   - 使用反證法，假設 \(a \neq 0\)
   - 分情況討論 \(a < 0\) 或 \(a > 0\)
   - 每種情況都推導出 \(|a| \neq 0\)，與前提矛盾
2. **方向 2**：證明 \(a = 0 \to |a| \geq 0 \wedge |a| = 0\)
   - 直接使用 \(|0| = 0\) 和 \(|a| \geq 0\) 的性質

### 完整證明

```lean
theorem Theorem_1_7_1 (a : ℝ) : |a| ≥ 0 ∧ |a| = 0 ↔ a = 0 := by
   constructor  -- 分別處理雙向等價的兩個方向
   intro h  -- 方向 1：假設 |a| ≥ 0 ∧ |a| = 0
   have h1 : |a| ≥ 0 := h.1  -- 提取 |a| ≥ 0
   have h2 : |a| = 0 := h.2  -- 提取 |a| = 0
   by_contra h_not  -- 假設 a ≠ 0（反證法）
   have h3 : a < 0 ∨ 0 < a := ne_iff_lt_or_gt.mp h_not  -- 從 a ≠ 0 得到 a < 0 或 a > 0
   cases h3 with
   | inl ha_neg =>  -- 情況 1：a < 0
      have h4 : |a| = -a := by rw [abs_of_neg ha_neg]  -- 因為 a < 0，所以 |a| = -a
      have h5 : -a > 0 := by  -- 證明 -a > 0
         have h5a : (-1 : ℝ) < 0 := by norm_num  -- 證明 -1 < 0
         calc
            -a
            _ = a * (-1) := by rw [mul_neg_one]  -- -a = a * (-1)
            _ > 0 * (-1) := mul_lt_mul_of_neg_right ha_neg h5a  -- 使用負數乘法保序（嚴格）
            _ = 0 := by rw [zero_mul]  -- 0 * (-1) = 0
      have h6 : |a| ≠ 0 := by  -- 證明 |a| ≠ 0
         rw [h4]  -- 將 |a| 替換為 -a
         exact ne_of_gt h5  -- 從 -a > 0 得到 -a ≠ 0
      exact h6 h2  -- 與 h2 : |a| = 0 矛盾
   | inr ha_pos =>  -- 情況 2：0 < a
      have h4 : |a| = a := by rw [abs_of_pos ha_pos]  -- 因為 0 < a，所以 |a| = a
      have h5 : |a| ≠ 0 := by  -- 證明 |a| ≠ 0
         rw [h4]  -- 將 |a| 替換為 a
         exact ne_of_gt ha_pos  -- 從 a > 0 得到 a ≠ 0
      exact h5 h2  -- 與 h2 : |a| = 0 矛盾
   intro h  -- 方向 2：假設 a = 0
   have h1 : |a| = 0 := by  -- 證明 |a| = 0
      calc
         |a|
         _ = |0| := by rw [h]  -- 將 a 替換為 0
         _ = 0 := abs_zero  -- |0| = 0
   have h2 : |a| ≥ 0 := abs_nonneg a  -- |a| ≥ 0（絕對值非負）
   exact ⟨h2, h1⟩  -- 組合得到 |a| ≥ 0 ∧ |a| = 0
```

### 證明步驟說明

#### 整體結構：雙向等價證明

這個證明使用 `constructor` 將雙向等價分成兩個方向分別證明。

#### 方向 1：|a| ≥ 0 ∧ |a| = 0 → a = 0

**證明方法：反證法**

**步驟說明：**
1. **假設結論不成立**：假設 \(a \neq 0\)
2. **分類討論**：從 \(a \neq 0\) 得到 \(a < 0\) 或 \(a > 0\)

**情況 1：a < 0**

**步驟說明：**
1. **計算 |a|**：因為 `a < 0`，所以 `|a| = -a`
2. **證明 -a > 0**：
   - 使用負數乘法保序：從 `a < 0` 和 `-1 < 0`，得到 `a * (-1) > 0 * (-1)`
   - 簡化：`a * (-1) = -a`，`0 * (-1) = 0`
   - 因此 `-a > 0`
3. **推導矛盾**：從 `-a > 0` 得到 `-a ≠ 0`，即 `|a| ≠ 0`，與前提 `|a| = 0` 矛盾

**情況 2：0 < a**

**步驟說明：**
1. **計算 |a|**：因為 `0 < a`，所以 `|a| = a`
2. **推導矛盾**：從 `a > 0` 得到 `a ≠ 0`，即 `|a| ≠ 0`，與前提 `|a| = 0` 矛盾

#### 方向 2：a = 0 → |a| ≥ 0 ∧ |a| = 0

**步驟說明：**
1. **證明 |a| = 0**：
   - 從 `a = 0`，得到 `|a| = |0|`
   - 使用 `abs_zero`：`|0| = 0`
   - 因此 `|a| = 0`
2. **證明 |a| ≥ 0**：
   - 使用 `abs_nonneg`：`|a| ≥ 0`（絕對值非負）
3. **組合結果**：`|a| ≥ 0 ∧ |a| = 0`

### 使用的公理和定理

1. **反證法**：`by_contra` 用於假設結論不成立
2. **全序性**：`ne_iff_lt_or_gt : a ≠ 0 ↔ a < 0 ∨ a > 0`
3. **絕對值的性質**：
   - `abs_of_neg : a < 0 → |a| = -a`
   - `abs_of_pos : 0 < a → |a| = a`
   - `abs_zero : |0| = 0`
   - `abs_nonneg : |a| ≥ 0`
4. **負數乘法保序（嚴格）**：
   - `mul_lt_mul_of_neg_right : c < 0 → a < b → b * c < a * c`
5. **負數的運算性質**：
   - `mul_neg_one : a * (-1) = -a`
   - `zero_mul : 0 * a = 0`
6. **不等於的性質**：
   - `ne_of_gt : a > 0 → a ≠ 0`

### 學習重點

1. **反證法的應用**：當直接證明困難時，可以假設結論不成立，然後推導出矛盾。

2. **分情況證明的必要性**：根據 \(a\) 的符號（正、負、零）分別處理，每種情況使用不同的絕對值計算規則。

3. **負數乘法保序（嚴格不等式）**：
   - 當乘以負數時，嚴格不等式的方向會反轉
   - `mul_lt_mul_of_neg_right`：如果 `c < 0` 且 `a < b`，則 `b * c < a * c`

4. **絕對值的基本性質**：
   - 絕對值非負：`|a| ≥ 0`
   - 絕對值為零當且僅當數本身為零：`|a| = 0 ↔ a = 0`

5. **矛盾的使用**：在反證法中，推導出與已知前提矛盾的結論，從而證明原命題成立。

### 相關練習

- 證明：\(|a| > 0 \leftrightarrow a \neq 0\)
- 證明：\(|a| = |b| \leftrightarrow a = b \vee a = -b\)
- 思考：為什麼絕對值非負這個性質很重要？

---

## 後續練習題

（此處將添加更多第一章的練習題）
