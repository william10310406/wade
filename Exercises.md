# 第一章：實數系統 練習題

這份教材包含第一章的練習題，每題都附有詳細的證明步驟和說明。

---

## 體公設與順序公設語法說明

在進行練習題之前，我們需要先了解實數系統的基本公設及其在 Lean 中的語法表達。實數滿足有序域（Ordered Field）的所有公理，這些公理構成了我們證明所有定理的基礎。

### 一、體公設（Field Axioms）

體公設定義了實數的加法、乘法和它們之間的關係。

#### 1. 加法公理

**公設 1.1：加法交換律（Additive Commutativity）**
- **語法**：`∀ a b : ℝ, a + b = b + a`
- **說明**：`∀ a b : ℝ` 是 `∀ a : ℝ, ∀ b : ℝ` 的簡寫
- **Lean 定理**：`add_comm`
- **完整語法範例**：`example (a b : ℝ) : a + b = b + a := add_comm a b`

**公設 1.2：加法結合律（Additive Associativity）**
- **語法**：`∀ a b c : ℝ, (a + b) + c = a + (b + c)`
- **說明**：括號表示運算順序，無論先加哪兩個，結果都相同
- **Lean 定理**：`add_assoc`
- **完整語法範例**：`example (a b c : ℝ) : (a + b) + c = a + (b + c) := add_assoc a b c`

**公設 1.3：加法單位元（零元）（Additive Identity）**
- **語法**：`∀ a : ℝ, a + 0 = a` 和 `∀ a : ℝ, 0 + a = a`
- **說明**：`0 : ℝ` 表示實數零，零是加法的單位元
- **Lean 定理**：`add_zero : a + 0 = a` 和 `zero_add : 0 + a = a`

**公設 1.4：加法逆元（負元）（Additive Inverse）**
- **語法**：`∀ a : ℝ, a + (-a) = 0` 和 `∀ a : ℝ, (-a) + a = 0`
- **說明**：`-a` 表示 a 的加法逆元（負數），每個數都有加法逆元
- **Lean 定理**：`add_neg_cancel : a + (-a) = 0` 和 `neg_add_cancel : (-a) + a = 0`

#### 2. 乘法公理

**公設 2.1：乘法交換律（Multiplicative Commutativity）**
- **語法**：`∀ a b : ℝ, a * b = b * a`
- **Lean 定理**：`mul_comm`

**公設 2.2：乘法結合律（Multiplicative Associativity）**
- **語法**：`∀ a b c : ℝ, (a * b) * c = a * (b * c)`
- **Lean 定理**：`mul_assoc`

**公設 2.3：乘法單位元（Multiplicative Identity）**
- **語法**：`∀ a : ℝ, a * 1 = a` 和 `∀ a : ℝ, 1 * a = a`
- **說明**：`1 : ℝ` 表示實數一，一是乘法的單位元
- **Lean 定理**：`mul_one : a * 1 = a` 和 `one_mul : 1 * a = a`

**公設 2.4：乘法逆元（倒數，對非零元）（Multiplicative Inverse）**
- **語法**：`∀ a : ℝ, a ≠ 0 → a * a⁻¹ = 1`
- **說明**：
  - `a⁻¹` 或 `1 / a` 表示 a 的乘法逆元（倒數）
  - `a ≠ 0` 表示 a 不等於零
  - `→` 表示蘊含（implies），這裡表示"如果 a ≠ 0，則..."
- **Lean 定理**：`mul_inv_cancel`（透過類型類解析自動應用）
- **注意**：`a / a = 1` 等價於 `a * a⁻¹ = 1`，因為 `a / a = a * a⁻¹`

#### 3. 分配律（Distributivity）

**公設 3.1：左分配律**
- **語法**：`∀ a b c : ℝ, a * (b + c) = a * b + a * c`
- **Lean 定理**：`mul_add`

**公設 3.2：右分配律**
- **語法**：`∀ a b c : ℝ, (a + b) * c = a * c + b * c`
- **Lean 定理**：`add_mul`

### 二、順序公設（Order Axioms）

順序公設定義了實數之間的大小關係。

**公設 4.1：全序性（Total Order）**
- **語法**：`∀ a b : ℝ, a ≤ b ∨ b ≤ a`
- **說明**：
  - `≤` 表示小於等於關係
  - `∨` 表示邏輯或（or）
  - 表示任意兩個實數都可以比較大小
- **Lean 定理**：`le_total`

**公設 4.2：傳遞性（Transitivity）**
- **語法**：`∀ a b c : ℝ, a ≤ b → b ≤ c → a ≤ c`
- **說明**：`→` 表示蘊含，可以鏈式使用。如果 a ≤ b 且 b ≤ c，則 a ≤ c
- **Lean 定理**：`le_trans`

**公設 4.3：反身性（Reflexivity）**
- **語法**：`∀ a : ℝ, a ≤ a`
- **說明**：每個數都小於等於自己
- **Lean 定理**：`le_refl`

**公設 4.4：加法保序（Order Preservation under Addition）**
- **語法**：`∀ a b c : ℝ, a ≤ b → a + c ≤ b + c`
- **說明**：如果 a ≤ b，則兩邊同時加 c 後仍保持 ≤
- **Lean 定理**：`add_le_add_right`

**公設 4.5：乘法保序（正數）（Order Preservation under Multiplication by Positive）**
- **語法**：`∀ a b c : ℝ, 0 ≤ c → a ≤ b → a * c ≤ b * c`
- **說明**：如果 c ≥ 0 且 a ≤ b，則 a * c ≤ b * c
- **Lean 定理**：`mul_le_mul_of_nonneg_right`

### 三、常用語法符號

在 Lean 中，我們會用到以下符號：

- **全稱量詞**：`∀` 表示"對於所有"（for all）
- **存在量詞**：`∃` 表示"存在"（exists）
- **蘊含**：`→` 表示"如果...則..."（implies）
- **雙向蘊含**：`↔` 表示"若且唯若"（iff）
- **邏輯與**：`∧` 表示"且"（and）
- **邏輯或**：`∨` 表示"或"（or）
- **邏輯非**：`¬` 表示"非"（not）
- **等於**：`=` 表示等於
- **小於等於**：`≤` 表示小於等於
- **大於等於**：`≥` 表示大於等於
- **小於**：`<` 表示小於
- **大於**：`>` 表示大於

### 四、在證明中使用公設

在 Lean 中，這些公設通常以定理的形式存在，我們可以直接使用：

```lean
-- 使用加法交換律
example (a b : ℝ) : a + b = b + a := add_comm a b

-- 使用加法結合律
example (a b c : ℝ) : (a + b) + c = a + (b + c) := add_assoc a b c

-- 使用分配律
example (a b c : ℝ) : a * (b + c) = a * b + a * c := mul_add a b c
example (a b c : ℝ) : (a + b) * c = a * c + b * c := add_mul a b c
```

在證明中，我們可以使用 `rw`（rewrite）策略來應用這些定理：

```lean
example (a : ℝ) : a + 0 = a := by
   rw [add_zero]  -- 使用 add_zero 定理
```

或者使用 `←` 來反向應用：

```lean
example (a : ℝ) : a = a + 0 := by
   rw [← add_zero]  -- 反向使用 add_zero 定理
```

---

## 練習題 1：證明 0 · a = 0

### 題目

**定理**：對於任意實數 \(a\)，有 \(0 \cdot a = 0\)

**說明**：這個定理說明零乘以任何數都等於零。這是實數系統中一個重要的基本性質。

### 證明思路

使用以下基本公理：
- 分配律（公設 3）
- 加法結合律（公設 1.2）
- 加法單位元（公設 1.3）
- 加法逆元（公設 1.4）

### 完整證明

```lean
example (a : ℝ) : 0 * a = 0 := by
   -- 步驟 1：使用加法單位元公理（公設 1.3）
   -- `add_zero` 定理：`a + 0 = a`
   -- 這裡將 `0 * a` 寫成 `0 * a + 0` 的形式
   have h0a_add_0 : 0 * a = 0 * a + 0 := by
      rw [add_zero]

   -- 步驟 2：使用加法逆元公理（公設 1.4）
   -- `add_neg_cancel` 定理：`a + (-a) = 0`
   -- 取其對稱形式：`0 = a + (-a)`
   -- 這裡 `a` 是 `0 * a`，所以 `0 = 0 * a + (- (0 * a))`
   have h0_eq_0a_add_0a : 0 = 0 * a + (- (0 * a)) :=
      (add_neg_cancel (0 * a)).symm

   -- 步驟 3：將步驟 1 中的 `0` 替換成步驟 2 中的表達式
   -- 從 `0 * a = 0 * a + 0` 得到 `0 * a = 0 * a + (0 * a + (- (0 * a)))`
   -- 使用 `convert` 和 `rw [← h0_eq_0a_add_0a]` 來替換
   have h3 : 0 * a = 0 * a + (0 * a + (- (0 * a))) := by
      -- 從 h0a_add_0: 0 * a = 0 * a + 0
      -- 把右邊的 0 替換成 0 * a + (- (0 * a))（用 h0_eq_0a_add_0a 的反向）
      convert h0a_add_0 using 2
      rw [← h0_eq_0a_add_0a]

   -- 步驟 4：使用加法結合律（公設 1.2）
   -- `add_assoc` 定理：`(a + b) + c = a + (b + c)`
   -- 取其對稱形式：`a + (b + c) = (a + b) + c`
   -- 這裡將 `0 * a + (0 * a + (- (0 * a)))` 重組為 `(0 * a + 0 * a) + (- (0 * a))`
   have h4 : 0 * a + (0 * a + - (0 * a)) = (0 * a + 0 * a) + (- (0 * a)) :=
      (add_assoc (0 * a) (0 * a) (- (0 * a))).symm

   -- 步驟 5：使用分配律（公設 3）和加法單位元
   -- 首先用右分配律將 `0 * a + 0 * a` 寫成 `(0 + 0) * a`
   -- 然後用 `add_zero` 將 `(0 + 0) * a` 簡化為 `0 * a`
   -- 最終得到 `(0 * a + 0 * a) + (- (0 * a)) = 0 * a + (-(0 * a))`
   have h5 : (0 * a + 0 * a) + (- (0 * a)) = 0 * a + (-(0 * a)) := by
      -- 子步驟 5.1：使用右分配律 `add_mul` 的逆方向
      -- `add_mul` 定理：`(a + b) * c = a * c + b * c`
      -- 逆方向：`a * c + b * c = (a + b) * c`
      -- 這裡 `a = 0`, `b = 0`, `c = a`，所以 `0 * a + 0 * a = (0 + 0) * a`
      have h6 : 0 * a + 0 * a = (0 + 0) * a := by
         rw [← add_mul]
      -- 子步驟 5.2：使用加法單位元 `add_zero`
      -- `add_zero` 定理：`a + 0 = a`
      -- 這裡 `0 + 0 = 0`，所以 `(0 + 0) * a = 0 * a`
      rw [h6]
      rw [add_zero]

   -- 步驟 6：使用加法逆元公理（公設 1.4）
   -- `add_neg_cancel` 定理：`a + (-a) = 0`
   -- 這裡 `a` 是 `0 * a`，所以 `0 * a + (-(0 * a)) = 0`
   have h7 : 0 * a + (-(0 * a)) = 0 := add_neg_cancel (0 * a)

   -- 最終步驟：使用 `calc` 將以上所有步驟串聯起來
   -- 這是一個等式鏈式證明，每一步都使用前面建立的引理
   calc
      0 * a = 0 * a + (0 * a + - (0 * a)) := h3
      _ = (0 * a + 0 * a) + (- (0 * a)) := h4
      _ = 0 * a + (-(0 * a)) := h5
      _ = 0 := h7
```

### 證明步驟說明

#### 步驟 1：引入加法單位元
我們從 `0 * a = 0 * a + 0` 開始，這是加法單位元公理（`add_zero`）的直接應用。

#### 步驟 2：建立零的等價表達
使用加法逆元公理，我們知道 `0 = 0 * a + (-(0 * a))`。這為後續的替換做準備。

#### 步驟 3：替換零
將步驟 1 中的 `0` 替換成步驟 2 中的表達式，得到：
\[
0 \cdot a = 0 \cdot a + (0 \cdot a + (-(0 \cdot a)))
\]

#### 步驟 4：應用結合律
使用加法結合律重組表達式：
\[
0 \cdot a + (0 \cdot a + (-(0 \cdot a))) = (0 \cdot a + 0 \cdot a) + (-(0 \cdot a))
\]

#### 步驟 5：應用分配律
這是關鍵步驟：
1. 使用右分配律的逆方向：`0 \cdot a + 0 \cdot a = (0 + 0) \cdot a`
2. 使用加法單位元：`(0 + 0) \cdot a = 0 \cdot a`

因此得到：`(0 \cdot a + 0 \cdot a) + (-(0 \cdot a)) = 0 \cdot a + (-(0 \cdot a))`

#### 步驟 6：應用加法逆元
使用加法逆元公理：`0 \cdot a + (-(0 \cdot a)) = 0`

#### 最終：鏈式證明
使用 `calc` 將所有步驟串聯起來，完成證明。

### 使用的公理和定理

1. **加法單位元（公設 1.3）**：`add_zero : a + 0 = a`
2. **加法逆元（公設 1.4）**：`add_neg_cancel : a + (-a) = 0`
3. **加法結合律（公設 1.2）**：`add_assoc : (a + b) + c = a + (b + c)`
4. **右分配律（公設 3）**：`add_mul : (a + b) * c = a * c + b * c`

### 學習重點

1. **分配律的應用**：這是證明中最重要的步驟，展示了如何將 `0 \cdot a + 0 \cdot a` 轉換為 `(0 + 0) \cdot a`。

2. **等式鏈式證明**：使用 `calc` 可以清晰地展示證明的每一步。

3. **公理的組合使用**：這個證明展示了如何組合使用多個基本公理來證明一個看似簡單但重要的定理。

### 相關練習

- 嘗試證明 `a · 0 = 0`（使用類似的方法）
- 思考為什麼需要分配律來證明這個定理
- 比較這個證明與直接使用 `zero_mul` 定理的差異

---

## 練習題 2：證明 -a = (-1) · a

### 題目

**定理**：對於任意實數 \(a\)，有 \(-a = (-1) \cdot a\)

**說明**：這個定理說明一個數的負數等於 -1 乘以這個數。這是實數系統中另一個重要的基本性質，展示了負數與乘法的關係。

### 證明思路

使用以下基本公理和定理：
- 乘法單位元（公設 2.3）
- 右分配律（公設 3.2）
- 加法逆元（公設 1.4）
- 零乘任何數等於零（練習題 1 的結果）
- `eq_neg_of_add_eq_zero_right` 定理

### 完整證明

```lean
example (a : ℝ) : -a = (-1) * a := by
   -- 步驟 1：證明 a + (-1) * a = 0
   -- 這是證明的關鍵中間步驟，我們將使用分配律和加法逆元
   have h1 : a + (-1) * a = 0 := by
      calc
         a + (-1) * a
         -- 子步驟 1.1：使用乘法單位元（公設 2.3）
         -- `one_mul` 定理：`1 * a = a`
         -- 將 `a` 寫成 `1 * a` 的形式，以便後續使用分配律
         _ = 1 * a + (-1) * a := by rw [one_mul a]
         -- 子步驟 1.2：使用右分配律（公設 3.2）的逆方向
         -- `add_mul` 定理：`(a + b) * c = a * c + b * c`
         -- 逆方向：`a * c + b * c = (a + b) * c`
         -- 這裡 `a = 1`, `b = -1`, `c = a`，所以 `1 * a + (-1) * a = (1 + (-1)) * a`
         _ = (1 + (-1)) * a := by rw [← add_mul]
         -- 子步驟 1.3：使用加法逆元（公設 1.4）
         -- `add_neg_cancel` 定理：`a + (-a) = 0`
         -- 這裡 `a = 1`，所以 `1 + (-1) = 0`
         _ = 0 * a := by rw [add_neg_cancel (1 : ℝ)]
         -- 子步驟 1.4：使用零乘任何數等於零（前面已證明的定理）
         -- `zero_mul` 定理：`0 * a = 0`
         _ = 0 := by rw [zero_mul]
   
   -- 步驟 2：從 a + (-1) * a = 0 推導出 -a = (-1) * a
   -- 使用 `eq_neg_of_add_eq_zero_right` 定理
   -- 這個定理說：如果 `a + b = 0`，則 `b = -a`
   -- 這裡 `a = a`, `b = (-1) * a`，所以 `(-1) * a = -a`
   -- 然後使用 `eq_comm` 交換等式的兩邊，得到 `-a = (-1) * a`
   rw [eq_comm]
   exact eq_neg_of_add_eq_zero_right h1
```

### 證明步驟說明

#### 步驟 1：證明 a + (-1) · a = 0

這是證明的關鍵中間步驟。我們使用 `calc` 來建立等式鏈：

1. **子步驟 1.1**：使用乘法單位元將 `a` 寫成 `1 * a`
   - 這使得我們可以將 `a + (-1) * a` 寫成 `1 * a + (-1) * a`
   - 為後續使用分配律做準備

2. **子步驟 1.2**：使用右分配律的逆方向
   - 將 `1 * a + (-1) * a` 合併為 `(1 + (-1)) * a`
   - 這是分配律的逆應用

3. **子步驟 1.3**：使用加法逆元
   - `1 + (-1) = 0`，所以 `(1 + (-1)) * a = 0 * a`

4. **子步驟 1.4**：使用零乘任何數等於零
   - 這是練習題 1 的結果：`0 * a = 0`

#### 步驟 2：推導出最終結果

從 `a + (-1) * a = 0` 推導出 `-a = (-1) * a`：

1. 使用 `eq_neg_of_add_eq_zero_right` 定理
   - 這個定理說：如果 `a + b = 0`，則 `b = -a`
   - 這裡 `b = (-1) * a`，所以 `(-1) * a = -a`

2. 使用 `eq_comm` 交換等式的兩邊
   - 從 `(-1) * a = -a` 得到 `-a = (-1) * a`

### 使用的公理和定理

1. **乘法單位元（公設 2.3）**：`one_mul : 1 * a = a`
2. **右分配律（公設 3.2）**：`add_mul : (a + b) * c = a * c + b * c`
3. **加法逆元（公設 1.4）**：`add_neg_cancel : a + (-a) = 0`
4. **零乘任何數等於零**：`zero_mul : 0 * a = 0`（練習題 1 的結果）
5. **等式交換律**：`eq_comm : a = b ↔ b = a`
6. **加法逆元的推論**：`eq_neg_of_add_eq_zero_right : a + b = 0 → b = -a`

### 學習重點

1. **分配律的逆應用**：這個證明展示了如何將 `1 * a + (-1) * a` 合併為 `(1 + (-1)) * a`，這是分配律的逆方向應用。

2. **中間步驟的重要性**：證明 `a + (-1) * a = 0` 是關鍵的中間步驟，它連接了分配律和最終結果。

3. **定理的組合使用**：這個證明展示了如何組合使用多個基本公理和已證明的定理來證明新的定理。

4. **等式變換的技巧**：使用 `eq_comm` 來交換等式的兩邊，這是在證明中常用的技巧。

### 相關練習

- 嘗試證明 `(-a) * b = -(a * b)`（使用類似的方法）
- 思考為什麼需要先證明 `a + (-1) * a = 0`
- 比較這個證明與直接使用 `neg_one_mul` 定理的差異（如果存在）

---

## 練習題 3：證明 -(-a) = a

### 題目

**定理**：對於任意實數 \(a\)，有 \(-(-a) = a\)

**說明**：這個定理說明一個數的負數的負數等於原數。這是實數系統中一個重要的基本性質，展示了負數運算的基本規則。

### 證明思路

使用以下基本公理：
- 加法逆元（公設 1.4）
- 加法交換律（公設 1.1）
- 加法消去律（可從體公設推導）

### 完整證明

```lean
example (a : ℝ) : -(-a) = a := by
   -- 步驟 1：使用加法逆元公理（公設 1.4）
   -- `add_neg_cancel` 定理：`a + (-a) = 0`
   -- 對 `a` 應用：`a + (-a) = 0`
   have h1 : a + (-a) = 0 := add_neg_cancel a
   -- 對 `-a` 應用：`(-a) + (-(-a)) = 0`
   -- 這表示 `-a` 的加法逆元是 `-(-a)`
   have h2 : (-a) + (-(-a)) = 0 := add_neg_cancel (-a)
   
   -- 步驟 2：使用加法交換律（公設 1.1）
   -- `add_comm` 定理：`a + b = b + a`
   -- 將 h1 轉換為 `(-a) + a = 0` 的形式
   -- 這樣我們就有兩個以 `-a` 開頭的等式，方便後續使用消去律
   have h3 : (-a) + a = 0 := by rw [add_comm, h1]
   
   -- 步驟 3：使用加法消去律
   -- 如果 `x + y = 0` 且 `x + z = 0`，則 `y = z`
   -- 這裡 `x = -a`, `y = a`, `z = -(-a)`
   -- 從 `(-a) + a = 0` 和 `(-a) + (-(-a)) = 0` 得到 `a = -(-a)`
   -- 然後使用 `eq_comm` 交換等式的兩邊，得到 `-(-a) = a`
   have h5 : a = -(-a) := by
      -- 子步驟 3.1：建立等式 `(-a) + a = (-a) + (-(-a))`
      -- 我們有 `(-a) + a = 0`（h3）和 `(-a) + (-(-a)) = 0`（h2）
      -- 因為兩邊都等於 0，所以 `(-a) + a = (-a) + (-(-a))`
      have h6 : (-a) + a = (-a) + (-(-a)) := by
         rw [h3, h2]
      -- 子步驟 3.2：使用左消去律 `add_left_cancel`
      -- `add_left_cancel` 定理：如果 `a + b = a + c`，則 `b = c`
      -- 這裡 `a = -a`, `b = a`, `c = -(-a)`
      -- 從 `(-a) + a = (-a) + (-(-a))` 得到 `a = -(-a)`
      exact add_left_cancel h6
   
   -- 步驟 4：交換等式的兩邊
   -- 使用 `eq_comm` 從 `a = -(-a)` 得到 `-(-a) = a`
   rw [eq_comm]
   exact h5
```

### 證明步驟說明

#### 步驟 1：建立兩個加法逆元等式

使用加法逆元公設（公設 1.4）建立兩個關鍵等式：

1. **對 `a` 應用**：`a + (-a) = 0`
   - 這表示 `-a` 是 `a` 的加法逆元

2. **對 `-a` 應用**：`(-a) + (-(-a)) = 0`
   - 這表示 `-(-a)` 是 `-a` 的加法逆元

#### 步驟 2：使用交換律統一形式

使用加法交換律（公設 1.1）將第一個等式轉換為：
\[
(-a) + a = 0
\]

這樣我們就有兩個以 `-a` 開頭的等式，為後續使用消去律做準備。

#### 步驟 3：應用加法消去律

這是證明的關鍵步驟：

1. **建立等式**：從 `(-a) + a = 0` 和 `(-a) + (-(-a)) = 0`，我們得到：
   \[
   (-a) + a = (-a) + (-(-a))
   \]

2. **應用左消去律**：使用 `add_left_cancel` 定理
   - 如果 `a + b = a + c`，則 `b = c`
   - 這裡 `a = -a`, `b = a`, `c = -(-a)`
   - 因此得到：`a = -(-a)`

#### 步驟 4：交換等式兩邊

使用 `eq_comm` 從 `a = -(-a)` 得到最終結果：`-(-a) = a`

### 使用的公理和定理

1. **加法逆元（公設 1.4）**：`add_neg_cancel : a + (-a) = 0`
2. **加法交換律（公設 1.1）**：`add_comm : a + b = b + a`
3. **加法消去律**：`add_left_cancel : a + b = a + c → b = c`
4. **等式交換律**：`eq_comm : a = b ↔ b = a`

### 學習重點

1. **消去律的應用**：這個證明展示了如何使用加法消去律來比較兩個表達式。當我們有 `x + y = 0` 和 `x + z = 0` 時，可以推導出 `y = z`。

2. **交換律的戰略使用**：通過使用交換律將等式轉換為相同的形式（都以 `-a` 開頭），我們可以應用消去律。

3. **只使用基本公設**：這個證明完全基於體公設，沒有使用高階定理，展示了如何從基本公設推導出重要的性質。

4. **負數運算的基本規則**：這個定理是負數運算的基礎，在後續的證明中會經常使用。

### 相關練習

- 嘗試證明 `(-a) * b = -(a * b)`（使用類似的方法）
- 思考為什麼需要交換律來統一等式的形式
- 證明加法消去律可以從體公設推導出來

---

## 練習題 4：證明 -(a - b) = b - a

### 題目

**定理**：對於任意實數 \(a, b\)，有 \(-(a - b) = b - a\)

**說明**：這個定理說明一個減法的負數等於交換被減數和減數後的減法。這是實數系統中減法運算的一個重要性質。

### 證明思路

使用以下基本公理和已證明的定理：
- 減法轉加法的性質：`sub_eq_add_neg`
- 負數與乘法的關係（練習題 2）：`-a = (-1) * a`
- 左分配律（公設 3.1）
- 負數的負數等於原數（練習題 3）：`-(-a) = a`
- 加法交換律（公設 1.1）

### 完整證明

```lean
example (a b : ℝ) : -(a - b) = b - a := by
   calc
      -(a - b)
      -- 步驟 1：將減法轉換為加法形式
      -- `sub_eq_add_neg` 定理：`a - b = a + (-b)`
      -- 所以 `-(a - b) = -(a + (-b))`
      _ = -(a + (-b)) := by rw [sub_eq_add_neg]
      
      -- 步驟 2：使用負數與乘法的關係（練習題 2 的結果）
      -- `neg_one_mul` 定理：`-a = (-1) * a`
      -- 逆方向：`-x = (-1) * x`
      -- 這裡 `x = a + (-b)`，所以 `-(a + (-b)) = (-1) * (a + (-b))`
      _ = (-1) * (a + (-b)) := by rw [← neg_one_mul]
      
      -- 步驟 3：使用左分配律（公設 3.1）
      -- `mul_add` 定理：`a * (b + c) = a * b + a * c`
      -- 這裡 `a = -1`, `b = a`, `c = -b`
      -- 所以 `(-1) * (a + (-b)) = (-1) * a + (-1) * (-b)`
      _ = (-1) * a + (-1) * (-b) := by rw [mul_add]
      
      -- 步驟 4：使用負數與乘法的關係
      -- `neg_one_mul` 定理：`(-1) * a = -a`
      -- 所以 `(-1) * a + (-1) * (-b) = (-a) + (-1) * (-b)`
      _ = (-a) + (-1) * (-b) := by rw [neg_one_mul]
      
      -- 步驟 5：使用負數的負數等於原數（練習題 3 的結果）
      -- `neg_one_mul` 定理：`(-1) * (-b) = -(-b)`
      -- `neg_neg` 定理：`-(-b) = b`
      -- 所以 `(-a) + (-1) * (-b) = (-a) + b`
      _ = (-a) + b := by rw [neg_one_mul, neg_neg]
      
      -- 步驟 6：使用加法交換律（公設 1.1）
      -- `add_comm` 定理：`a + b = b + a`
      -- 所以 `(-a) + b = b + (-a)`
      _ = b + (-a) := by rw [add_comm]
      
      -- 步驟 7：轉換回減法形式
      -- `sub_eq_add_neg` 定理的逆方向：`a + (-b) = a - b`
      -- 所以 `b + (-a) = b - a`
      _ = b - a := by rw [← sub_eq_add_neg]
```

### 證明步驟說明

#### 步驟 1：將減法轉換為加法

使用 `sub_eq_add_neg` 將 `a - b` 轉換為 `a + (-b)`，這樣我們就可以使用加法的性質。

#### 步驟 2：使用負數與乘法的關係

使用練習題 2 的結果：`-x = (-1) * x`，將 `-(a + (-b))` 轉換為 `(-1) * (a + (-b))`。

#### 步驟 3：應用左分配律

使用左分配律（公設 3.1）將 `(-1) * (a + (-b))` 展開為 `(-1) * a + (-1) * (-b)`。

#### 步驟 4：簡化第一項

使用 `neg_one_mul` 將 `(-1) * a` 簡化為 `-a`。

#### 步驟 5：簡化第二項

使用 `neg_one_mul` 和 `neg_neg`（練習題 3 的結果）將 `(-1) * (-b)` 簡化為 `b`。

#### 步驟 6：使用交換律

使用加法交換律（公設 1.1）將 `(-a) + b` 轉換為 `b + (-a)`。

#### 步驟 7：轉換回減法

使用 `sub_eq_add_neg` 的逆方向將 `b + (-a)` 轉換回 `b - a`。

### 使用的公理和定理

1. **減法轉加法**：`sub_eq_add_neg : a - b = a + (-b)`
2. **負數與乘法的關係（練習題 2）**：`neg_one_mul : -a = (-1) * a`
3. **左分配律（公設 3.1）**：`mul_add : a * (b + c) = a * b + a * c`
4. **負數的負數等於原數（練習題 3）**：`neg_neg : -(-a) = a`
5. **加法交換律（公設 1.1）**：`add_comm : a + b = b + a`

### 學習重點

1. **calc 的清晰性**：使用 `calc` 建立等式鏈比大量 `rw` 更清晰，每一步的轉換都清楚可見。

2. **定理的組合使用**：這個證明展示了如何組合使用多個已證明的定理（練習題 2 和 3）來證明新的定理。

3. **減法與加法的轉換**：通過在減法和加法之間轉換，我們可以利用加法的性質來處理減法問題。

4. **負數運算的性質**：這個定理是負數運算的重要性質，在後續的證明中會經常使用。

### 相關練習

- 嘗試證明 `(a - b) - c = a - (b + c)`（使用類似的方法）
- 思考為什麼需要將減法轉換為加法
- 比較這個證明與使用消去律的證明方法的差異

---

## 練習題 5：證明 ab = 0 → a = 0 ∨ b = 0（零乘積性質）

### 題目

**定理**：對於任意實數 \(a, b\)，如果 \(a \cdot b = 0\)，則 \(a = 0\) 或 \(b = 0\)

**說明**：這個定理說明如果兩個數的乘積為零，則至少有一個為零。這是實數系統中一個重要的性質，在解方程時經常使用。

### 證明思路

使用反證法：
1. 假設結論不成立：\(a \neq 0\) 且 \(b \neq 0\)
2. 從 \(a \cdot b = 0\) 和 \(a \neq 0\) 推導出 \(b = 0\)
3. 這與 \(b \neq 0\) 矛盾
4. 因此原結論成立

### 完整證明

```lean
example (a b : ℝ) : a * b = 0 → a = 0 ∨ b = 0 := by
   -- 步驟 1：引入前提
   -- 假設 a * b = 0
   intro h
   
   -- 步驟 2：使用反證法
   -- 假設結論不成立：a ≠ 0 且 b ≠ 0
   by_contra h_not
   -- h_not 是 ¬(a = 0 ∨ b = 0)，即 a ≠ 0 且 b ≠ 0
   
   -- 步驟 3：使用德摩根定律展開否定
   -- `push_neg` 將 ¬(a = 0 ∨ b = 0) 轉換為 a ≠ 0 ∧ b ≠ 0
   push_neg at h_not
   
   -- 步驟 4：分解假設
   -- 從 h_not : a ≠ 0 ∧ b ≠ 0 得到兩個假設
   have ha_neq_0 : a ≠ 0 := h_not.left
   have hb_neq_0 : b ≠ 0 := h_not.right
   
   -- 步驟 5：從 a * b = 0 和 a ≠ 0 推導出 b = 0
   -- 這是反證法的關鍵步驟
   have hb_eq_0 : b = 0 := by
      calc
         b
         -- 子步驟 5.1：使用乘法單位元（公設 2.3）
         -- `one_mul` 定理：`1 * b = b`
         _ = 1 * b := by rw [one_mul]
         -- 子步驟 5.2：使用乘法逆元（公設 2.4）
         -- 因為 a ≠ 0，所以 a 有乘法逆元 a⁻¹
         -- `mul_inv_cancel` 定理：`a * a⁻¹ = 1`
         -- 使用 `field_simp` 自動處理類型推斷，將 1 替換為 a * a⁻¹
         _ = (a * a⁻¹) * b := by
            field_simp [ha_neq_0]
         -- 子步驟 5.3：使用乘法交換律和結合律（公設 2.1, 2.2）
         -- `mul_comm` 定理：`a * a⁻¹ = a⁻¹ * a`
         -- `mul_assoc` 定理：`(a⁻¹ * a) * b = a⁻¹ * (a * b)`
         _ = a⁻¹ * (a * b) := by rw [mul_comm a a⁻¹, mul_assoc]
         -- 子步驟 5.4：使用前提 h : a * b = 0
         -- 將 a * b 替換為 0
         _ = a⁻¹ * 0 := by rw [h]
         -- 子步驟 5.5：使用零乘任何數等於零（練習題 1 的結果）
         -- `mul_zero` 定理：`a * 0 = 0`
         _ = 0 := by rw [mul_zero]
   
   -- 步驟 6：得出矛盾
   -- 我們有 hb_neq_0 : b ≠ 0 和 hb_eq_0 : b = 0
   -- 這兩個命題矛盾，因此原假設不成立
   -- 所以 a = 0 ∨ b = 0 成立
   exact hb_neq_0 hb_eq_0
```

### 證明步驟說明

#### 步驟 1：引入前提

使用 `intro h` 引入前提 `a * b = 0`。

#### 步驟 2：使用反證法

使用 `by_contra h_not` 開始反證法，假設結論 `a = 0 ∨ b = 0` 不成立。

#### 步驟 3：展開否定

使用 `push_neg` 將 `¬(a = 0 ∨ b = 0)` 轉換為 `a ≠ 0 ∧ b ≠ 0`。

#### 步驟 4：分解假設

從 `a ≠ 0 ∧ b ≠ 0` 中提取兩個假設：
- `ha_neq_0 : a ≠ 0`
- `hb_neq_0 : b ≠ 0`

#### 步驟 5：推導矛盾

這是證明的關鍵步驟。從 `a * b = 0` 和 `a ≠ 0` 推導出 `b = 0`：

1. **使用乘法單位元**：將 `b` 寫成 `1 * b`
2. **使用乘法逆元**：因為 `a ≠ 0`，所以 `a` 有乘法逆元 `a⁻¹`，且 `a * a⁻¹ = 1`
3. **重組表達式**：使用交換律和結合律將 `(a * a⁻¹) * b` 重組為 `a⁻¹ * (a * b)`
4. **使用前提**：將 `a * b` 替換為 `0`
5. **使用零乘性質**：`a⁻¹ * 0 = 0`

因此得到 `b = 0`。

#### 步驟 6：得出矛盾

我們有 `hb_neq_0 : b ≠ 0` 和 `hb_eq_0 : b = 0`，這兩個命題矛盾。因此原假設不成立，所以 `a = 0 ∨ b = 0` 成立。

### 使用的公理和定理

1. **乘法單位元（公設 2.3）**：`one_mul : 1 * a = a`
2. **乘法逆元（公設 2.4）**：`mul_inv_cancel : a ≠ 0 → a * a⁻¹ = 1`
3. **乘法交換律（公設 2.1）**：`mul_comm : a * b = b * a`
4. **乘法結合律（公設 2.2）**：`mul_assoc : (a * b) * c = a * (b * c)`
5. **零乘任何數等於零（練習題 1）**：`mul_zero : a * 0 = 0`
6. **反證法策略**：`by_contra`、`push_neg`

### 學習重點

1. **反證法的使用**：這個證明展示了如何使用反證法來證明一個"或"命題。當直接證明困難時，反證法是一個有力的工具。

2. **乘法逆元的應用**：當我們有 `a * b = 0` 且 `a ≠ 0` 時，可以使用乘法逆元來"消去" `a`，從而得到 `b = 0`。

3. **field_simp 的使用**：`field_simp` 可以自動處理類型類實例的推斷，特別是在處理域（Field）相關的運算時非常有用。

4. **零乘積性質的重要性**：這個定理在解方程時非常重要，例如解 `(x - 1)(x - 2) = 0` 時，我們知道 `x - 1 = 0` 或 `x - 2 = 0`。

### 相關練習

- 嘗試證明：如果 `a * b = 0` 且 `a ≠ 0`，則 `b = 0`（不使用反證法）
- 思考為什麼需要 `a ≠ 0` 才能使用乘法逆元
- 證明：如果 `a * b * c = 0`，則 `a = 0` 或 `b = 0` 或 `c = 0`

---

## 練習題 6：證明 a ≠ 0 → a² > 0（平方的正性）

### 題目

**定理**：對於任意實數 \(a\)，如果 \(-1 < a < 1\) 且 \(a \neq 0\)，則 \(a^2 > 0\)

**說明**：這個定理說明在區間 \((-1, 1)\) 內的非零實數，其平方必為正數。實際上，對於任意非零實數，其平方都為正數，這個條件只是題目給出的額外限制。

### 證明思路

使用以下基本公理和定理：
- 全序性（公設 4.1）：將 \(a \neq 0\) 轉換為 \(a < 0\) 或 \(a > 0\)
- 分情況證明：分別處理 \(a < 0\) 和 \(a > 0\) 兩種情況
- 乘法保序性質：正數的乘積為正，負數的乘積也為正

### 完整證明

```lean
example (a : ℝ) : -1 < a → a < 1 → a ≠ 0 → a^2 > 0 := by
   -- 步驟 1：引入前提
   -- h1 : -1 < a（雖然在證明中不需要用到，但這是題目給出的條件）
   -- h2 : a < 1（雖然在證明中不需要用到，但這是題目給出的條件）
   -- h3 : a ≠ 0（這是證明的關鍵條件）
   intro h1 h2 h3
   
   -- 步驟 2：使用全序性（公設 4.1）將 a ≠ 0 轉換為 a < 0 或 a > 0
   -- `ne_iff_lt_or_gt` 定理：`a ≠ 0 ↔ a < 0 ∨ a > 0`
   -- 使用 `.mp` 得到：如果 a ≠ 0，則 a < 0 或 a > 0
   have h4 : a < 0 ∨ a > 0 := ne_iff_lt_or_gt.mp h3
   
   -- 步驟 3：建立 a² 與 a * a 的等價關係
   -- `pow_two` 定理：`a^2 = a * a`
   -- 這允許我們在 a² 和 a * a 之間轉換
   have h5 : a^2 = a * a := pow_two a
   
   -- 步驟 4：分情況證明
   -- 使用 `cases` 對 h4 進行分情況討論
   cases h4 with
   -- 情況 1：a < 0
   | inl h_neg => 
      -- 子步驟 4.1：證明 a * a > 0（當 a < 0 時）
      -- `mul_pos_of_neg_of_neg` 定理：如果 a < 0 且 b < 0，則 a * b > 0
      -- 這裡 a < 0 且 a < 0，所以 a * a > 0
      have h6 : a * a > 0 := mul_pos_of_neg_of_neg h_neg h_neg
      -- 子步驟 4.2：使用 calc 建立不等式鏈
      calc 
         a^2
         -- 將 a² 轉換為 a * a
         _ = a * a := by rw [h5]
         -- 使用 h6 得到 a * a > 0
         _ > 0 := by exact h6
   -- 情況 2：a > 0
   | inr h_pos => 
      -- 子步驟 4.3：證明 a * a > 0（當 a > 0 時）
      -- `mul_pos` 定理：如果 a > 0 且 b > 0，則 a * b > 0
      -- 這裡 a > 0 且 a > 0，所以 a * a > 0
      have h6 : a * a > 0 := mul_pos h_pos h_pos
      -- 子步驟 4.4：使用 calc 建立不等式鏈
      calc 
         a^2
         -- 將 a² 轉換為 a * a
         _ = a * a := by rw [h5]
         -- 使用 h6 得到 a * a > 0
         _ > 0 := by exact h6
```

### 證明步驟說明

#### 步驟 1：引入前提

使用 `intro` 引入三個前提：
- `h1 : -1 < a`
- `h2 : a < 1`
- `h3 : a ≠ 0`

**注意**：雖然 `h1` 和 `h2` 給出了 `a` 的範圍限制，但在證明 `a^2 > 0` 時實際上不需要用到這兩個條件，因為只要 `a \neq 0` 就有 `a^2 > 0`。

#### 步驟 2：使用全序性轉換

使用 `ne_iff_lt_or_gt.mp` 將 `a ≠ 0` 轉換為 `a < 0 ∨ a > 0`。這是全序性的應用：對於任意實數，要麼小於 0，要麼等於 0，要麼大於 0。由於 `a ≠ 0`，所以只能是 `a < 0` 或 `a > 0`。

#### 步驟 3：建立等價關係

使用 `pow_two` 建立 `a^2 = a * a` 的等價關係，這樣我們就可以在平方和乘積之間轉換。

#### 步驟 4：分情況證明

使用 `cases` 對 `a < 0 ∨ a > 0` 進行分情況討論：

**情況 1：a < 0**
- 使用 `mul_pos_of_neg_of_neg` 定理：如果兩個負數相乘，結果為正數
- 因此 `a * a > 0`，即 `a^2 > 0`

**情況 2：a > 0**
- 使用 `mul_pos` 定理：如果兩個正數相乘，結果為正數
- 因此 `a * a > 0`，即 `a^2 > 0`

### 使用的公理和定理

1. **全序性（公設 4.1）**：`ne_iff_lt_or_gt : a ≠ 0 ↔ a < 0 ∨ a > 0`
2. **平方的定義**：`pow_two : a^2 = a * a`
3. **正數乘積為正**：`mul_pos : a > 0 → b > 0 → a * b > 0`
4. **負數乘積為正**：`mul_pos_of_neg_of_neg : a < 0 → b < 0 → a * b > 0`

### 學習重點

1. **分情況證明**：當我們有 `P ∨ Q` 時，可以使用 `cases` 分別證明每種情況，這是處理"或"命題的標準方法。

2. **全序性的應用**：`ne_iff_lt_or_gt` 是將不等於關係轉換為嚴格不等式的有用工具。

3. **平方的正性**：這個定理說明非零實數的平方總是正數，這是實數系統的一個重要性質。

4. **calc 用於不等式**：`calc` 不僅可以用於等式，也可以用於不等式鏈式證明。

### 相關練習

- 嘗試證明：對於任意實數 \(a\)，有 \(a^2 \geq 0\)（不需要 \(a \neq 0\) 的條件）
- 思考為什麼 `-1 < a < 1` 這個條件在證明中不需要用到
- 證明：如果 \(a^2 = 0\)，則 \(a = 0\)

---

## 練習題 7：證明 0 < a < 1 → 0 < a² < a

### 題目

**定理**：對於任意實數 \(a\)，如果 \(0 < a < 1\)，則 \(0 < a^2 < a\)

**說明**：這個定理說明在區間 \((0, 1)\) 內的實數，其平方也在 \((0, a)\) 內，即平方比原數小。這是實數系統中一個重要的不等式性質。

### 證明思路

分別證明兩個部分：
1. **a² > 0**：使用正數乘積為正的性質
2. **a² < a**：使用乘法保序性質，因為 \(a < 1\) 且 \(a > 0\)

### 完整證明

```lean
example (a : ℝ) : 0 < a → a < 1 → 0 < a^2 ∧ a^2 < a := by
   -- 步驟 1：引入前提
   -- h1 : 0 < a（a 是正數）
   -- h2 : a < 1（a 小於 1）
   intro h1 h2
   
   -- 步驟 2：建立 a² 與 a * a 的等價關係
   -- `pow_two` 定理：`a^2 = a * a`
   -- 這允許我們在 a² 和 a * a 之間轉換
   have h3 : a^2 = a * a := pow_two a
   
   -- 步驟 3：證明 a * a > 0
   -- `mul_pos` 定理：如果 a > 0 且 b > 0，則 a * b > 0
   -- 這裡 a > 0 (h1) 且 a > 0 (h1)，所以 a * a > 0
   have h4 : a * a > 0 := mul_pos h1 h1
   
   -- 步驟 4：證明 a² > 0
   -- 使用 calc 從 a² = a * a 和 a * a > 0 得到 a² > 0
   have h5 : a^2 > 0 := by 
      calc 
         a^2
         -- 將 a² 轉換為 a * a
         _ = a * a := h3 
         -- 使用 h4：a * a > 0
         _ > 0 := h4 
   
   -- 步驟 5：證明 a² < a
   -- 這是證明的關鍵步驟，需要使用乘法保序性質
   have h6 : a^2 < a := by
      -- 先將 a² 轉換為 a * a
      rw [h3]
      calc 
         a * a
         -- 子步驟 5.1：使用乘法保序（公設 4.5）
         -- `mul_lt_mul_of_pos_right` 定理：如果 a < b 且 0 < c，則 c * a < c * b
         -- 這裡 a < 1 (h2) 且 0 < a (h1)，所以 a * a < a * 1
         -- 但我們需要 a * a < 1 * a，所以使用 mul_lt_mul_of_pos_right
         _ < 1 * a := mul_lt_mul_of_pos_right h2 h1
         -- 子步驟 5.2：使用乘法單位元（公設 2.3）
         -- `one_mul` 定理：`1 * a = a`
         _ = a := by rw [one_mul]
   
   -- 步驟 6：組合兩個結果
   -- 使用 `⟨h5, h6⟩` 將 `a^2 > 0` 和 `a^2 < a` 組合成 `0 < a^2 ∧ a^2 < a`
   exact ⟨h5, h6⟩
```

### 證明步驟說明

#### 步驟 1：引入前提

使用 `intro` 引入兩個前提：
- `h1 : 0 < a`：a 是正數
- `h2 : a < 1`：a 小於 1

#### 步驟 2：建立等價關係

使用 `pow_two` 建立 `a^2 = a * a` 的等價關係，這樣我們就可以在平方和乘積之間轉換。

#### 步驟 3：證明 a * a > 0

使用 `mul_pos` 定理：如果兩個正數相乘，結果為正數。因為 `a > 0`，所以 `a * a > 0`。

#### 步驟 4：證明 a² > 0

使用 `calc` 從 `a^2 = a * a` 和 `a * a > 0` 得到 `a^2 > 0`。

#### 步驟 5：證明 a² < a

這是證明的關鍵步驟：

1. **使用乘法保序**：`mul_lt_mul_of_pos_right` 定理說：如果 `a < b` 且 `0 < c`，則 `c * a < c * b`
   - 這裡 `a < 1` (h2) 且 `0 < a` (h1)
   - 所以 `a * a < a * 1`

2. **使用乘法單位元**：`one_mul` 將 `1 * a` 簡化為 `a`

因此得到 `a^2 < a`。

#### 步驟 6：組合結果

使用 `⟨h5, h6⟩` 將兩個結果組合成 `0 < a^2 ∧ a^2 < a`。

### 使用的公理和定理

1. **平方的定義**：`pow_two : a^2 = a * a`
2. **正數乘積為正**：`mul_pos : a > 0 → b > 0 → a * b > 0`
3. **乘法保序（右側）**：`mul_lt_mul_of_pos_right : a < b → 0 < c → c * a < c * b`
4. **乘法單位元（公設 2.3）**：`one_mul : 1 * a = a`

### 學習重點

1. **分步證明合取命題**：當需要證明 `P ∧ Q` 時，可以分別證明 `P` 和 `Q`，然後使用 `⟨hP, hQ⟩` 組合。

2. **乘法保序的應用**：`mul_lt_mul_of_pos_right` 和 `mul_lt_mul_of_pos_left` 是處理不等式乘法的有力工具。

3. **區間 (0, 1) 的性質**：這個定理說明在開區間 (0, 1) 內，平方函數是遞減的（相對於原數）。

4. **calc 用於不等式**：`calc` 不僅可以用於等式，也可以用於不等式鏈式證明。

### 相關練習

- 嘗試證明：如果 \(a > 1\)，則 \(a^2 > a\)
- 思考為什麼需要 \(0 < a\) 這個條件
- 證明：如果 \(0 < a < b < 1\)，則 \(a^2 < b^2\)

---

## 練習題 8：證明 |a · b| = |a| · |b|（絕對值的乘性）

### 題目

**定理**：對於任意實數 \(a, b\)，有 \(|a \cdot b| = |a| \cdot |b|\)

**說明**：這個定理說明絕對值對乘法是保持的，即乘積的絕對值等於絕對值的乘積。這是絕對值運算的一個重要性質。

### 證明思路

使用分情況證明：
1. 對 \(a\) 分情況：\(a \leq 0\) 或 \(a \geq 0\)
2. 對 \(b\) 分情況：\(b \leq 0\) 或 \(b \geq 0\)
3. 總共有四種情況組合，分別證明每種情況

### 完整證明

```lean
example (a b : ℝ) : |a * b| = |a| * |b| := by 
   have h_a : a ≤ 0 ∨ 0 ≤ a := le_total a 0  -- 對 a 分情況：a ≤ 0 或 a ≥ 0
   have h_b : b ≤ 0 ∨ 0 ≤ b := le_total b 0  -- 對 b 分情況：b ≤ 0 或 b ≥ 0
   cases h_a with  -- 對 a 的情況進行分情況討論
   | inl ha_neg =>  -- 情況 1：a ≤ 0
      cases h_b with  -- 對 b 的情況進行分情況討論
         | inl hb_neg =>  -- 情況 1.1：a ≤ 0 且 b ≤ 0
            have h_ab : a * b ≥ 0 := mul_nonneg_of_nonpos_of_nonpos ha_neg hb_neg
            have h1 : |a * b| = a * b := by rw [abs_of_nonneg h_ab]
            have h2 : |a| = -a := by rw [abs_of_nonpos ha_neg]
            have h3 : |b| = -b := by rw [abs_of_nonpos hb_neg]
            have h4 : |a| * |b| = -a * -b := by rw [h2, h3]
            have h5 : -a * -b = a * b := by rw [neg_mul_neg]
            have h6 : |a| * |b| = a * b := by 
               calc 
                  |a| * |b|
                  _ = -a * -b := h4 
                  _ = a * b := h5 
            have h7 :|a * b| = |a| * |b| := by 
               calc 
                  |a * b|
                  _ = a * b := h1 
                  _ = |a| * |b| := h6.symm
            exact h7
         | inr hb_pos =>  -- 情況 1.2：a ≤ 0 且 b ≥ 0
            have h_ab : a * b ≤ 0 := mul_nonpos_of_nonpos_of_nonneg ha_neg hb_pos
            have h1 : |a * b| = - (a * b) := by rw [abs_of_nonpos h_ab]
            have h2 : |a| = -a := by rw [abs_of_nonpos ha_neg]
            have h3 : |b| = b := by rw [abs_of_nonneg hb_pos]
            have h4 : |a| * |b| = (-a) * b := by rw [h2, h3]
            have h5 : -(a * b) = (-a) * b := by rw [neg_mul]
            have h6 : |a * b| = |a| * |b| := by 
               calc 
                  |a * b|
                  _ = - (a * b) := h1
                  _ = (-a) * b := h5 
                  _ = |a| * |b| := h4.symm
            exact h6
   | inr ha_pos =>  -- 情況 2：a ≥ 0
      cases h_b with
      | inl hb_neg =>  -- 情況 2.1：a ≥ 0 且 b ≤ 0
         have h_ab : b * a ≤ 0 := mul_nonpos_of_nonpos_of_nonneg hb_neg ha_pos
         have h1 : a * b = b * a := by rw [mul_comm]
         have h2 : a * b ≤ 0 := by 
            calc
               a * b
               _ = b * a := h1
               _ ≤ 0 := h_ab
         have h3 : |a * b| = - (a * b) := by rw [abs_of_nonpos h2]
         have h4 : |a| = a := by rw [abs_of_nonneg ha_pos]
         have h5 : |b| = -b := by rw [abs_of_nonpos hb_neg]
         have h6 : |a| * |b| = a * (-b) := by rw [h4, h5]
         have h7 : - (a * b) = a * (-b) := by rw [← mul_neg]
         have h8 : |a * b| = |a| * |b| := by 
            calc 
               |a * b|
               _ = - (a * b) := h3
               _ = a * (-b) := h7 
               _ = |a| * |b| := h6.symm
         exact h8
      | inr hb_pos =>  -- 情況 2.2：a ≥ 0 且 b ≥ 0
         have h_ab : a * b ≥ 0 := mul_nonneg ha_pos hb_pos
         have h1 : |a * b| = a * b := by rw [abs_of_nonneg h_ab]
         have h2 : |a| = a := by rw [abs_of_nonneg ha_pos]
         have h3 : |b| = b := by rw [abs_of_nonneg hb_pos]
         have h4 : |a| * |b| = a * b := by rw [h2, h3]
         have h6 : |a * b| = |a| * |b| := by 
            calc 
               |a * b|
               _ = a * b := h1 
               _ = |a| * |b| := h4.symm
         exact h6
```

### 證明步驟說明

#### 整體結構：分情況證明

這個證明使用嵌套的分情況討論，總共有四種情況：

1. **情況 1.1**：\(a \leq 0\) 且 \(b \leq 0\)
2. **情況 1.2**：\(a \leq 0\) 且 \(b \geq 0\)
3. **情況 2.1**：\(a \geq 0\) 且 \(b \leq 0\)
4. **情況 2.2**：\(a \geq 0\) 且 \(b \geq 0\)

#### 情況 1.1：a ≤ 0 且 b ≤ 0

**步驟說明：**
1. **確定 a * b 的符號**：使用 `mul_nonneg_of_nonpos_of_nonpos` 得到 `a * b ≥ 0`（兩個非正數相乘為非負數）
2. **計算 |a * b|**：因為 `a * b ≥ 0`，所以 `|a * b| = a * b`
3. **計算 |a| 和 |b|**：因為 `a ≤ 0` 和 `b ≤ 0`，所以 `|a| = -a` 和 `|b| = -b`
4. **計算 |a| * |b|**：`|a| * |b| = (-a) * (-b) = a * b`（使用 `neg_mul_neg`）
5. **組合結果**：`|a * b| = a * b = |a| * |b|`

#### 情況 1.2：a ≤ 0 且 b ≥ 0

**步驟說明：**
1. **確定 a * b 的符號**：使用 `mul_nonpos_of_nonpos_of_nonneg` 得到 `a * b ≤ 0`（非正數乘以非負數為非正數）
2. **計算 |a * b|**：因為 `a * b ≤ 0`，所以 `|a * b| = -(a * b)`
3. **計算 |a| 和 |b|**：`|a| = -a` 和 `|b| = b`
4. **計算 |a| * |b|**：`|a| * |b| = (-a) * b`
5. **使用負數的分配**：`-(a * b) = (-a) * b`（使用 `neg_mul`）
6. **組合結果**：`|a * b| = -(a * b) = (-a) * b = |a| * |b|`

#### 情況 2.1：a ≥ 0 且 b ≤ 0

**步驟說明：**
1. **確定 a * b 的符號**：先證明 `b * a ≤ 0`，然後使用交換律得到 `a * b ≤ 0`
2. **計算 |a * b|**：因為 `a * b ≤ 0`，所以 `|a * b| = -(a * b)`
3. **計算 |a| 和 |b|**：`|a| = a` 和 `|b| = -b`
4. **計算 |a| * |b|**：`|a| * |b| = a * (-b)`
5. **使用負數的分配**：`-(a * b) = a * (-b)`（使用 `mul_neg` 的逆方向）
6. **組合結果**：`|a * b| = -(a * b) = a * (-b) = |a| * |b|`

#### 情況 2.2：a ≥ 0 且 b ≥ 0

**步驟說明：**
1. **確定 a * b 的符號**：使用 `mul_nonneg` 得到 `a * b ≥ 0`（兩個非負數相乘為非負數）
2. **計算 |a * b|**：因為 `a * b ≥ 0`，所以 `|a * b| = a * b`
3. **計算 |a| 和 |b|**：`|a| = a` 和 `|b| = b`
4. **計算 |a| * |b|**：`|a| * |b| = a * b`
5. **組合結果**：`|a * b| = a * b = |a| * |b|`

### 使用的公理和定理

1. **全序性（公設 4.1）**：`le_total : a ≤ b ∨ b ≤ a`
2. **絕對值的性質**：
   - `abs_of_nonneg : a ≥ 0 → |a| = a`
   - `abs_of_nonpos : a ≤ 0 → |a| = -a`
3. **乘法的符號性質**：
   - `mul_nonneg : a ≥ 0 → b ≥ 0 → a * b ≥ 0`
   - `mul_nonneg_of_nonpos_of_nonpos : a ≤ 0 → b ≤ 0 → a * b ≥ 0`
   - `mul_nonpos_of_nonpos_of_nonneg : a ≤ 0 → b ≥ 0 → a * b ≤ 0`
   - `mul_nonpos_of_nonneg_of_nonpos : a ≥ 0 → b ≤ 0 → a * b ≤ 0`
4. **負數的乘法性質**：
   - `neg_mul_neg : (-a) * (-b) = a * b`
   - `neg_mul : (-a) * b = -(a * b)`
   - `mul_neg : a * (-b) = -(a * b)`
5. **乘法交換律（公設 2.1）**：`mul_comm : a * b = b * a`

### 學習重點

1. **分情況證明的嵌套結構**：當需要對多個變數分情況時，可以使用嵌套的 `cases` 語句。

2. **絕對值的計算規則**：
   - 如果 \(a \geq 0\)，則 \(|a| = a\)
   - 如果 \(a \leq 0\)，則 \(|a| = -a\)

3. **乘法的符號規則**：
   - 正數 × 正數 = 正數
   - 負數 × 負數 = 正數
   - 正數 × 負數 = 負數
   - 負數 × 正數 = 負數

4. **負數的分配性質**：`-(a * b) = (-a) * b = a * (-b)`

5. **calc 用於等式鏈**：使用 `calc` 可以清晰地展示每一步的轉換。

### 相關練習

- 嘗試證明：\(|a / b| = |a| / |b|\)（當 \(b \neq 0\) 時）
- 思考為什麼需要分四種情況
- 證明：\(|a^n| = |a|^n\)（對任意自然數 \(n\)）

---

## 練習題 9：證明 |a| ≤ M ↔ -M ≤ a ≤ M（絕對值不等式的等價形式）

### 題目

**定理 1.6**：對於任意實數 \(a\) 和 \(M \geq 0\)，有 \(|a| \leq M\) 若且唯若 \(-M \leq a \leq M\)

**說明**：這個定理說明絕對值不等式 \(|a| \leq M\) 等價於 \(a\) 在區間 \([-M, M]\) 內。這是絕對值運算的一個重要性質，在分析學中經常使用。

### 證明思路

使用雙向等價證明：
1. **方向 1**：證明 \(|a| \leq M \to -M \leq a \leq M\)
   - 分情況討論 \(a\) 的符號（\(a \leq 0\) 或 \(a \geq 0\)）
   - 每種情況分別證明 \(-M \leq a\) 和 \(a \leq M\)
2. **方向 2**：證明 \(-M \leq a \leq M \to |a| \leq M\)
   - 同樣分情況討論 \(a\) 的符號
   - 每種情況分別證明 \(|a| \leq M\)

### 完整證明

```lean
theorem Theorem_1_6 (a M : ℝ) (hM : M ≥ 0): |a| ≤ M ↔ -M ≤ a ∧ a ≤ M := by
   constructor  -- 分別處理雙向等價的兩個方向
   · intro h  -- 方向 1：假設 |a| ≤ M
      have h_a : a ≤ 0 ∨ 0 ≤ a := le_total a 0  -- 對 a 分情況
      cases h_a with
      | inl ha_neg =>  -- 情況 1.1：a ≤ 0
         have h1 : |a| = -a := by rw [abs_of_nonpos ha_neg]  -- 因為 a ≤ 0，所以 |a| = -a
         have h2 : -a ≤ M := by  -- 從 |a| ≤ M 得到 -a ≤ M
            calc
               -a
               _ = |a| := h1.symm
               _ ≤ M := h
         have h3 : (-1 : ℝ) ≤ 0 := by norm_num  -- 證明 -1 ≤ 0
         have h4 : M * (-1) ≤ (-a) * (-1) := mul_le_mul_of_nonpos_right h2 h3  -- 使用負數乘法保序
         have h5 : -M = M * (-1) := by rw [mul_neg_one]  -- M * (-1) = -M
         have h6 : (-a) * (-1) = a := by  -- 證明 (-a) * (-1) = a
            calc
               (-a) * (-1)
               _ = (-1) * (-a) := by rw [mul_comm]
               _ = -(-a) := by rw [neg_one_mul]
               _ = a := by rw [neg_neg]
         have h7 : -M ≤ a := by  -- 組合得到 -M ≤ a
            calc
               -M
               _ = M * (-1) := h5
               _ ≤ (-a) * (-1) := h4
               _ = a := h6
         have h8 : a ≤ M := by  -- 因為 a ≤ 0 且 M ≥ 0
            calc
               a
               _ ≤ 0 := ha_neg
               _ ≤ M := hM
         exact ⟨h7, h8⟩  -- 組合得到 -M ≤ a ∧ a ≤ M
      | inr ha_pos =>  -- 情況 1.2：a ≥ 0
         have h1 : |a| = a := by rw [abs_of_nonneg ha_pos]  -- 因為 a ≥ 0，所以 |a| = a
         have h2 : a ≤ M := by  -- 從 |a| ≤ M 得到 a ≤ M
            calc
               a
               _ = |a| := h1.symm
               _ ≤ M := h
         have h3 : -M ≤ a := by  -- 因為 a ≥ 0 且 M ≥ 0
            calc
               -M
               _ ≤ 0 := neg_nonpos.mpr hM  -- 因為 M ≥ 0，所以 -M ≤ 0
               _ ≤ a := ha_pos  -- 因為 a ≥ 0，所以 0 ≤ a
         have h4 : a ≤ M := by  -- 從 |a| ≤ M 得到 a ≤ M
            calc
               a
               _ = |a| := h1.symm
               _ ≤ M := h
         exact ⟨h3, h4⟩  -- 組合得到 -M ≤ a ∧ a ≤ M
   · intro h  -- 方向 2：假設 -M ≤ a ∧ a ≤ M
      rcases h with ⟨h1, h2⟩  -- 分解為 h1 : -M ≤ a 和 h2 : a ≤ M
      have h_a : a ≤ 0 ∨ 0 ≤ a := le_total a 0  -- 對 a 分情況
      cases h_a with
      | inl ha_neg =>  -- 情況 2.1：a ≤ 0
         have h3 : |a| = -a := by rw [abs_of_nonpos ha_neg]  -- 因為 a ≤ 0，所以 |a| = -a
         have h4 : |a| ≤ M := by  -- 證明 |a| ≤ M
            have h4a : -a ≤ M := by  -- 從 -M ≤ a 得到 -a ≤ M
               have h4a1 : (-1 : ℝ) ≤ 0 := by norm_num  -- 證明 -1 ≤ 0
               calc
                  -a
                  _ = a * (-1) := by rw [mul_neg_one]  -- -a = a * (-1)
                  _ ≤ -M * (-1) := mul_le_mul_of_nonpos_right h1 h4a1  -- 使用負數乘法保序
                  _ = -(-M) := by rw [mul_neg_one]  -- -M * (-1) = -(-M)
                  _ = M := by rw [neg_neg]  -- -(-M) = M
            calc
               |a|
               _ = -a := h3
               _ ≤ M := h4a
         exact h4
      | inr ha_pos =>  -- 情況 2.2：a ≥ 0
         have h1 : |a| = a := by rw [abs_of_nonneg ha_pos]  -- 因為 a ≥ 0，所以 |a| = a
         have h2 : |a| ≤ M := by  -- 從 a ≤ M 得到 |a| ≤ M
            calc
               |a|
               _ = a := h1
               _ ≤ M := h2
         exact h2
```

### 證明步驟說明

#### 整體結構：雙向等價證明

這個證明使用 `constructor` 將雙向等價分成兩個方向分別證明。

#### 方向 1：|a| ≤ M → -M ≤ a ≤ M

**情況 1.1：a ≤ 0**

**步驟說明：**
1. **計算 |a|**：因為 `a ≤ 0`，所以 `|a| = -a`
2. **證明 -a ≤ M**：從 `|a| ≤ M` 得到 `-a ≤ M`
3. **證明 -M ≤ a**：
   - 使用負數乘法保序：從 `-a ≤ M` 和 `-1 ≤ 0`，得到 `M * (-1) ≤ (-a) * (-1)`
   - 簡化：`M * (-1) = -M`，`(-a) * (-1) = a`
   - 因此 `-M ≤ a`
4. **證明 a ≤ M**：因為 `a ≤ 0` 且 `M ≥ 0`，所以 `a ≤ M`
5. **組合結果**：`-M ≤ a ∧ a ≤ M`

**情況 1.2：a ≥ 0**

**步驟說明：**
1. **計算 |a|**：因為 `a ≥ 0`，所以 `|a| = a`
2. **證明 a ≤ M**：從 `|a| ≤ M` 得到 `a ≤ M`
3. **證明 -M ≤ a**：因為 `a ≥ 0` 且 `M ≥ 0`，所以 `-M ≤ 0 ≤ a`，即 `-M ≤ a`
4. **組合結果**：`-M ≤ a ∧ a ≤ M`

#### 方向 2：-M ≤ a ≤ M → |a| ≤ M

**情況 2.1：a ≤ 0**

**步驟說明：**
1. **計算 |a|**：因為 `a ≤ 0`，所以 `|a| = -a`
2. **證明 -a ≤ M**：
   - 從 `-M ≤ a`，使用負數乘法保序：`a * (-1) ≤ -M * (-1)`
   - 簡化：`a * (-1) = -a`，`-M * (-1) = M`
   - 因此 `-a ≤ M`
3. **得到結果**：`|a| = -a ≤ M`

**情況 2.2：a ≥ 0**

**步驟說明：**
1. **計算 |a|**：因為 `a ≥ 0`，所以 `|a| = a`
2. **證明 a ≤ M**：從前提 `a ≤ M` 直接得到
3. **得到結果**：`|a| = a ≤ M`

### 使用的公理和定理

1. **全序性（公設 4.1）**：`le_total : a ≤ b ∨ b ≤ a`
2. **絕對值的性質**：
   - `abs_of_nonneg : a ≥ 0 → |a| = a`
   - `abs_of_nonpos : a ≤ 0 → |a| = -a`
3. **負數乘法保序**：
   - `mul_le_mul_of_nonpos_right : c ≤ 0 → a ≤ b → b * c ≤ a * c`
4. **負數的運算性質**：
   - `mul_neg_one : a * (-1) = -a`
   - `neg_one_mul : (-1) * a = -a`
   - `neg_neg : -(-a) = a`
   - `neg_nonpos : M ≥ 0 → -M ≤ 0`
5. **乘法交換律（公設 2.1）**：`mul_comm : a * b = b * a`

### 學習重點

1. **雙向等價的證明結構**：使用 `constructor` 將 `↔` 分成兩個 `→` 分別證明。

2. **分情況證明的應用**：根據 `a` 的符號（正、負、零）分別處理，每種情況使用不同的絕對值計算規則。

3. **負數乘法保序的使用**：
   - 當乘以負數時，不等式的方向會反轉
   - `mul_le_mul_of_nonpos_right`：如果 `c ≤ 0` 且 `a ≤ b`，則 `b * c ≤ a * c`

4. **負數運算的簡化**：
   - `a * (-1) = -a`
   - `(-a) * (-1) = a`
   - 這些性質在處理絕對值不等式時非常有用

5. **區間表示**：這個定理將絕對值不等式轉換為區間表示，在分析學中非常重要。

### 相關練習

- 證明：\(|a| < M \leftrightarrow -M < a < M\)（當 \(M > 0\) 時）
- 證明：\(|a| \geq M \leftrightarrow a \leq -M \vee a \geq M\)（當 \(M \geq 0\) 時）
- 思考：為什麼需要條件 \(M \geq 0\)？

---

## 練習題 10：證明 |a| ≥ 0 且 |a| = 0 ↔ a = 0（絕對值的非負性與零性）

### 題目

**定理 1.7(1)**：對於任意實數 \(a\)，有 \(|a| \geq 0\) 且 \(|a| = 0\) 若且唯若 \(a = 0\)

**說明**：這個定理說明絕對值非負，且絕對值為零當且僅當數本身為零。這是絕對值運算的基本性質。

### 證明思路

使用雙向等價證明：
1. **方向 1**：證明 \(|a| \geq 0 \wedge |a| = 0 \to a = 0\)
   - 使用反證法，假設 \(a \neq 0\)
   - 分情況討論 \(a < 0\) 或 \(a > 0\)
   - 每種情況都推導出 \(|a| \neq 0\)，與前提矛盾
2. **方向 2**：證明 \(a = 0 \to |a| \geq 0 \wedge |a| = 0\)
   - 直接使用 \(|0| = 0\) 和 \(|a| \geq 0\) 的性質

### 完整證明

```lean
theorem Theorem_1_7_1 (a : ℝ) : |a| ≥ 0 ∧ |a| = 0 ↔ a = 0 := by
   constructor  -- 分別處理雙向等價的兩個方向
   intro h  -- 方向 1：假設 |a| ≥ 0 ∧ |a| = 0
   have h1 : |a| ≥ 0 := h.1  -- 提取 |a| ≥ 0
   have h2 : |a| = 0 := h.2  -- 提取 |a| = 0
   by_contra h_not  -- 假設 a ≠ 0（反證法）
   have h3 : a < 0 ∨ 0 < a := ne_iff_lt_or_gt.mp h_not  -- 從 a ≠ 0 得到 a < 0 或 a > 0
   cases h3 with
   | inl ha_neg =>  -- 情況 1：a < 0
      have h4 : |a| = -a := by rw [abs_of_neg ha_neg]  -- 因為 a < 0，所以 |a| = -a
      have h5 : -a > 0 := by  -- 證明 -a > 0
         have h5a : (-1 : ℝ) < 0 := by norm_num  -- 證明 -1 < 0
         calc
            -a
            _ = a * (-1) := by rw [mul_neg_one]  -- -a = a * (-1)
            _ > 0 * (-1) := mul_lt_mul_of_neg_right ha_neg h5a  -- 使用負數乘法保序（嚴格）
            _ = 0 := by rw [zero_mul]  -- 0 * (-1) = 0
      have h6 : |a| ≠ 0 := by  -- 證明 |a| ≠ 0
         rw [h4]  -- 將 |a| 替換為 -a
         exact ne_of_gt h5  -- 從 -a > 0 得到 -a ≠ 0
      exact h6 h2  -- 與 h2 : |a| = 0 矛盾
   | inr ha_pos =>  -- 情況 2：0 < a
      have h4 : |a| = a := by rw [abs_of_pos ha_pos]  -- 因為 0 < a，所以 |a| = a
      have h5 : |a| ≠ 0 := by  -- 證明 |a| ≠ 0
         rw [h4]  -- 將 |a| 替換為 a
         exact ne_of_gt ha_pos  -- 從 a > 0 得到 a ≠ 0
      exact h5 h2  -- 與 h2 : |a| = 0 矛盾
   intro h  -- 方向 2：假設 a = 0
   have h1 : |a| = 0 := by  -- 證明 |a| = 0
      calc
         |a|
         _ = |0| := by rw [h]  -- 將 a 替換為 0
         _ = 0 := abs_zero  -- |0| = 0
   have h2 : |a| ≥ 0 := abs_nonneg a  -- |a| ≥ 0（絕對值非負）
   exact ⟨h2, h1⟩  -- 組合得到 |a| ≥ 0 ∧ |a| = 0
```

### 證明步驟說明

#### 整體結構：雙向等價證明

這個證明使用 `constructor` 將雙向等價分成兩個方向分別證明。

#### 方向 1：|a| ≥ 0 ∧ |a| = 0 → a = 0

**證明方法：反證法**

**步驟說明：**
1. **假設結論不成立**：假設 \(a \neq 0\)
2. **分類討論**：從 \(a \neq 0\) 得到 \(a < 0\) 或 \(a > 0\)

**情況 1：a < 0**

**步驟說明：**
1. **計算 |a|**：因為 `a < 0`，所以 `|a| = -a`
2. **證明 -a > 0**：
   - 使用負數乘法保序：從 `a < 0` 和 `-1 < 0`，得到 `a * (-1) > 0 * (-1)`
   - 簡化：`a * (-1) = -a`，`0 * (-1) = 0`
   - 因此 `-a > 0`
3. **推導矛盾**：從 `-a > 0` 得到 `-a ≠ 0`，即 `|a| ≠ 0`，與前提 `|a| = 0` 矛盾

**情況 2：0 < a**

**步驟說明：**
1. **計算 |a|**：因為 `0 < a`，所以 `|a| = a`
2. **推導矛盾**：從 `a > 0` 得到 `a ≠ 0`，即 `|a| ≠ 0`，與前提 `|a| = 0` 矛盾

#### 方向 2：a = 0 → |a| ≥ 0 ∧ |a| = 0

**步驟說明：**
1. **證明 |a| = 0**：
   - 從 `a = 0`，得到 `|a| = |0|`
   - 使用 `abs_zero`：`|0| = 0`
   - 因此 `|a| = 0`
2. **證明 |a| ≥ 0**：
   - 使用 `abs_nonneg`：`|a| ≥ 0`（絕對值非負）
3. **組合結果**：`|a| ≥ 0 ∧ |a| = 0`

### 使用的公理和定理

1. **反證法**：`by_contra` 用於假設結論不成立
2. **全序性**：`ne_iff_lt_or_gt : a ≠ 0 ↔ a < 0 ∨ a > 0`
3. **絕對值的性質**：
   - `abs_of_neg : a < 0 → |a| = -a`
   - `abs_of_pos : 0 < a → |a| = a`
   - `abs_zero : |0| = 0`
   - `abs_nonneg : |a| ≥ 0`
4. **負數乘法保序（嚴格）**：
   - `mul_lt_mul_of_neg_right : c < 0 → a < b → b * c < a * c`
5. **負數的運算性質**：
   - `mul_neg_one : a * (-1) = -a`
   - `zero_mul : 0 * a = 0`
6. **不等於的性質**：
   - `ne_of_gt : a > 0 → a ≠ 0`

### 學習重點

1. **反證法的應用**：當直接證明困難時，可以假設結論不成立，然後推導出矛盾。

2. **分情況證明的必要性**：根據 \(a\) 的符號（正、負、零）分別處理，每種情況使用不同的絕對值計算規則。

3. **負數乘法保序（嚴格不等式）**：
   - 當乘以負數時，嚴格不等式的方向會反轉
   - `mul_lt_mul_of_neg_right`：如果 `c < 0` 且 `a < b`，則 `b * c < a * c`

4. **絕對值的基本性質**：
   - 絕對值非負：`|a| ≥ 0`
   - 絕對值為零當且僅當數本身為零：`|a| = 0 ↔ a = 0`

5. **矛盾的使用**：在反證法中，推導出與已知前提矛盾的結論，從而證明原命題成立。

### 相關練習

- 證明：\(|a| > 0 \leftrightarrow a \neq 0\)
- 證明：\(|a| = |b| \leftrightarrow a = b \vee a = -b\)
- 思考：為什麼絕對值非負這個性質很重要？

---

## 練習題 11：證明 |a - b| = |b - a|（絕對值對減法的交換性）

### 題目

**定理 1.7(2)**：對於任意實數 \(a, b\)，有 \(|a - b| = |b - a|\)

**說明**：這個定理說明絕對值對減法具有交換性，即 \(|a - b| = |b - a|\)。這是一個簡單但重要的性質，在分析學中經常使用。

### 證明思路

使用絕對值的性質：
1. 首先證明 \(a - b = -(b - a)\)
2. 然後使用 \(|-(b - a)| = |b - a|\)（絕對值對負數的性質）

### 完整證明

```lean
theorem Theorem_1_7_2 (a b : ℝ) : |a - b| = |b - a| := by
   have h1 : a - b = -(b - a) := by rw [neg_sub]  -- a - b = -(b - a)
   calc
      |a - b|
      _ = |-(b - a)| := by rw [h1]  -- 將 a - b 替換為 -(b - a)
      _ = |b - a| := by rw [abs_neg]  -- |-(b - a)| = |b - a|
```

### 證明步驟說明

#### 整體結構：直接計算證明

這個證明使用 `calc` 來建立等式鏈，步驟非常簡潔。

#### 步驟說明

**步驟 1：證明 a - b = -(b - a)**

使用 `neg_sub` 定理：\(a - b = -(b - a)\)

這個定理可以直接從減法的定義和負數的性質得到。

**步驟 2：應用絕對值**

1. **替換**：將 \(|a - b|\) 中的 \(a - b\) 替換為 \(-(b - a)\)，得到 \(|-(b - a)|\)
2. **使用絕對值性質**：使用 `abs_neg` 定理：\(|-x| = |x|\)
3. **得到結果**：\(|-(b - a)| = |b - a|\)

### 使用的公理和定理

1. **減法與負數的關係**：
   - `neg_sub : a - b = -(b - a)`
2. **絕對值對負數的性質**：
   - `abs_neg : |-a| = |a|`

### 學習重點

1. **減法的性質**：\(a - b = -(b - a)\) 是一個基本的減法性質，在證明中經常使用。

2. **絕對值對負數的性質**：\(|-a| = |a|\) 說明絕對值函數是偶函數，即對稱於原點。

3. **簡潔的證明**：這個證明展示了如何使用基本性質來快速證明看似複雜的等式。

4. **calc 的使用**：使用 `calc` 可以清晰地展示每一步的轉換。

### 相關練習

- 證明：\(|a - b| = 0 \leftrightarrow a = b\)
- 證明：\(|a - b| = |a| - |b|\) 是否成立？如果不成立，在什麼條件下成立？
- 思考：為什麼 \(|a - b| = |b - a|\) 這個性質在分析學中很重要？

---

## 練習題 12：證明三角不等式和反向三角不等式

### 題目

**定理 1.7(3)**：對於任意實數 \(a, b\)，有 \(|a + b| \leq |a| + |b|\) 且 \(||a| - |b|| \leq |a - b|\)

**說明**：這個定理包含兩個部分：
1. **三角不等式**：\(|a + b| \leq |a| + |b|\) - 這是分析學中最重要的不等式之一
2. **反向三角不等式**：\(||a| - |b|| \leq |a - b|\) - 這是三角不等式的推論

### 證明思路

#### 第一部分：三角不等式 \(|a + b| \leq |a| + |b|\)

使用分情況證明：
1. 對 \(a + b\) 的符號分情況：\(a + b \leq 0\) 或 \(a + b \geq 0\)
2. 每種情況都需要證明 \(a \leq |a|\) 和 \(b \leq |b|\)（或對應的負數形式）
3. 然後使用加法保序性質

#### 第二部分：反向三角不等式 \(||a| - |b|| \leq |a - b|\)

使用第一部分（三角不等式）來證明：
1. 從 \(|a| = |(a - b) + b| \leq |a - b| + |b|\) 得到 \(|a| - |b| \leq |a - b|\)
2. 從 \(|b| = |(b - a) + a| \leq |b - a| + |a| = |a - b| + |a|\) 得到 \(-|a - b| \leq |a| - |b|\)
3. 組合這兩個結果得到 \(||a| - |b|| \leq |a - b|\)

### 完整證明

由於證明非常長（約290行），這裡只展示關鍵部分。完整證明請參考 `Analysis/Basic.lean` 文件。

#### 第一部分：三角不等式

```lean
-- 對 a + b 分情況
have h_ab : a + b ≤ 0 ∨ 0 ≤ a + b := le_total (a + b) 0
cases h_ab with
| inl hab_neg =>  -- 情況 1：a + b ≤ 0
   calc
      |a + b|
      _ = -(a + b) := by rw [abs_of_nonpos hab_neg]
      _ = -a - b := by ring
      _ ≤ |a| + |b| := by
         -- 需要證明 -a ≤ |a| 和 -b ≤ |b|
         -- 然後使用加法保序
| inr hab_pos =>  -- 情況 2：a + b ≥ 0
   calc
      |a + b|
      _ = a + b := by rw [abs_of_nonneg hab_pos]
      _ ≤ |a| + |b| := by
         -- 需要證明 a ≤ |a| 和 b ≤ |b|
         -- 然後使用加法保序
```

#### 第二部分：反向三角不等式

```lean
-- 證明 ||a| - |b|| ≤ |a - b|
have h1 : |a| - |b| ≤ |a - b| := by
   -- 從 |a| = |(a - b) + b| ≤ |a - b| + |b| 得到
   have h1a : |a| = |(a - b) + b| := by ring
   have h1b : |(a - b) + b| ≤ |a - b| + |b| := by
      -- 重複使用第一部分（三角不等式）的證明過程
   calc
      |a| - |b|
      _ = |(a - b) + b| - |b| := by rw [h1a]
      _ ≤ (|a - b| + |b|) - |b| := sub_le_sub_right h1b |b|
      _ = |a - b| := by ring

have h2 : -|a - b| ≤ |a| - |b| := by
   -- 類似地從 |b| = |(b - a) + a| ≤ |a - b| + |a| 得到
   -- （證明過程類似）

exact abs_le.mpr ⟨h2, h1⟩  -- 組合得到 ||a| - |b|| ≤ |a - b|
```

### 證明步驟說明

#### 第一部分：三角不等式 \(|a + b| \leq |a| + |b|\)

**情況 1：a + b ≤ 0**

**步驟說明：**
1. **計算 |a + b|**：因為 `a + b ≤ 0`，所以 `|a + b| = -(a + b) = -a - b`
2. **證明 -a ≤ |a|**：
   - 如果 `a ≤ 0`，則 `|a| = -a`，所以 `-a = |a| ≤ |a|`
   - 如果 `a ≥ 0`，則 `|a| = a`，所以 `-a ≤ 0 ≤ a = |a|`
3. **證明 -b ≤ |b|**：類似地分情況證明
4. **組合結果**：使用加法保序 `add_le_add`，得到 `-a - b ≤ |a| + |b|`

**情況 2：a + b ≥ 0**

**步驟說明：**
1. **計算 |a + b|**：因為 `a + b ≥ 0`，所以 `|a + b| = a + b`
2. **證明 a ≤ |a|**：
   - 如果 `a ≤ 0`，則 `|a| = -a`，所以 `a ≤ 0 ≤ -a = |a|`
   - 如果 `a ≥ 0`，則 `|a| = a`，所以 `a = |a| ≤ |a|`
3. **證明 b ≤ |b|**：類似地分情況證明
4. **組合結果**：使用加法保序，得到 `a + b ≤ |a| + |b|`

#### 第二部分：反向三角不等式 \(||a| - |b|| \leq |a - b|\)

**步驟說明：**
1. **證明 |a| - |b| ≤ |a - b|**：
   - 使用 `|a| = |(a - b) + b|`
   - 對 `|(a - b) + b|` 應用三角不等式，得到 `|(a - b) + b| ≤ |a - b| + |b|`
   - 因此 `|a| - |b| ≤ |a - b|`

2. **證明 -|a - b| ≤ |a| - |b|**：
   - 使用 `|b| = |(b - a) + a|`
   - 對 `|(b - a) + a|` 應用三角不等式，得到 `|(b - a) + a| ≤ |b - a| + |a| = |a - b| + |a|`
   - 因此 `|b| - |a| ≤ |a - b|`
   - 使用負數保序（方向反轉），得到 `-|a - b| ≤ -(|b| - |a|) = |a| - |b|`

3. **組合結果**：
   - 從 `-|a - b| ≤ |a| - |b| ≤ |a - b|`，使用 `abs_le.mpr` 得到 `||a| - |b|| ≤ |a - b|`

### 使用的公理和定理

1. **全序性（公設 4.1）**：`le_total : a ≤ b ∨ b ≤ a`
2. **絕對值的性質**：
   - `abs_of_nonneg : a ≥ 0 → |a| = a`
   - `abs_of_nonpos : a ≤ 0 → |a| = -a`
3. **加法保序（公設 4.4）**：`add_le_add : a ≤ b → c ≤ d → a + c ≤ b + d`
4. **減法保序**：`sub_le_sub_right : a ≤ b → a - c ≤ b - c`
5. **負數保序**：`neg_le_neg : a ≤ b → -b ≤ -a`
6. **絕對值不等式**：`abs_le : ||a| - |b|| ≤ |a - b| ↔ -|a - b| ≤ |a| - |b| ≤ |a - b|`
7. **絕對值交換性**：`abs_sub_comm : |a - b| = |b - a|`

### 學習重點

1. **三角不等式的重要性**：這是分析學中最基本的不等式之一，在後續的極限、連續性、微積分等內容中都會頻繁使用。

2. **分情況證明的嵌套結構**：這個證明展示了如何使用嵌套的分情況討論來處理複雜的不等式。

3. **遞歸使用已證明的結果**：第二部分（反向三角不等式）的證明重複使用了第一部分（三角不等式）的證明過程，展示了如何利用已證明的結果。

4. **基本性質的應用**：
   - `a ≤ |a|` 和 `-a ≤ |a|` 是絕對值的基本性質
   - 這些性質在證明中起到關鍵作用

5. **減法保序的使用**：從 `|a| ≤ |a - b| + |b|` 得到 `|a| - |b| ≤ |a - b|`，需要使用減法保序性質。

6. **負數保序的方向反轉**：當對不等式兩邊取負號時，不等式的方向會反轉。

### 相關練習

- 證明：\(|a_1 + a_2 + \cdots + a_n| \leq |a_1| + |a_2| + \cdots + |a_n|\)（廣義三角不等式）
- 證明：\(|a - b| \geq ||a| - |b||\)
- 思考：三角不等式在幾何上有什麼直觀意義？
- 應用：使用三角不等式證明 \(|a| < 1\) 和 \(|b| < 1\) 時，\(|a + b| < 2\)

---

## 練習題 13：證明 (∀ ε > 0, x < y + ε) ↔ x ≤ y（ε-δ 定義的基礎）

### 題目

**定理 1.9(1)**：對於任意實數 \(x, y\)，有 \((\forall \varepsilon > 0, x < y + \varepsilon) \leftrightarrow x \leq y\)

**說明**：這個定理說明 \(x\) 小於等於 \(y\) 若且唯若對於所有正數 \(\varepsilon\)，\(x\) 都小於 \(y + \varepsilon\)。這是分析學中重要的等價關係，是 \(\varepsilon\)-\(\delta\) 定義的基礎，在處理極限和連續性時會頻繁使用。

### 證明思路

使用雙向等價證明：
1. **方向 1**：證明 \((\forall \varepsilon > 0, x < y + \varepsilon) \to x \leq y\)
   - 使用反證法，假設 \(x > y\)
   - 構造特定的 \(\varepsilon_0 = x - y > 0\)
   - 應用假設得到 \(x < y + (x - y) = x\)，矛盾
2. **方向 2**：證明 \(x \leq y \to (\forall \varepsilon > 0, x < y + \varepsilon)\)
   - 直接證明，分情況討論 \(x < y\) 或 \(x = y\)
   - 每種情況都得到 \(x < y + \varepsilon\)

### 完整證明

```lean
theorem Theorem_1_9_1 (x y : ℝ) : (∀ ε > 0, x < y + ε) ↔ x ≤ y := by
   constructor  -- 分別處理雙向等價的兩個方向
   · intro h  -- 方向 1：假設 ∀ ε > 0, x < y + ε
      by_contra h_not  -- 假設 ¬(x ≤ y)，即 x > y（反證法）
      have h1 : x > y := lt_of_not_le h_not  -- 從 ¬(x ≤ y) 得到 x > y
      have h2 : x - y > 0 := by  -- 從 x > y 得到 x - y > 0
         calc
            x - y
            _ > y - y := sub_lt_sub_right h1 y  -- 從 x > y 得到 x - y > y - y
            _ = 0 := sub_self y  -- y - y = 0
      have h3 : x < y + (x - y) := h (x - y) h2  -- 對 ε = x - y 應用假設 h
      have h4 : y + (x - y) = x := by ring  -- y + (x - y) = x
      rw [h4] at h3  -- 將 y + (x - y) 替換為 x
      exact lt_irrefl x h3  -- 矛盾：x < x
   · intro h  -- 方向 2：假設 x ≤ y
      intro ε hε  -- 引入任意 ε > 0
      have h_cases : x < y ∨ x = y := lt_or_eq_of_le h  -- 從 x ≤ y 得到 x < y 或 x = y
      cases h_cases with
      | inl h_lt =>  -- 情況 1：x < y
         calc
            x
            _ < y := h_lt  -- x < y
            _ < y + ε := lt_add_of_pos_right y hε  -- 因為 ε > 0，所以 y < y + ε
      | inr h_eq =>  -- 情況 2：x = y
         calc
            x
            _ = y := h_eq  -- x = y
            _ < y + ε := lt_add_of_pos_right y hε  -- 因為 ε > 0，所以 y < y + ε
```

### 證明步驟說明

#### 整體結構：雙向等價證明

這個證明使用 `constructor` 將雙向等價分成兩個方向分別證明。

#### 方向 1：(∀ ε > 0, x < y + ε) → x ≤ y

**證明方法：反證法**

**步驟說明：**
1. **假設結論不成立**：假設 \(x > y\)（即 \(\neg(x \leq y)\)）
2. **構造特定的 ε**：
   - 從 \(x > y\) 得到 \(x - y > 0\)
   - 選擇 \(\varepsilon_0 = x - y > 0\)
3. **應用假設**：
   - 對 \(\varepsilon_0 = x - y\) 應用假設 \(h : \forall \varepsilon > 0, x < y + \varepsilon\)
   - 得到 \(x < y + (x - y)\)
4. **推導矛盾**：
   - 簡化：\(y + (x - y) = x\)
   - 因此 \(x < x\)，這違反了嚴格不等式的反身性（一個數不能嚴格小於自己）
5. **得出結論**：假設 \(x > y\) 導致矛盾，因此 \(x \leq y\) 必須成立

#### 方向 2：x ≤ y → (∀ ε > 0, x < y + ε)

**證明方法：直接證明，分情況討論**

**步驟說明：**
1. **引入前提**：假設 \(x \leq y\) 和任意 \(\varepsilon > 0\)
2. **分類討論**：從 \(x \leq y\) 得到 \(x < y\) 或 \(x = y\)

**情況 1：x < y**

**步驟說明：**
1. 從 \(x < y\) 和 \(\varepsilon > 0\)，使用加法保序性質
2. 因為 \(\varepsilon > 0\)，所以 \(y < y + \varepsilon\)
3. 由傳遞性得到 \(x < y < y + \varepsilon\)，即 \(x < y + \varepsilon\)

**情況 2：x = y**

**步驟說明：**
1. 從 \(x = y\) 和 \(\varepsilon > 0\)
2. 因為 \(\varepsilon > 0\)，所以 \(y < y + \varepsilon\)
3. 因此 \(x = y < y + \varepsilon\)，即 \(x < y + \varepsilon\)

### 使用的公理和定理

1. **反證法**：`by_contra` 用於假設結論不成立
2. **否定與不等式的關係**：
   - `lt_of_not_le : ¬(x ≤ y) → x > y`
3. **減法保序（嚴格）**：
   - `sub_lt_sub_right : x < y → x - z < y - z`
4. **減法性質**：
   - `sub_self : a - a = 0`
5. **加法保序（嚴格）**：
   - `lt_add_of_pos_right : 0 < c → a < b → a < b + c`
6. **全序性**：
   - `lt_or_eq_of_le : x ≤ y → x < y ∨ x = y`
7. **嚴格不等式的反身性**：
   - `lt_irrefl : ¬(a < a)`（一個數不能嚴格小於自己）

### 學習重點

1. **反證法的應用**：當直接證明困難時，可以假設結論不成立，然後構造特定的反例來推導矛盾。

2. **構造特定值**：在反證法中，選擇特定的 \(\varepsilon_0 = x - y\) 是關鍵步驟。這個值利用了假設 \(x > y\)，使得應用假設後能直接得到矛盾。

3. **分情況證明的應用**：從 \(x \leq y\) 得到 \(x < y\) 或 \(x = y\)，每種情況都需要單獨處理。

4. **ε-δ 定義的基礎**：這個定理是分析學中 \(\varepsilon\)-\(\delta\) 定義的基礎，在後續的極限、連續性、導數等內容中會頻繁使用。

5. **全稱量詞的處理**：在證明涉及全稱量詞的命題時，需要對任意值證明；在應用全稱量詞的假設時，可以選擇特定的值。

### 相關練習

- 證明：\((\forall \varepsilon > 0, x \leq y + \varepsilon) \leftrightarrow x \leq y\)
- 證明：\((\forall \varepsilon > 0, |x - a| < \varepsilon) \leftrightarrow x = a\)
- 思考：為什麼這個定理在分析學中如此重要？
- 應用：使用這個定理證明極限的唯一性

---

## 練習題 14：證明 (∀ ε > 0, x > y - ε) ↔ x ≥ y

### 題目

**定理 1.9(2)**：對於任意實數 \(x, y\)，有 \((\forall \varepsilon > 0, x > y - \varepsilon) \leftrightarrow x \geq y\)

**說明**：這個定理說明 \(x\) 大於等於 \(y\) 若且唯若對於所有正數 \(\varepsilon\)，\(x\) 都大於 \(y - \varepsilon\)。這是定理 1.9(1) 的對偶形式，同樣是分析學中重要的等價關係。

### 證明思路

使用雙向等價證明，與定理 1.9(1) 類似：
1. **方向 1**：證明 \((\forall \varepsilon > 0, x > y - \varepsilon) \to x \geq y\)
   - 使用反證法，假設 \(x < y\)
   - 構造特定的 \(\varepsilon_0 = y - x > 0\)
   - 應用假設得到 \(x > y - (y - x) = x\)，矛盾
2. **方向 2**：證明 \(x \geq y \to (\forall \varepsilon > 0, x > y - \varepsilon)\)
   - 直接證明，分情況討論 \(x > y\) 或 \(x = y\)
   - 每種情況都得到 \(x > y - \varepsilon\)

### 完整證明

```lean
theorem Theorem_1_9_2 (x y : ℝ) : (∀ ε > 0, x > y - ε) ↔ x ≥ y := by
   constructor  -- 分別處理雙向等價的兩個方向
   intro h  -- 方向 1：假設 ∀ ε > 0, x > y - ε
   by_contra h_not  -- 假設 ¬(x ≥ y)，即 x < y（反證法）
   push_neg at h_not  -- 將 ¬(x ≥ y) 轉換為 x < y
   have h1 : y - x > 0 := by  -- 從 x < y 得到 y - x > 0
      calc
         y - x
         _ > x - x := sub_lt_sub_right h_not x  -- 從 x < y 得到 y - x > x - x
         _ = 0 := sub_self x  -- x - x = 0
   have h2 : x > y - (y - x) := h (y - x) h1  -- 對 ε = y - x 應用假設 h
   have h3 : y - (y - x) = x := by ring  -- y - (y - x) = x
      rw [h3] at h2  -- 將 y - (y - x) 替換為 x
      exact lt_irrefl x h2  -- 矛盾：x > x
   intro h  -- 方向 2：假設 x ≥ y
      intro ε hε  -- 引入任意 ε > 0
      have h_cases : y < x ∨ y = x := lt_or_eq_of_le h  -- 從 x ≥ y（即 y ≤ x）得到 y < x 或 y = x
      cases h_cases with
      | inl h_lt =>  -- 情況 1：y < x，即 x > y
         calc
            x
            _ > y := h_lt  -- 從 y < x 得到 x > y
            _ > y - ε := by  -- 需要證明 y > y - ε
               calc
                  y
                  _ = y - 0 := by ring  -- y = y - 0
                  _ > y - ε := sub_lt_sub_left hε y  -- 從 0 < ε 得到 y - 0 > y - ε
      | inr h_eq =>  -- 情況 2：y = x，即 x = y
         calc
            x
            _ = y := h_eq.symm  -- x = y
            _ > y - ε := by  -- 需要證明 y > y - ε
               calc
                  y
                  _ = y - 0 := by ring  -- y = y - 0
                  _ > y - ε := sub_lt_sub_left hε y  -- 從 0 < ε 得到 y - 0 > y - ε
```

### 證明步驟說明

#### 整體結構：雙向等價證明

這個證明使用 `constructor` 將雙向等價分成兩個方向分別證明，與定理 1.9(1) 的結構類似。

#### 方向 1：(∀ ε > 0, x > y - ε) → x ≥ y

**證明方法：反證法**

**步驟說明：**
1. **假設結論不成立**：假設 \(x < y\)（即 \(\neg(x \geq y)\)）
2. **構造特定的 ε**：
   - 從 \(x < y\) 得到 \(y - x > 0\)
   - 選擇 \(\varepsilon_0 = y - x > 0\)
3. **應用假設**：
   - 對 \(\varepsilon_0 = y - x\) 應用假設 \(h : \forall \varepsilon > 0, x > y - \varepsilon\)
   - 得到 \(x > y - (y - x)\)
4. **推導矛盾**：
   - 簡化：\(y - (y - x) = x\)
   - 因此 \(x > x\)，這違反了嚴格不等式的反身性
5. **得出結論**：假設 \(x < y\) 導致矛盾，因此 \(x \geq y\) 必須成立

#### 方向 2：x ≥ y → (∀ ε > 0, x > y - ε)

**證明方法：直接證明，分情況討論**

**步驟說明：**
1. **引入前提**：假設 \(x \geq y\) 和任意 \(\varepsilon > 0\)
2. **分類討論**：從 \(x \geq y\)（即 \(y \leq x\)）得到 \(y < x\) 或 \(y = x\)

**情況 1：y < x（即 x > y）**

**步驟說明：**
1. 從 \(y < x\) 得到 \(x > y\)
2. 需要證明 \(y > y - \varepsilon\)：
   - 使用 \(y = y - 0\)
   - 從 \(0 < \varepsilon\)，使用 `sub_lt_sub_left` 得到 \(y - 0 > y - \varepsilon\)
   - 因此 \(y > y - \varepsilon\)
3. 由傳遞性得到 \(x > y > y - \varepsilon\)，即 \(x > y - \varepsilon\)

**情況 2：y = x（即 x = y）**

**步驟說明：**
1. 從 \(y = x\) 得到 \(x = y\)
2. 需要證明 \(y > y - \varepsilon\)：
   - 使用 \(y = y - 0\)
   - 從 \(0 < \varepsilon\)，使用 `sub_lt_sub_left` 得到 \(y - 0 > y - \varepsilon\)
   - 因此 \(y > y - \varepsilon\)
3. 因此 \(x = y > y - \varepsilon\)，即 \(x > y - \varepsilon\)

### 使用的公理和定理

1. **反證法**：`by_contra` 用於假設結論不成立
2. **否定與不等式的關係**：
   - `push_neg` 將 `¬(x ≥ y)` 轉換為 `x < y`
3. **減法保序（嚴格）**：
   - `sub_lt_sub_right : x < y → x - z < y - z`
   - `sub_lt_sub_left : a < b → a - c < b - c`
4. **減法性質**：
   - `sub_self : a - a = 0`
5. **全序性**：
   - `lt_or_eq_of_le : x ≤ y → x < y ∨ x = y`
6. **嚴格不等式的反身性**：
   - `lt_irrefl : ¬(a < a)`（一個數不能嚴格小於自己）

### 學習重點

1. **對偶定理**：這個定理是定理 1.9(1) 的對偶形式，證明的結構和方法都非常相似。

2. **減法保序的應用**：
   - `sub_lt_sub_left : a < b → a - c < b - c`
   - 從 `0 < ε` 得到 `0 - y < ε - y`，即 `-y < ε - y`
   - 這等價於 `y - ε < y - 0`，即 `y - ε < y`，即 `y > y - ε`

3. **構造特定值**：在反證法中，選擇特定的 \(\varepsilon_0 = y - x\) 是關鍵步驟。

4. **分情況證明的應用**：從 \(x \geq y\)（即 \(y \leq x\)）得到 \(y < x\) 或 \(y = x\)，每種情況都需要單獨處理。

### 相關練習

- 比較這個定理與定理 1.9(1) 的異同
- 證明：\((\forall \varepsilon > 0, x \geq y - \varepsilon) \leftrightarrow x \geq y\)
- 思考：為什麼這兩個定理在分析學中如此重要？

---

## 練習題 15：證明 (∀ ε > 0, |a| < ε) ↔ a = 0

### 問題陳述

**定理 1.9(3)**：對於任意實數 \(a\)，有
\[
(\forall \varepsilon > 0, |a| < \varepsilon) \leftrightarrow a = 0
\]

這個定理說明：一個數的絕對值小於任意正數，當且僅當這個數本身為零。

### 證明策略

這個定理的證明分為兩個方向：

1. **方向 1（→）**：假設 \(\forall \varepsilon > 0, |a| < \varepsilon\)，證明 \(a = 0\)
   - 將 \(|a| < \varepsilon\) 改寫為 \(|a| < 0 + \varepsilon\)
   - 使用定理 1.9(1) 得到 \(|a| \leq 0\)
   - 結合 \(|a| \geq 0\)（絕對值非負），得到 \(|a| = 0\)
   - 使用定理 1.7(1) 得到 \(a = 0\)

2. **方向 2（←）**：假設 \(a = 0\)，證明 \(\forall \varepsilon > 0, |a| < \varepsilon\)
   - 使用定理 1.7(1) 得到 \(|a| = 0\)
   - 對於任意 \(\varepsilon > 0\)，有 \(|a| = 0 < \varepsilon\)

### Lean 程式碼

```lean
theorem Theorem_1_9_3 (a : ℝ) : (∀ ε > 0, |a| < ε) ↔ a = 0 := by
   constructor  -- 分別處理雙向等價的兩個方向
   intro h  -- 方向 1：假設 ∀ ε > 0, |a| < ε
   have h1 : ∀ ε > 0, |a| < 0 + ε := by  -- 將 |a| < ε 改寫為 |a| < 0 + ε
      intro ε hε  -- 引入 ε 和 ε > 0
      calc
         |a|
         _ < ε := h ε hε  -- 應用 h
         _ = 0 + ε := by ring  -- ε = 0 + ε
   have h2 : |a| ≤ 0 := (Theorem_1_9_1 |a| 0).1 h1  -- 使用 Theorem 1.9(1) 得到 |a| ≤ 0
   have h3 : |a| ≥ 0 := abs_nonneg a  -- |a| ≥ 0（絕對值非負）
   have h4 : |a| = 0 := le_antisymm h2 h3  -- 從 |a| ≤ 0 和 |a| ≥ 0 得到 |a| = 0
   have h5 : a = 0 := (Theorem_1_7_1 a).1 ⟨h3, h4⟩  -- 使用 Theorem 1.7(1) 得到 a = 0
   exact h5  -- 完成方向 1 的證明
   intro h  -- 方向 2：假設 a = 0
   have h1 : |a| ≥ 0 ∧ |a| = 0 := (Theorem_1_7_1 a).mpr h  -- 使用 Theorem 1.7(1) 得到 |a| ≥ 0 ∧ |a| = 0
   have h2 : |a| = 0 := h1.2  -- 提取 |a| = 0
   have h3 : ∀ ε > 0, |a| < ε := by  -- 證明 ∀ ε > 0, |a| < ε
      intro ε hε  -- 引入 ε 和 ε > 0
      calc
         |a|
         _ = 0 := h2  -- |a| = 0
         _ < ε := hε  -- 0 < ε
   exact h3  -- 完成方向 2 的證明
```

### 詳細證明步驟

#### 方向 1：\((\forall \varepsilon > 0, |a| < \varepsilon) \to a = 0\)

1. **改寫條件**：
   - 假設 \(\forall \varepsilon > 0, |a| < \varepsilon\)
   - 將 \(|a| < \varepsilon\) 改寫為 \(|a| < 0 + \varepsilon\)
   - 這一步是為了應用定理 1.9(1)

2. **應用定理 1.9(1)**：
   - 定理 1.9(1) 說：\((\forall \varepsilon > 0, x < y + \varepsilon) \leftrightarrow x \leq y\)
   - 這裡 \(x = |a|\)，\(y = 0\)
   - 所以從 \(\forall \varepsilon > 0, |a| < 0 + \varepsilon\) 得到 \(|a| \leq 0\)

3. **結合絕對值非負性**：
   - 絕對值總是非負的：\(|a| \geq 0\)
   - 現在有 \(|a| \leq 0\) 和 \(|a| \geq 0\)
   - 根據三歧性（Trichotomy Property），得到 \(|a| = 0\)

4. **應用定理 1.7(1)**：
   - 定理 1.7(1) 說：\(|a| \geq 0 \land |a| = 0 \leftrightarrow a = 0\)
   - 從 \(|a| \geq 0 \land |a| = 0\) 得到 \(a = 0\)

#### 方向 2：\(a = 0 \to (\forall \varepsilon > 0, |a| < \varepsilon)\)

1. **應用定理 1.7(1)**：
   - 假設 \(a = 0\)
   - 使用定理 1.7(1) 的右到左方向，得到 \(|a| \geq 0 \land |a| = 0\)
   - 提取 \(|a| = 0\)

2. **證明全稱命題**：
   - 對於任意 \(\varepsilon > 0\)，需要證明 \(|a| < \varepsilon\)
   - 因為 \(|a| = 0\)，且 \(0 < \varepsilon\)（由 \(\varepsilon > 0\) 得到）
   - 所以 \(|a| = 0 < \varepsilon\)

### 使用的公設和定理

1. **定理 1.9(1)**：
   - `Theorem_1_9_1 x y : (∀ ε > 0, x < y + ε) ↔ x ≤ y`
   - 用於將「小於任意正數」轉換為「小於等於」

2. **絕對值非負性**：
   - `abs_nonneg a : |a| ≥ 0`
   - 絕對值總是非負的

3. **三歧性（等號的對稱性）**：
   - `le_antisymm : x ≤ y → y ≤ x → x = y`
   - 如果 \(x \leq y\) 且 \(y \leq x\)，則 \(x = y\)

4. **定理 1.7(1)**：
   - `Theorem_1_7_1 a : |a| ≥ 0 ∧ |a| = 0 ↔ a = 0`
   - 絕對值為零當且僅當數本身為零

5. **基本算術**：
   - `ring`：簡化環運算
   - 嚴格不等式的傳遞性

### 學習重點

1. **定理的應用**：這個證明展示了如何將一個定理（定理 1.9(1)）應用到另一個問題中。

2. **改寫技巧**：將 \(|a| < \varepsilon\) 改寫為 \(|a| < 0 + \varepsilon\) 是關鍵步驟，使得可以應用定理 1.9(1)。

3. **三歧性的應用**：
   - 從 \(|a| \leq 0\) 和 \(|a| \geq 0\) 得到 \(|a| = 0\)
   - 這是實數三歧性（Trichotomy Property）的應用

4. **全稱命題的證明**：
   - 證明 \(\forall \varepsilon > 0, P(\varepsilon)\) 需要對任意 \(\varepsilon > 0\) 證明 \(P(\varepsilon)\)
   - 在 Lean 中使用 `intro ε hε` 引入任意 \(\varepsilon > 0\)

5. **定理的組合使用**：
   - 這個證明結合了多個之前證明的定理
   - 展示了如何將簡單的定理組合成更複雜的證明

### 相關練習

- 比較這個定理與定理 1.9(1) 和 1.9(2) 的異同
- 證明：\((\forall \varepsilon > 0, |a| \leq \varepsilon) \leftrightarrow a = 0\)
- 思考：為什麼這個定理在分析學中如此重要？（它與極限的定義密切相關）

---

## 例題 1.11：證明 sup [0, 1] = 1

### 問題陳述

**例題 1.11**：設 \(E = [0, 1]\)（閉區間），證明 \(\sup E = 1\)。

這個例題展示了如何證明一個具體集合的上確界。閉區間 \([0, 1]\) 的上確界是 1，這是一個直觀的結果，但需要嚴格證明。

### 證明策略

根據上確界的定義，需要證明兩個部分：

1. **上界性**：證明 1 是 \([0, 1]\) 的上界
   - 需要證明：對所有 \(x \in [0, 1]\)，有 \(x \leq 1\)
   - 這直接從區間的定義得到：如果 \(x \in [0, 1]\)，則 \(x \leq 1\)

2. **最小性**：證明 1 是所有上界中最小的
   - 需要證明：對所有 \([0, 1]\) 的上界 \(M\)，有 \(1 \leq M\)
   - 使用反證法：假設 \(M < 1\)，但 \(1 \in [0, 1]\)，而 \(M < 1\)，這與 \(M\) 是上界矛盾

### Lean 程式碼

```lean
theorem Example_1_11 : is_supremum 1 (Set.Icc 0 1) := by
   constructor  -- 分開 is_supremum 的兩個部分：上界性和最小性
   intro x hx  -- 第一部分：引入 x 和 x ∈ [0, 1]
   exact hx.2  -- 從 x ∈ [0, 1] 得到 x ≤ 1（hx.2 提取第二個條件）
   intro M hM  -- 第二部分：引入 M 和 hM : M 是 [0, 1] 的上界
   by_contra h_not  -- 假設 ¬(1 ≤ M)（反證法）
   push_neg at h_not  -- 將 ¬(1 ≤ M) 轉換為 M < 1
   have h1_in : (1 : ℝ) ∈ Set.Icc (0 : ℝ) 1 := by  -- 證明 1 ∈ [0, 1]
      exact ⟨ by norm_num, by norm_num ⟩  -- 0 ≤ 1 且 1 ≤ 1（norm_num 自動證明）
   have h_contra : 1 ≤ M := hM 1 h1_in  -- 因為 M 是上界，所以 1 ≤ M
   have h : (1 : ℝ) < 1 := lt_of_le_of_lt h_contra h_not  -- 從 1 ≤ M 和 M < 1 得到 1 < 1
   exact lt_irrefl (1 : ℝ) h  -- 1 < 1 矛盾（lt_irrefl 表示一個數不能嚴格小於自己）
```

### 詳細證明步驟

#### 第一部分：證明 1 是 [0, 1] 的上界

1. **引入變數**：
   - `intro x hx`：引入 \(x\) 和假設 \(x \in [0, 1]\)
   - `hx : x ∈ Set.Icc 0 1` 表示 \(0 \leq x \land x \leq 1\)

2. **提取條件**：
   - `exact hx.2`：從 \(hx : 0 \leq x \land x \leq 1\) 提取第二個條件 \(x \leq 1\)
   - 這直接證明了 1 是上界

#### 第二部分：證明 1 是最小的上界

1. **引入上界**：
   - `intro M hM`：引入 \(M\) 和假設 \(M\) 是 \([0, 1]\) 的上界
   - `hM : is_upper_bound M (Set.Icc 0 1)` 表示對所有 \(x \in [0, 1]\)，有 \(x \leq M\)

2. **反證法**：
   - `by_contra h_not`：假設 \(\neg(1 \leq M)\)，即 \(M < 1\)
   - `push_neg at h_not`：將 \(\neg(1 \leq M)\) 轉換為 \(M < 1\)

3. **證明 1 屬於 [0, 1]**：
   - `have h1_in : 1 ∈ Set.Icc 0 1`：需要證明 \(0 \leq 1 \land 1 \leq 1\)
   - `⟨ by norm_num, by norm_num ⟩`：使用 `norm_num` 自動證明這兩個數值不等式

4. **應用上界定義**：
   - `have h_contra : 1 ≤ M := hM 1 h1_in`：因為 \(M\) 是上界，且 \(1 \in [0, 1]\)，所以 \(1 \leq M\)

5. **得到矛盾**：
   - `have h : 1 < 1 := lt_of_le_of_lt h_contra h_not`：從 \(1 \leq M\) 和 \(M < 1\) 得到 \(1 < 1\)
   - `exact lt_irrefl 1 h`：\(1 < 1\) 矛盾（一個數不能嚴格小於自己）

### 使用的定義和定理

1. **集合定義**：
   - `Set.Icc 0 1`：閉區間 \([0, 1] = \{x : \mathbb{R} \mid 0 \leq x \land x \leq 1\}\)

2. **上確界定義**：
   - `is_supremum s E`：\(s\) 是 \(E\) 的上確界，當且僅當：
     - \(s\) 是 \(E\) 的上界
     - 對所有 \(E\) 的上界 \(M\)，有 \(s \leq M\)

3. **邏輯操作**：
   - `constructor`：分開合取命題的兩個部分
   - `by_contra`：反證法
   - `push_neg`：應用 De Morgan 定律轉換否定

4. **不等式定理**：
   - `lt_of_le_of_lt`：從 \(a \leq b\) 和 \(b < c\) 得到 \(a < c\)
   - `lt_irrefl`：\(\neg(a < a)\)（一個數不能嚴格小於自己）

5. **自動證明**：
   - `norm_num`：自動證明數值不等式和等式

### 學習重點

1. **上確界的證明結構**：
   - 證明上確界需要兩個部分：上界性和最小性
   - 使用 `constructor` 分開這兩個目標

2. **從集合定義提取條件**：
   - 如果 \(x \in [0, 1]\)，則 \(x \leq 1\) 已經包含在定義中
   - 使用 `.2` 或 `.right` 提取合取命題的第二個條件

3. **反證法的應用**：
   - 證明最小性時，假設存在更小的上界 \(M < 1\)
   - 利用 \(1 \in [0, 1]\) 和上界定義得到矛盾

4. **自動證明的使用**：
   - `norm_num` 可以自動證明簡單的數值不等式
   - 這大大簡化了證明過程

5. **矛盾的識別**：
   - 從 \(1 \leq M\) 和 \(M < 1\) 得到 \(1 < 1\)
   - 使用 `lt_irrefl` 證明這是不可能的

### 相關練習

- 證明：\(\sup [a, b] = b\)（其中 \(a < b\)）
- 證明：\(\sup (0, 1) = 1\)（開區間）
- 證明：如果 \(E = \{1/n : n \in \mathbb{N}\}\)，則 \(\sup E = 1\)
- 思考：為什麼閉區間 \([0, 1]\) 的上確界是 1，而不是其他值？

---

## 備註 1.12：如果集合有一個上界，則有無窮多個上界

### 問題陳述

**備註 1.12**：如果一個集合有一個上界，則它有無窮多個上界。

這個備註說明了一個重要的觀察：上界不是唯一的。如果 \(M\) 是集合 \(E\) 的上界，那麼任何大於等於 \(M\) 的數都是 \(E\) 的上界。

### 證明策略

要證明這個備註，需要證明：如果 \(M\) 是 \(E\) 的上界，那麼對所有 \(N \geq M\)，\(N\) 也是 \(E\) 的上界。

證明思路：
1. 設 \(M\) 是 \(E\) 的上界
2. 設 \(N \geq M\)
3. 對任意 \(a \in E\)，需要證明 \(a \leq N\)
4. 因為 \(M\) 是上界，所以 \(a \leq M\)
5. 因為 \(M \leq N\)，由傳遞性得到 \(a \leq N\)

### Lean 程式碼

```lean
theorem Remark_1_12 (E : Set ℝ) (M : ℝ) (hM : is_upper_bound M E) :
   ∀ N : ℝ, N ≥ M → is_upper_bound N E := by
   intro N hN a ha  -- 引入 N、N ≥ M、a 和 a ∈ E
   have h1 : a ≤ M := hM a ha  -- 因為 M 是上界，所以 a ≤ M
   exact le_trans h1 hN  -- 從 a ≤ M 和 M ≤ N 得到 a ≤ N（傳遞性）
```

### 詳細證明步驟

1. **引入變數**：
   - `intro N hN a ha`：引入 \(N\)、假設 \(N \geq M\)、引入 \(a\) 和假設 \(a \in E\)
   - 目標是證明 \(a \leq N\)

2. **應用上界定義**：
   - `have h1 : a ≤ M := hM a ha`：因為 \(M\) 是 \(E\) 的上界，且 \(a \in E\)，所以 \(a \leq M\)
   - 這是直接應用 `is_upper_bound` 的定義

3. **使用傳遞性**：
   - `exact le_trans h1 hN`：從 \(a \leq M\)（`h1`）和 \(M \leq N\)（`hN`）得到 \(a \leq N\)
   - `le_trans` 是傳遞性定理：\(a \leq b \to b \leq c \to a \leq c\)

### 使用的定義和定理

1. **上界定義**：
   - `is_upper_bound M E`：\(M\) 是 \(E\) 的上界，當且僅當對所有 \(a \in E\)，有 \(a \leq M\)

2. **傳遞性定理**：
   - `le_trans`：\(\forall a b c : \mathbb{R}, a \leq b \to b \leq c \to a \leq c\)
   - 這是實數序關係的基本性質

### 學習重點

1. **上界的不唯一性**：
   - 如果一個集合有上界，則有無窮多個上界
   - 這是因為任何大於等於某個上界的數都是上界

2. **傳遞性的應用**：
   - 從 \(a \leq M\) 和 \(M \leq N\) 得到 \(a \leq N\)
   - 這是實數序關係的基本性質，在證明中經常使用

3. **全稱量詞的證明**：
   - 證明 \(\forall N : \mathbb{R}, N \geq M \to P(N)\) 需要對任意 \(N \geq M\) 證明 \(P(N)\)
   - 在 Lean 中使用 `intro N hN` 引入任意 \(N\) 和條件 \(N \geq M\)

4. **定義的直接應用**：
   - 如果 \(M\) 是上界，則對所有 \(a \in E\)，有 \(a \leq M\)
   - 這是上界定義的直接應用

### 相關練習

- 證明：如果一個集合有一個下界，則有無窮多個下界
- 思考：為什麼上界有無窮多個，但上確界是唯一的？
- 證明：如果 \(M\) 是 \(E\) 的上界，且 \(M' > M\)，則 \(M'\) 也是 \(E\) 的上界

---

## 備註 1.13：上確界的唯一性

### 問題陳述

**備註 1.13**：如果一個集合有上確界，則它只有一個上確界。

這個備註說明上確界是唯一的，這與上界有無窮多個形成對比。

### 證明策略

要證明唯一性，需要證明：如果 \(s_1\) 和 \(s_2\) 都是 \(E\) 的上確界，則 \(s_1 = s_2\)。

證明思路：
1. 因為 \(s_1\) 是上確界，\(s_2\) 是上界，所以 \(s_1 \leq s_2\)
2. 因為 \(s_2\) 是上確界，\(s_1\) 是上界，所以 \(s_2 \leq s_1\)
3. 由 \(s_1 \leq s_2\) 和 \(s_2 \leq s_1\) 得到 \(s_1 = s_2\)

### Lean 程式碼

```lean
theorem Remark_1_13 (E : Set ℝ) (s1 s2 : ℝ) (hs1 : is_supremum s1 E) (hs2 : is_supremum s2 E) :
   s1 = s2 := by
   have h1 : s1 ≤ s2 := hs1.2 s2 hs2.1  -- s1 是上確界，s2 是上界，所以 s1 ≤ s2
   have h2 : s2 ≤ s1 := hs2.2 s1 hs1.1  -- s2 是上確界，s1 是上界，所以 s2 ≤ s1
   have h4 : s1 = s2 := le_antisymm h1 h2  -- 從 s1 ≤ s2 和 s2 ≤ s1 得到 s1 = s2
   exact h4  -- 完成證明
```

### 詳細證明步驟

1. **應用上確界的性質**：
   - `hs1.2` 是 `is_supremum s1 E` 的第二個部分：對所有上界 \(M\)，有 \(s_1 \leq M\)
   - `hs2.1` 是 `is_supremum s2 E` 的第一個部分：\(s_2\) 是上界
   - 所以 `hs1.2 s2 hs2.1` 表示 \(s_1 \leq s_2\)

2. **對稱地得到另一個不等式**：
   - 同樣地，因為 \(s_2\) 是上確界，\(s_1\) 是上界，所以 \(s_2 \leq s_1\)

3. **使用反對稱性**：
   - `le_antisymm` 表示：如果 \(a \leq b\) 且 \(b \leq a\)，則 \(a = b\)
   - 從 \(s_1 \leq s_2\) 和 \(s_2 \leq s_1\) 得到 \(s_1 = s_2\)

### 使用的定義和定理

1. **上確界定義**：
   - `is_supremum s E` 包含兩個部分：
     - `.1`：\(s\) 是 \(E\) 的上界
     - `.2`：對所有上界 \(M\)，有 \(s \leq M\)

2. **反對稱性定理**：
   - `le_antisymm`：\(\forall a b : \mathbb{R}, a \leq b \to b \leq a \to a = b\)

### 學習重點

1. **唯一性證明的標準方法**：
   - 證明兩個對象相等，通常先證明 \(a \leq b\)，再證明 \(b \leq a\)，最後使用反對稱性

2. **上確界與上界的區別**：
   - 上界有無窮多個，但上確界是唯一的
   - 這是因為上確界是所有上界中最小的

3. **定義的結構化使用**：
   - `is_supremum` 的兩個部分（`.1` 和 `.2`）在證明中都有重要作用

### 相關練習

- 證明：如果一個集合有下確界，則它只有一個下確界
- 思考：為什麼上確界是唯一的，而上界有無窮多個？

---

## 定理 1.14：上確界的逼近性質

### 問題陳述

**定理 1.14**：如果集合 \(E\) 有有限的上確界 \(s = \sup E\)，且 \(\varepsilon > 0\) 是任意正數，則存在點 \(a \in E\)，使得
\[
\sup E - \varepsilon < a \leq \sup E
\]

這個定理說明：上確界可以被集合中的點任意接近（從下方）。

### 證明策略

使用反證法：
1. 假設不存在這樣的 \(a \in E\)
2. 那麼對所有 \(a \in E\)，有 \(a \leq s - \varepsilon\)
3. 所以 \(s - \varepsilon\) 是上界
4. 因為 \(s\) 是上確界，所以 \(s \leq s - \varepsilon\)
5. 這意味著 \(\varepsilon \leq 0\)，與 \(\varepsilon > 0\) 矛盾

### Lean 程式碼

```lean
theorem Theorem_1_14 (E : Set ℝ) (s : ℝ) (hs : is_supremum s E) (ε : ℝ) (hε : ε > 0) :
   ∃ a ∈ E, s - ε < a ∧ a ≤ s := by
   by_contra h_not  -- 假設不存在這樣的 a（反證法）
   have h1 : ∀ a ∈ E, a ≤ s - ε := by  -- 證明對所有 a ∈ E，有 a ≤ s - ε
      intro a ha  -- 引入 a ∈ E
      have h2 : a ≤ s := hs.1 a ha  -- s 是上界，所以 a ≤ s
      by_cases h3 : s - ε < a  -- 分情況：s - ε < a 或 s - ε ≥ a
      · have h4 : s - ε < a ∧ a ≤ s := ⟨ h3, h2 ⟩  -- 如果 s - ε < a，則滿足條件
        exact absurd ⟨ a, ha, h4 ⟩ h_not  -- 與 h_not 矛盾（存在這樣的 a）
      · push_neg at h3  -- s - ε ≥ a，即 a ≤ s - ε
        exact h3  -- 這就是我們要的
   have h5 : is_upper_bound (s - ε) E := h1  -- s - ε 是上界
   have h6 : s ≤ s - ε := hs.2 (s - ε) h5  -- s 是上確界，所以 s ≤ s - ε
   have h7 : ε ≤ 0 := by linarith  -- 從 s ≤ s - ε 得到 ε ≤ 0
   exact not_le_of_gt hε h7  -- ε > 0 與 ε ≤ 0 矛盾
```

### 詳細證明步驟

#### 第一步：反證法假設

1. **假設不存在**：
   - `by_contra h_not`：假設不存在 \(a \in E\) 使得 \(s - \varepsilon < a \leq s\)
   - `h_not : ¬(∃ a ∈ E, s - ε < a ∧ a ≤ s)`

#### 第二步：證明對所有 a ∈ E，有 a ≤ s - ε

2. **引入變數**：
   - `intro a ha`：引入 \(a \in E\)

3. **應用上界定義**：
   - `have h2 : a ≤ s := hs.1 a ha`：因為 \(s\) 是上界，所以 \(a \leq s\)

4. **分情況討論**：
   - `by_cases h3 : s - ε < a`：分兩種情況
     - **情況 1**（`s - ε < a`）：
       - 構造 `⟨h3, h2⟩` 得到 \(s - \varepsilon < a \land a \leq s\)
       - 構造 `⟨a, ha, h4⟩` 得到存在性證明
       - `exact absurd ⟨a, ha, h4⟩ h_not`：與 `h_not` 矛盾
     - **情況 2**（`s - ε ≥ a`）：
       - `push_neg at h3`：將 `¬(s - ε < a)` 轉換為 `a ≤ s - ε`
       - `exact h3`：這就是我們要的結論

#### 第三步：得到矛盾

5. **證明 s - ε 是上界**：
   - `have h5 : is_upper_bound (s - ε) E := h1`：從 `h1` 得到 \(s - \varepsilon\) 是上界

6. **應用上確界的性質**：
   - `have h6 : s ≤ s - ε := hs.2 (s - ε) h5`：因為 \(s\) 是上確界，\(s - \varepsilon\) 是上界，所以 \(s \leq s - \varepsilon\)

7. **推導矛盾**：
   - `have h7 : ε ≤ 0 := by linarith`：從 \(s \leq s - \varepsilon\) 得到 \(\varepsilon \leq 0\)
   - `exact not_le_of_gt hε h7`：\(\varepsilon > 0\) 與 \(\varepsilon \leq 0\) 矛盾

### 使用的定義和定理

1. **上確界定義**：
   - `is_supremum s E` 包含兩個部分：
     - `.1`：\(s\) 是 \(E\) 的上界
     - `.2`：對所有上界 \(M\)，有 \(s \leq M\)

2. **邏輯操作**：
   - `by_contra`：反證法
   - `by_cases`：分情況討論
   - `push_neg`：應用 De Morgan 定律轉換否定
   - `absurd`：從矛盾得到任意結論

3. **不等式定理**：
   - `not_le_of_gt`：從 \(a > b\) 得到 \(\neg(a \leq b)\)
   - `linarith`：線性算術自動證明

### 學習重點

1. **反證法的應用**：
   - 證明存在性時，假設不存在，然後推導矛盾
   - 這是證明存在性的常用方法

2. **分情況討論的技巧**：
   - 使用 `by_cases` 分兩種情況
   - 一種情況得到矛盾，另一種情況得到結論

3. **上確界的逼近性質**：
   - 這個定理說明上確界可以被集合中的點任意接近
   - 這是上確界的重要性質，在分析學中經常使用

4. **構造存在性證明**：
   - 在 Lean 中，存在性證明用 `⟨a, ha, P⟩` 構造
   - 需要提供元素、元素屬於集合的證明，以及性質的證明

### 相關練習

- 證明：如果 \(E\) 有有限的下確界，且 \(\varepsilon > 0\)，則存在 \(a \in E\) 使得 \(\inf E \leq a < \inf E + \varepsilon\)
- 思考：為什麼這個定理在分析學中如此重要？（它與極限和連續性密切相關）

---

## 定理 1.15：整數集合的上確界必為整數

### 問題陳述

**定理 1.15**：如果 \(E \subseteq \mathbb{Z}\) 有上確界，則 \(\sup E \in E\)。特別地，如果一個只包含整數的集合有上確界，那麼這個上確界必須是整數。

**說明**：這個定理說明了一個重要的性質：對於整數集合，如果它有上確界，那麼這個上確界必須是集合中的一個元素。這與一般實數集合不同，一般實數集合的上確界可能不在集合中（例如開區間 \((0, 1)\) 的上確界是 1，但 1 不在開區間中）。

### 證明策略

使用反證法，證明思路如下：

1. **假設結論不成立**：假設 \(\sup E \notin E\)（即上確界不在集合中）
2. **找到第一個整數**：使用定理 1.14，找到一個整數 \(n \in E\)，使得 \(s - 1/2 < n \leq s\)
3. **證明 \(n < s\)**：如果 \(n = s\)，則 \(s\) 在 \(E\) 中，與假設矛盾
4. **找到第二個整數**：再次使用定理 1.14，找到另一個整數 \(m \in E\)，使得 \(n < m \leq s\)
5. **推導矛盾**：
   - 證明 \(0 < m - n < 1\)
   - 但整數的差 \(m - n\) 也是整數
   - 不存在整數 \(k\) 使得 \(0 < k < 1\)（整數的三歧性）
   - 因此得到矛盾

### 完整證明

```lean
theorem Theorem_1_15 (E : Set ℤ) (s : ℝ) (hs : is_supremum s (E.image (Int.cast : ℤ → ℝ))) :
   (s : ℝ) ∈ (E.image (Int.cast : ℤ → ℝ)) := by
   by_contra h_not  -- 反證法：假設 s 不在 E 的像中
   have h1 : ∃ a ∈ E.image (Int.cast : ℤ → ℝ), s - (1/2 : ℝ) < a ∧ a ≤ s :=
      Theorem_1_14 (E.image (Int.cast : ℤ → ℝ)) s hs (1/2 : ℝ) (by norm_num)  -- 使用定理 1.14，取 ε = 1/2
   obtain ⟨a, ha_in, h1_left, h1_right⟩ := h1  -- 分解存在性證明，得到 a ∈ E 的像，且 s - 1/2 < a ≤ s
   obtain ⟨n, hn_in, hn_eq⟩ := ha_in  -- 因為 a 在 E 的像中，存在整數 n ∈ E 使得 a = ↑n
   have h2 : a = (n : ℝ) := hn_eq.symm  -- a 等於整數 n 的實數轉換
   have h3 : a < s := by  -- 證明 a < s（關鍵步驟）
      by_contra h_eq  -- 假設 a ≥ s
      push_neg at h_eq  -- 轉換為 a ≥ s
      have h4 : a = s := le_antisymm h1_right h_eq  -- 從 a ≤ s 和 a ≥ s 得到 a = s
      rw [← h2, h4] at hn_eq  -- 將 a 替換為 s，得到 s = ↑n
      have h5 : s = (n : ℝ) := h4.symm.trans h2  -- s = a = ↑n
      have h6 : (n : ℝ) ∈ E.image (Int.cast : ℤ → ℝ) := ⟨ n, hn_in, rfl ⟩  -- n 在 E 的像中
      rw [← h5] at h6  -- 將 ↑n 替換為 s
      exact h_not h6  -- 與假設矛盾（s 在 E 的像中）
   have h7 : s - a > 0 := sub_pos.mpr h3  -- 從 a < s 得到 s - a > 0
   have h8 : ∃ b ∈ E.image (Int.cast : ℤ → ℝ), a < b ∧ b ≤ s := by  -- 存在另一個整數 b，使得 a < b ≤ s
      have h9 : ∃ b ∈ E.image (Int.cast : ℤ → ℝ), s - (s - a) < b ∧ b ≤ s :=
         Theorem_1_14 (E.image (Int.cast : ℤ → ℝ)) s hs (s - a) h7  -- 使用定理 1.14，取 ε = s - a
      obtain ⟨ b, hb_in, hb_left, hb_right⟩ := h9  -- 分解存在性證明
      have h10 : a = s - (s - a) := by ring  -- 代數恆等式：a = s - (s - a)
      have h11 : a < b := by rw [h10]; exact hb_left  -- 從 s - (s - a) < b 得到 a < b
      use b, hb_in, h11, hb_right  -- 構造存在性證明
   obtain ⟨ b, hb_in, hb_left, hb_right⟩ := h8  -- 分解得到整數 b，滿足 a < b ≤ s
   obtain ⟨ m, hm_in, hm_eq⟩ := hb_in  -- 因為 b 在 E 的像中，存在整數 m ∈ E 使得 b = ↑m
   have h12 : b = (m : ℝ) := hm_eq.symm  -- b 等於整數 m 的實數轉換
   have h13 : 0 < b - a := sub_pos.mpr hb_left  -- 從 a < b 得到 b - a > 0
   have h14 : b - a < 1 := by  -- 證明 b - a < 1（關鍵不等式）
      have h15 : s - (1/2 : ℝ) < a := h1_left  -- 從 h1 得到 s - 1/2 < a
      calc
         b - a
         _ ≤ s - a := sub_le_sub_right hb_right a  -- 從 b ≤ s 得到 b - a ≤ s - a
         _ < 1/2 := by linarith  -- 從 s - 1/2 < a 得到 s - a < 1/2
         _ < 1 := by norm_num  -- 1/2 < 1
   have h16 : b - a = (m - n : ℝ) := by rw [h12, h2]  -- b - a = ↑m - ↑n = ↑(m - n)
   have h17 : (0 : ℝ) < (m - n : ℝ) ∧ (m - n : ℝ) < 1 := by  -- 0 < ↑(m - n) < 1
      constructor
      rw [← h16]; exact h13  -- 從 b - a > 0 得到 ↑(m - n) > 0
      rw [← h16]; exact h14  -- 從 b - a < 1 得到 ↑(m - n) < 1
   have h18 : ¬ (∃ k : ℤ, (0 : ℝ) < (k : ℝ) ∧ (k : ℝ) < 1) := by  -- 不存在整數 k 使得 0 < ↑k < 1
      intro h  -- 假設存在這樣的 k
      obtain ⟨ k, hk_left, hk_right⟩ := h  -- 分解存在性證明
      have h19 : (k : ℤ) ≤ 0 ∨ (k : ℤ) ≥ 1 := by  -- 整數的三歧性：k ≤ 0 或 k ≥ 1
         by_cases h_le : (k : ℤ) ≤ 0  -- 分情況：k ≤ 0 或 k > 0
         left; exact h_le  -- 情況 1：k ≤ 0
         right  -- 情況 2：k > 0
         push_neg at h_le  -- 轉換為 k > 0
         exact Int.add_one_le_of_lt h_le  -- 從 k > 0 得到 k ≥ 1（整數性質）
      cases h19 with
      | inl h_le =>  -- 情況 1：k ≤ 0
         have h20 : (k : ℝ) ≤ 0:= by
            rw [← Int.cast_zero]
            exact Int.cast_le.mpr h_le  -- 整數轉換保序：k ≤ 0 則 ↑k ≤ 0
         linarith  -- 與 hk_left : ↑k > 0 矛盾
      | inr h_ge =>  -- 情況 2：k ≥ 1
         have h21 : (k : ℝ) ≥ 1 := by
            rw [← Int.cast_one]
            exact Int.cast_le.mpr h_ge  -- 整數轉換保序：k ≥ 1 則 ↑k ≥ 1
         linarith  -- 與 hk_right : ↑k < 1 矛盾
   have h22 : (0 : ℝ) < ↑(m - n) := by  -- 證明 0 < ↑(m - n)
      calc
         (0 : ℝ)
         _ < ↑m - ↑n := h17.1  -- 從 h17 得到 0 < ↑m - ↑n
         _ = ↑(m - n) := (Int.cast_sub m n).symm  -- 使用整數轉換的減法性質
   have h23 : ↑(m - n) < (1 : ℝ) := by  -- 證明 ↑(m - n) < 1
      calc
         ↑(m - n)
         _ = ↑m - ↑n := Int.cast_sub m n  -- 使用整數轉換的減法性質
         _ < (1 : ℝ) := h17.2  -- 從 h17 得到 ↑m - ↑n < 1
   exact h18 ⟨m - n, h22, h23⟩  -- 與 h18 矛盾（存在整數 m - n 使得 0 < ↑(m - n) < 1）
```

### 詳細證明步驟

#### 第一步：反證法假設

1. **假設結論不成立**：
   - `by_contra h_not`：假設上確界 \(s\) 不在 \(E\) 的像中
   - 目標是推導出矛盾

#### 第二步：找到第一個整數

2. **應用定理 1.14**：
   - 使用定理 1.14，取 \(\varepsilon = 1/2\)
   - 得到存在 \(a \in E\) 的像，使得 \(s - 1/2 < a \leq s\)
   - 因為 \(a\) 在 \(E\) 的像中，存在整數 \(n \in E\) 使得 \(a = n\)（作為實數）

3. **證明 \(n < s\)**：
   - 如果 \(n = s\)，則 \(s\) 在 \(E\) 中，與假設矛盾
   - 因此必須有 \(n < s\)

#### 第三步：找到第二個整數

4. **再次應用定理 1.14**：
   - 因為 \(s - n > 0\)，使用定理 1.14，取 \(\varepsilon = s - n\)
   - 得到存在另一個點 \(b \in E\) 的像，使得 \(s - (s - n) < b \leq s\)
   - 簡化：\(n < b \leq s\)
   - 因為 \(b\) 在 \(E\) 的像中，存在整數 \(m \in E\) 使得 \(b = m\)（作為實數）

#### 第四步：推導關鍵不等式

5. **證明 \(0 < m - n < 1\)**：
   - 從 \(n < m \leq s\) 得到 \(0 < m - n\)
   - 從 \(s - 1/2 < n\) 和 \(m \leq s\) 得到：
     \[
     m - n \leq s - n < s - (s - 1/2) = 1/2 < 1
     \]
   - 因此 \(0 < m - n < 1\)

#### 第五步：推導矛盾

6. **整數的三歧性**：
   - 對於任意整數 \(k\)，要麼 \(k \leq 0\)，要麼 \(k \geq 1\)
   - 不存在整數 \(k\) 使得 \(0 < k < 1\)

7. **應用到 \(m - n\)**：
   - \(m - n\) 是整數（因為 \(m\) 和 \(n\) 都是整數）
   - 但我們證明了 \(0 < m - n < 1\)
   - 這與整數的三歧性矛盾

8. **完成證明**：
   - 假設導致矛盾，因此原結論成立
   - 即：如果整數集合有上確界，則上確界必須在集合中

### 使用的定義和定理

1. **定理 1.14**：
   - 如果集合有上確界 \(s\)，且 \(\varepsilon > 0\)，則存在 \(a \in E\) 使得 \(s - \varepsilon < a \leq s\)
   - 這是上確界的逼近性質

2. **整數的三歧性**：
   - 對於任意整數 \(k\)，有 \(k \leq 0\) 或 \(k \geq 1\)
   - 不存在整數 \(k\) 使得 \(0 < k < 1\)

3. **整數轉換的性質**：
   - `Int.cast_sub`：\(\uparrow(m - n) = \uparrow m - \uparrow n\)
   - `Int.cast_le`：整數轉換保序
   - `Int.add_one_le_of_lt`：如果整數 \(k > 0\)，則 \(k \geq 1\)

4. **反證法**：
   - `by_contra`：假設結論不成立，推導矛盾

### 學習重點

1. **反證法的應用**：
   - 這個證明展示了如何使用反證法來證明存在性
   - 假設結論不成立，然後推導出邏輯矛盾

2. **整數的特殊性質**：
   - 整數是離散的，任意兩個不同整數之間的距離至少為 1
   - 這與實數的稠密性形成對比

3. **上確界的逼近性質**：
   - 定理 1.14 允許我們找到任意接近上確界的點
   - 對於整數集合，這導致上確界必須是集合中的元素

4. **類型轉換的使用**：
   - 在 Lean 中，需要將整數轉換為實數來使用實數的性質
   - `Int.cast` 用於整數到實數的轉換
   - 需要注意轉換後的性質（如保序性）

5. **代數恆等式的使用**：
   - \(a = s - (s - a)\) 是一個有用的代數恆等式
   - 在證明中經常使用這類恆等式來重組表達式

### 相關練習

- 證明：如果 \(E \subseteq \mathbb{Z}\) 有下確界，則 \(\inf E \in E\)
- 思考：為什麼實數集合的上確界可能不在集合中，而整數集合的上確界必須在集合中？
- 證明：如果 \(E \subseteq \mathbb{N}\)（自然數集合）有上確界，則 \(\sup E \in E\)
- 應用：使用這個定理證明，如果整數序列有上確界，則上確界是序列中的某項

---

## 定理 1.16：阿基米德性質（Archimedean Property）

### 問題陳述

**定理 1.16（阿基米德性質）**：給定正實數 \(a > 0\) 和任意實數 \(b\)，存在自然數 \(n \in \mathbb{N}\)，使得
\[
b < n \cdot a
\]

**說明**：這個定理說明，無論實數 \(b\) 有多大，我們總能找到一個自然數 \(n\)，使得 \(n\) 個 \(a\) 的和超過 \(b\)。這是實數系統的一個基本性質，保證了自然數集合在實數中是「無界的」。

**幾何直觀**：想像在數線上，從 0 開始，每次向右移動 \(a\) 的距離。阿基米德性質說，無論 \(b\) 在數線上有多遠，我們總能通過足夠多次移動到達或超過 \(b\)。

### 證明策略

這個證明是本教材中最複雜的證明之一，使用了完備性公設（Completeness Axiom）和反證法。主要思路如下：

#### **第一步：處理簡單情況**
- 如果 \(b < a\)，則取 \(n = 1\) 即可

#### **第二步：處理一般情況（\(a \leq b\)）**
當 \(a \leq b\) 時，我們需要使用更複雜的論證：

1. **定義集合 \(E\)**：
   \[
   E = \{k \cdot a : k \in \mathbb{N} \text{ 且 } k \cdot a \leq b\}
   \]
   這是所有不超過 \(b\) 的 \(a\) 的倍數組成的集合

2. **證明 \(E\) 非空且有上界**：
   - **非空性**：因為 \(a \leq b\)，所以 \(1 \cdot a = a \leq b\)，因此 \(a \in E\)
   - **有界性**：\(b\) 是 \(E\) 的上界（根據 \(E\) 的定義）

3. **應用完備性公設**：
   - 因為 \(E\) 非空且有上界，根據完備性公設，\(E\) 有上確界
   - 設 \(s = \sup E\)

4. **證明 \(s \in E\)**（關鍵步驟）：
   - 使用反證法：假設 \(s \notin E\)
   - 應用定理 1.14（上確界逼近性質）兩次：
     - 第一次：找到整數 \(k\)，使得 \(s - a/2 < k \cdot a \leq s\)
     - 第二次：找到另一個整數 \(m\)，使得 \(k \cdot a < m \cdot a \leq s\)
   - 推導出 \((k+1) \cdot a \in E\) 且 \((k+1) \cdot a > s\)
   - 這與 \(s\) 是上界矛盾
   - 因此 \(s \in E\)

5. **完成證明**：
   - 從 \(s \in E\) 得到：存在整數 \(k\) 使得 \(s = k \cdot a\) 且 \(k \cdot a \leq b\)
   - 取 \(n = k + 1\)
   - 分兩種情況：
     - 如果 \((k+1) \cdot a \leq b\)，則 \((k+1) \cdot a \in E\)，且 \((k+1) \cdot a > s = k \cdot a\)（因為 \(a > 0\)）
     - 但同時 \((k+1) \cdot a \leq s\)（因為 \(s\) 是上界）
     - 這導致 \(s < s\)，矛盾
   - 因此必須 \((k+1) \cdot a > b\)，即 \(b < (k+1) \cdot a\)

### 完整 Lean 證明

```lean
theorem Theorem_1_16 (a b : ℝ) (ha : a > 0) :  -- 定理 1.16（阿基米德性質）：給定正實數 a 和任意實數 b
   ∃ n : ℕ, b < n * a := by  -- 存在自然數 n 使得 b < n * a
   by_cases h_case : b < a  -- 情況分析：b < a 或 a ≤ b
   use 1  -- 若 b < a，取 n = 1
   simp  -- 簡化目標為 b < a
   exact h_case  -- 用假設 b < a 完成證明
   push_neg at h_case  -- 否則，將 ¬(b < a) 轉換為 a ≤ b
   let E : Set ℝ := {x : ℝ | ∃ k : ℕ, x = (k : ℝ) * a ∧ (k : ℝ) * a ≤ b}  -- 定義集合 E = {ka | k ∈ ℕ 且 ka ≤ b}
   have h_nonempty : Set.Nonempty E := by  -- 證明 E 非空
      use (1 : ℝ) * a  -- 提供元素 1 * a
      use 1  -- 提供自然數 k = 1
      constructor  -- 證明合取：(1) 1 * a = 1 * a，(2) 1 * a ≤ b
      · simp  -- 證明等式 (1 : ℝ) * a = (1 : ℝ) * a
      · simp  -- 簡化 1 * a 為 a
        exact h_case  -- 使用 a ≤ b 證明 1 * a ≤ b
   have h_bounded : bounded_above E := by  -- 證明 E 有上界
      use b  -- 聲稱 b 是 E 的上界
      intro x hx  -- 對任意 x ∈ E
      obtain ⟨ k, hk_eq, hk_le⟩ := hx  -- 從 x ∈ E 得到：x = ka 且 ka ≤ b
      rw [hk_eq]  -- 將 x 改寫為 ka
      exact hk_le  -- 用 ka ≤ b 證明 x ≤ b
   have h_sup : ∃ s : ℝ, is_supremum s E := by  -- 證明 E 有上確界
      have h_bdd : BddAbove E := by  -- 先將 bounded_above 轉換為 Mathlib 的 BddAbove
         obtain ⟨M, hM⟩ := h_bounded  -- 從 bounded_above E 取得上界 M
         use M  -- 用 M 構造 BddAbove 的證明
         exact hM  -- M 是 E 的上界
      use sSup E  -- 應用完備性公設：使用 Mathlib 的 sSup（上確界）
      constructor  -- 證明 sSup E 滿足上確界的兩個性質
      · intro x hx  -- (1) sSup E 是上界：對任意 x ∈ E
        exact le_csSup h_bdd hx  -- 用 Mathlib 定理證明 x ≤ sSup E
      · intro M hM  -- (2) sSup E 是最小上界：對任意 E 的上界 M
        exact csSup_le h_nonempty hM  -- 用 Mathlib 定理證明 sSup E ≤ M
   obtain ⟨s, hs_sup⟩ := h_sup  -- 取得上確界 s 及其性質 hs_sup
   have h_s_in_E : s ∈ E := by  -- 證明 s ∈ E（關鍵步驟）
      by_contra h_not  -- 反證法：假設 s ∉ E
      have h_eps_pos : a / 2 > 0 := div_pos ha (by norm_num)  -- a / 2 > 0（因為 a > 0）
      have h_approx : ∃ x ∈ E, s - (a / 2) < x ∧ x ≤ s :=  -- 由定理 1.14（上確界逼近性質）
         Theorem_1_14 E s hs_sup (a / 2) h_eps_pos  -- 存在 x ∈ E 使得 s - a/2 < x ≤ s
      obtain ⟨x, hx_in, hx_left, hx_right⟩ := h_approx  -- 取得這樣的 x 及其性質
      obtain ⟨k, hk_eq, hk_le⟩ := hx_in  -- 從 x ∈ E 得到：x = ka 且 ka ≤ b
      have h_x_lt_s : x < s := by  -- 證明 x < s（嚴格小於）
         by_contra h_ge  -- 反證法：假設 ¬(x < s)
         push_neg at h_ge  -- 轉換為 s ≤ x
         have h_eq : x = s := le_antisymm hx_right h_ge  -- 由 x ≤ s 和 s ≤ x 得 x = s
         rw [hk_eq] at h_eq  -- 將 x = ka 代入得 ka = s
         have h_s_in : s ∈ E := by  -- 這表示 s ∈ E
            use k  -- 見證者為 k
            exact ⟨h_eq.symm, hk_le⟩  -- s = ka 且 ka ≤ b
         exact h_not h_s_in  -- 矛盾：s ∈ E 但我們假設 s ∉ E
      have h_gap : s - x > 0 := sub_pos.mpr h_x_lt_s  -- 由 x < s 得 s - x > 0
      have h_approx2 : ∃ y ∈ E, s - (s - x) < y ∧ y ≤ s :=  -- 再次應用定理 1.14
         Theorem_1_14 E s hs_sup (s - x) h_gap  -- 存在 y ∈ E 使得 x < y ≤ s
      obtain ⟨y, hy_in, hy_left, hy_right⟩ := h_approx2  -- 取得這樣的 y
      obtain ⟨m, hm_eq, hm_le⟩ := hy_in  -- 從 y ∈ E 得到：y = ma 且 ma ≤ b
      have h_y_gt_x : y > x := by  -- 證明 y > x
         have h10 : x = s - (s - x) := by ring  -- 代數計算：x = s - (s - x)
         rw [h10]  -- 改寫目標
         exact hy_left  -- 由 s - (s - x) < y 得證
      rw [hk_eq, hm_eq] at h_y_gt_x  -- 改寫為 ma > ka
      have h_m_gt_k : (m : ℕ) > k := by  -- 證明 m > k（作為自然數）
         by_contra h_le  -- 反證法：假設 ¬(m > k)
         push_neg at h_le  -- 轉換為 m ≤ k
         have h_m_le_k : (m : ℝ) ≤ (k : ℝ) := Nat.cast_le.mpr h_le  -- 轉型到實數：m ≤ k
         have h_mul_le : (m : ℝ) * a ≤ (k : ℝ) * a := by  -- 兩邊乘以 a
            have h_pos : 0 ≤ a := le_of_lt ha  -- a ≥ 0
            exact mul_le_mul_of_nonneg_right h_m_le_k h_pos  -- 得 ma ≤ ka
         linarith  -- 矛盾：ma ≤ ka 但 ma > ka
      have h_m_ge_k1 : (m : ℕ) ≥ k + 1 := Nat.succ_le_of_lt h_m_gt_k  -- 由 m > k 得 m ≥ k + 1
      have h_n_in_E : ((k + 1 : ℕ) : ℝ) * a ∈ E := by  -- 證明 (k+1)a ∈ E
         have h_k1_le_b : ((k + 1 : ℕ) : ℝ) * a ≤ b := by  -- 證明 (k+1)a ≤ b
            have h_mul_le : ((k + 1 : ℕ) : ℝ) * a ≤ (m : ℝ) * a := by  -- 先證 (k+1)a ≤ ma
               have h_nat_le : (k + 1 : ℕ) ≤ m := h_m_ge_k1  -- k + 1 ≤ m
               have h_cast_le : ((k + 1 : ℕ) : ℝ) ≤ (m : ℝ) := Nat.cast_le.mpr h_nat_le  -- 轉型到實數
               have h_pos : 0 ≤ a := le_of_lt ha  -- a ≥ 0
               exact mul_le_mul_of_nonneg_right h_cast_le h_pos  -- 兩邊乘以 a
            have h_y_le_s : y ≤ s := hy_right  -- y ≤ s
            have h_s_le_b : s ≤ b := by  -- 證明 s ≤ b
               have h_b_ub : is_upper_bound b E := by  -- b 是 E 的上界
                  intro z hz  -- 對任意 z ∈ E
                  obtain ⟨n, hn_eq, hn_le⟩ := hz  -- z = na 且 na ≤ b
                  rw [hn_eq]  -- 改寫 z 為 na
                  exact hn_le  -- z = na ≤ b
               exact hs_sup.2 b h_b_ub  -- s 是最小上界，所以 s ≤ b
            have h_m_le_b : (m : ℝ) * a ≤ b := hm_le  -- ma ≤ b
            linarith  -- 由 (k+1)a ≤ ma 和 ma ≤ b 得 (k+1)a ≤ b
         use k + 1, rfl, h_k1_le_b  -- 構造證明：(k+1)a = (k+1)a 且 (k+1)a ≤ b
      have h_n_gt_s : ((k + 1 : ℕ) : ℝ) * a > s := by  -- 證明 (k+1)a > s
         have h_add : ((k + 1 : ℕ) : ℝ) * a = (k : ℝ) * a + a := by simp; ring  -- (k+1)a = ka + a
         rw [h_add]  -- 改寫目標為 ka + a > s
         have h_x_eq : x = (k : ℝ) * a := hk_eq  -- x = ka
         rw [← h_x_eq]  -- 改寫為 x + a > s
         linarith  -- 由 s - x < a/2 < a 推得 x + a > s
      have h_n_le_s : ((k + 1 : ℕ) : ℝ) * a ≤ s := hs_sup.1 _ h_n_in_E  -- 由 (k+1)a ∈ E 和 s 是上界得 (k+1)a ≤ s
      linarith  -- 矛盾：(k+1)a > s 且 (k+1)a ≤ s，所以原假設 s ∉ E 不成立
   obtain ⟨k, hk_eq, hk_le⟩ := h_s_in_E  -- 從 s ∈ E 得到：s = ka 且 ka ≤ b
   use k + 1  -- 取 n = k + 1
   by_cases h_case2 : ((k + 1 : ℕ) : ℝ) * a ≤ b  -- 情況分析：(k+1)a ≤ b 或 b < (k+1)a
   · have h_n_in_E : ((k + 1 : ℕ) : ℝ) * a ∈ E := ⟨k + 1, rfl, h_case2⟩  -- 若 (k+1)a ≤ b，則 (k+1)a ∈ E
     have h_gt : ((k + 1 : ℕ) : ℝ) * a > s := by  -- 證明 (k+1)a > s
        have h_add : ((k + 1 : ℕ) : ℝ) * a = (k : ℝ) * a + a := by simp; ring  -- (k+1)a = ka + a
        rw [h_add, ← hk_eq]  -- 改寫為 s + a > s（因為 s = ka）
        linarith  -- 由 a > 0 得 s + a > s
     have h_le : ((k + 1 : ℕ) : ℝ) * a ≤ s := hs_sup.1 _ h_n_in_E  -- 由 (k+1)a ∈ E 和 s 是上界得 (k+1)a ≤ s
     have h_s_lt_s : s < s := by  -- 推出矛盾：s < s
        have h_lt : s < ((k + 1 : ℕ) : ℝ) * a := gt_iff_lt.mp h_gt  -- 由 (k+1)a > s 得 s < (k+1)a
        exact lt_of_lt_of_le h_lt h_le  -- 由 s < (k+1)a 和 (k+1)a ≤ s 得 s < s
     exact False.elim (lt_irrefl s h_s_lt_s)  -- 矛盾消去：由 s < s（不可能）證明任何結論
   · push_neg at h_case2  -- 否則，¬((k+1)a ≤ b) 即 b < (k+1)a
     exact h_case2  -- 這正是我們要證明的目標 b < (k+1)a
```

### 詳細證明步驟說明

#### **第一部分：處理簡單情況（b < a）**

1. **情況分析**：
   - 使用 `by_cases h_case : b < a` 分兩種情況
   - 如果 `b < a`，證明變得簡單

2. **直接構造**：
   - 取 `n = 1`
   - 目標變為證明 `b < 1 * a`，即 `b < a`
   - 這正是我們的假設

#### **第二部分：定義集合 E**

3. **集合定義**：
   ```lean
   let E : Set ℝ := {x : ℝ | ∃ k : ℕ, x = (k : ℝ) * a ∧ (k : ℝ) * a ≤ b}
   ```
   - `E` 是所有不超過 `b` 的 `a` 的倍數
   - 形式上：\(E = \{k \cdot a : k \in \mathbb{N}, k \cdot a \leq b\}\)

4. **為什麼定義這個集合？**
   - 我們想要找一個自然數 `n`，使得 `n * a > b`
   - 等價於找最大的 `k` 使得 `k * a ≤ b`，然後取 `n = k + 1`
   - 這個最大的 `k` 對應於 `E` 的上確界

#### **第三部分：證明 E 非空**

5. **非空性證明**：
   - 需要找一個元素在 `E` 中
   - 因為 `a ≤ b`（從 `¬(b < a)` 得到）
   - 所以 `1 * a = a ≤ b`
   - 因此 `a ∈ E`，即 `E` 非空

6. **Lean 實現細節**：
   - `use (1 : ℝ) * a`：提供元素 `1 * a`
   - `use 1`：提供見證者 `k = 1`
   - `constructor`：分開證明合取的兩部分
   - `simp`：簡化 `1 * a = 1 * a` 和 `1 * a ≤ b`

#### **第四部分：證明 E 有上界**

7. **上界性證明**：
   - 聲稱 `b` 是 `E` 的上界
   - 對任意 `x ∈ E`，根據定義，`x = k * a` 且 `k * a ≤ b`
   - 因此 `x ≤ b`

8. **為什麼需要證明有上界？**
   - 為了應用完備性公設
   - 完備性公設要求集合非空且有上界

#### **第五部分：應用完備性公設**

9. **完備性公設的應用**：
   - 因為 `E` 非空且有上界
   - 根據完備性公設，`E` 有上確界
   - 使用 Lean 的 `sSup E` 函數得到上確界
   - 證明 `sSup E` 滿足上確界的兩個性質：
     - 是上界
     - 是最小上界

10. **Mathlib 與自定義定義的轉換**：
    - 教材中定義了自己的 `is_supremum` 和 `bounded_above`
    - Mathlib 有自己的 `BddAbove` 和 `sSup`
    - 需要在兩者之間轉換

#### **第六部分：證明 s ∈ E（最複雜的部分）**

11. **反證法設置**：
    - 假設 `s ∉ E`
    - 目標是推導出矛盾

12. **第一次應用定理 1.14**：
    - 取 `ε = a / 2`
    - 得到存在 `x ∈ E`，使得 `s - a/2 < x ≤ s`
    - 因為 `x ∈ E`，存在整數 `k` 使得 `x = k * a`

13. **證明 x < s**：
    - 如果 `x = s`，則 `s ∈ E`，與假設矛盾
    - 因此必須 `x < s`

14. **第二次應用定理 1.14**：
    - 取 `ε = s - x > 0`
    - 得到存在 `y ∈ E`，使得 `s - (s - x) < y ≤ s`
    - 即 `x < y ≤ s`
    - 因為 `y ∈ E`，存在整數 `m` 使得 `y = m * a`

15. **推導自然數的大小關係**：
    - 從 `k * a < m * a` 得到 `k < m`（因為 `a > 0`）
    - 作為自然數，`k < m` 意味著 `m ≥ k + 1`

16. **證明 (k+1) * a ∈ E**：
    - 需要證明 `(k+1) * a ≤ b`
    - 從 `m ≥ k + 1` 得到 `(k+1) * a ≤ m * a`
    - 從 `m * a ≤ b`（因為 `m * a ∈ E`）
    - 由傳遞性得到 `(k+1) * a ≤ b`

17. **推導矛盾**：
    - 一方面：`(k+1) * a = k * a + a = x + a > s`（因為 `s - x < a/2 < a`）
    - 另一方面：`(k+1) * a ≤ s`（因為 `s` 是上界，且 `(k+1) * a ∈ E`）
    - 這導致 `s < (k+1) * a ≤ s`，矛盾

#### **第七部分：完成主證明**

18. **從 s ∈ E 提取信息**：
    - 因為 `s ∈ E`，存在自然數 `k` 使得 `s = k * a` 且 `k * a ≤ b`

19. **取 n = k + 1**：
    - 目標是證明 `b < (k+1) * a`

20. **情況分析**：
    - **情況 1**：如果 `(k+1) * a ≤ b`
      - 則 `(k+1) * a ∈ E`
      - 但 `(k+1) * a = k * a + a = s + a > s`（因為 `a > 0`）
      - 同時 `(k+1) * a ≤ s`（因為 `s` 是上界）
      - 導致 `s < s`，矛盾
    - **情況 2**：如果 `(k+1) * a > b`
      - 這正是我們要證明的

### 使用的定義和定理

#### **基本定義**

1. **集合成員關係**：
   - `x ∈ E` 表示 `x` 是集合 `E` 的元素
   - `Set.Nonempty E` 表示 `E` 非空

2. **上界和上確界**：
   - `is_upper_bound M E`：`M` 是 `E` 的上界
   - `bounded_above E`：`E` 有上界
   - `is_supremum s E`：`s` 是 `E` 的上確界

3. **自然數轉換**：
   - `(k : ℝ)`：將自然數 `k` 轉換為實數
   - `Nat.cast_le`：保序性質

#### **關鍵定理**

1. **完備性公設**：
   - 非空且有上界的實數集合有上確界
   - 在 Lean 中通過 `sSup` 實現

2. **定理 1.14（上確界逼近性質）**：
   - 如果 `s = sup E` 且 `ε > 0`
   - 則存在 `x ∈ E` 使得 `s - ε < x ≤ s`

3. **不等式性質**：
   - `mul_le_mul_of_nonneg_right`：乘法保序
   - `sub_pos`：減法與正性的關係
   - `linarith`：線性算術自動證明

#### **邏輯策略**

1. **反證法**：
   - `by_contra h`：假設結論不成立

2. **情況分析**：
   - `by_cases h : P`：分 `P` 真和 `P` 假兩種情況

3. **存在性**：
   - `obtain ⟨x, hx⟩ := h`：從存在性命題中提取見證者

### 學習重點

#### **1. 完備性公設的重要性**

這個證明展示了完備性公設在實數理論中的核心作用：

- **為什麼需要完備性？**
  - 有理數集合沒有完備性（例如 \(\{x \in \mathbb{Q} : x^2 < 2\}\) 在有理數中沒有上確界）
  - 實數的完備性保證了「沒有間隙」
  - 阿基米德性質依賴於完備性

- **完備性的應用**：
  - 定義上確界 `s = sup E`
  - 保證 `s` 存在且唯一
  - 允許我們找到接近 `s` 的元素

#### **2. 定理 1.14 的關鍵作用**

定理 1.14（上確界逼近性質）在證明中被應用了兩次：

- **第一次應用**：
  - 找到第一個整數 `k`，使得 `s - a/2 < k * a ≤ s`
  - 這建立了 `s` 與整數倍數之間的聯繫

- **第二次應用**：
  - 找到第二個整數 `m`，使得 `k * a < m * a ≤ s`
  - 這建立了兩個連續整數之間的關係

- **為什麼選擇 ε = a/2？**
  - 保證 `(k+1) * a` 和 `k * a` 之間的差距小於 `a`
  - 這對於後續推導不等式至關重要

#### **3. 反證法的嵌套使用**

這個證明包含多層反證法：

- **外層反證法**：假設 `s ∉ E`
- **內層反證法**：
  - 在證明 `x < s` 時，假設 `x ≥ s`
  - 在證明 `m > k` 時，假設 `m ≤ k`

每個反證法都通過推導出邏輯矛盾來證明原命題。

#### **4. 整數與實數的轉換**

- **類型轉換**：
  - `(k : ℝ)`：將自然數轉換為實數
  - 需要保證運算的正確性

- **保序性**：
  - `Nat.cast_le`：`k ≤ m` 當且僅當 `(k : ℝ) ≤ (m : ℝ)`
  - 這保證了不等式在轉換後仍然成立

#### **5. 不等式鏈的構造**

證明中使用了多個複雜的不等式鏈：

- **關鍵不等式**：
  - `s - a/2 < k * a < m * a ≤ s`
  - `(k+1) * a ≤ m * a ≤ b`
  - `k * a < (k+1) * a ≤ s`

- **linarith 的使用**：
  - 自動處理線性不等式
  - 大大簡化了證明

#### **6. 構造性與非構造性證明**

這個證明是**非構造性的**：

- 我們沒有給出明確的 `n` 的計算公式
- 證明只說明 `n` 存在，但沒有告訴我們如何計算 `n`
- 這是使用完備性公設的必然結果

對比**構造性證明**：
- 可以給出 `n = ⌈b/a⌉ + 1`（向上取整）
- 但這需要證明向上取整函數的性質
- 教材選擇使用完備性公設，展示了更深層的理論結構

### 為什麼這個定理重要？

#### **1. 理論重要性**

阿基米德性質是實數系統的基本性質之一：

- **無窮性**：
  - 保證自然數集合在實數中是無界的
  - 沒有「最大的實數」

- **稠密性的基礎**：
  - 阿基米德性質是證明有理數稠密性的基礎
  - 對任意實數 `x < y`，存在有理數 `q` 使得 `x < q < y`

- **極限理論**：
  - 是定義極限、連續性的基礎
  - 例如：`1/n → 0` 當 `n → ∞`

#### **2. 實際應用**

- **逼近理論**：
  - 可以用有理數任意逼近無理數
  - 這是數值計算的理論基礎

- **測量理論**：
  - 任意大的量都可以用有限個單位測量
  - 這是物理測量的數學基礎

- **算法設計**：
  - 保證迭代算法的收斂性
  - 例如二分法、牛頓法等

#### **3. 歷史意義**

- **古希臘數學**：
  - 阿基米德（Archimedes）首先明確陳述了這個性質
  - 是歐幾里得《幾何原本》的公設之一

- **實數理論的發展**：
  - 19 世紀數學家（戴德金、康托等）在構造實數理論時
  - 明確將阿基米德性質作為實數的基本性質

### 常見誤區與注意事項

#### **誤區 1：認為定理顯而易見**

- **為什麼看起來顯然？**
  - 直覺上，我們可以一直加 `a`，最終會超過 `b`
  - 但這需要嚴格證明

- **為什麼需要證明？**
  - 並非所有有序域都滿足阿基米德性質
  - 例如：超實數（hyperreal numbers）不滿足
  - 需要從實數的基本公設推導出來

#### **誤區 2：忽略完備性公設的作用**

- **為什麼不能用歸納法？**
  - 歸納法只對有限次成立
  - 我們不知道需要加多少次 `a`
  - 完備性公設提供了「跳過無限步驟」的工具

#### **誤區 3：混淆構造性和存在性**

- **存在性證明**：
  - 證明 `n` 存在，但不給出具體的 `n`
  - 這是這個證明的做法

- **構造性證明**：
  - 給出明確的 `n` 的計算方法
  - 例如 `n = ⌈b/a⌉ + 1`
  - 兩種證明方法都是有效的

### 相關練習

#### **基礎練習**

1. **應用阿基米德性質**：
   - 證明：對任意實數 `x > 0`，存在自然數 `n` 使得 `0 < 1/n < x`
   - 提示：對 `a = x` 和 `b = 1` 應用定理 1.16

2. **有理數的稠密性**：
   - 證明：對任意實數 `x < y`，存在有理數 `q` 使得 `x < q < y`
   - 提示：使用阿基米德性質找到合適的分母

3. **整數部分的存在性**：
   - 證明：對任意實數 `x`，存在唯一的整數 `n` 使得 `n ≤ x < n + 1`
   - 這個整數稱為 `x` 的**整數部分**，記作 `⌊x⌋`

#### **進階練習**

4. **無理數的存在性**：
   - 使用阿基米德性質證明：\(\sqrt{2}\) 是無理數
   - 提示：假設 \(\sqrt{2} = p/q\)（既約分數），推導矛盾

5. **序列的極限**：
   - 證明：如果序列 \(a_n = 1/n\)，則對任意 \(\varepsilon > 0\)，存在 \(N\) 使得當 \(n > N\) 時，\(|a_n| < \varepsilon\)
   - 這是證明 \(\lim_{n \to \infty} 1/n = 0\) 的基礎

6. **上確界的性質**：
   - 證明：如果 \(E \subseteq \mathbb{R}\) 有上確界 \(s\)，則對任意 \(n \in \mathbb{N}\)，存在 \(x \in E\) 使得 \(s - 1/n < x \leq s\)
   - 這是定理 1.14 的一個特殊情況

#### **挑戰練習**

7. **阿基米德性質的等價形式**：
   - 證明以下命題等價：
     - (a) 阿基米德性質：對任意 \(a > 0\) 和 \(b\)，存在 \(n \in \mathbb{N}\) 使得 \(b < n \cdot a\)
     - (b) 對任意 \(x > 0\)，存在 \(n \in \mathbb{N}\) 使得 \(0 < 1/n < x\)
     - (c) \(\mathbb{N}\) 在 \(\mathbb{R}\) 中無上界

8. **非阿基米德有序域**：
   - 研究超實數（hyperreal numbers）：一個包含無窮小和無窮大的有序域
   - 理解為什麼超實數不滿足阿基米德性質
   - 這是非標準分析（non-standard analysis）的基礎

9. **完備性與阿基米德性質**：
   - 證明：有理數集合滿足阿基米德性質，但不滿足完備性
   - 理解這兩個性質的區別
   - 思考：為什麼實數既需要完備性又需要阿基米德性質？

### 延伸閱讀

1. **實數理論**：
   - Rudin, W. (1976). *Principles of Mathematical Analysis*. Chapter 1.
   - 戴德金分割（Dedekind cuts）和柯西序列（Cauchy sequences）的構造

2. **公理化方法**：
   - Tao, T. (2016). *Analysis I*. Chapter 5.
   - 從佩亞諾公設（Peano axioms）構造自然數、整數、有理數和實數

3. **非標準分析**：
   - Robinson, A. (1996). *Non-standard Analysis*.
   - 超實數的構造和應用

### 總結

定理 1.16（阿基米德性質）是實數理論的基石之一。這個證明展示了：

1. **完備性公設的威力**：
   - 通過定義集合 \(E\) 和應用完備性公設
   - 我們能夠處理看似簡單但實際上深刻的問題

2. **反證法的應用**：
   - 嵌套的反證法幫助我們推導出關鍵的矛盾
   - 這是處理存在性命題的有力工具

3. **定理的組合使用**：
   - 定理 1.14（上確界逼近性質）被應用兩次
   - 展示了如何將簡單的定理組合成複雜的證明

4. **理論與直覺的結合**：
   - 雖然結果直觀，但證明需要嚴格的邏輯推理
   - 這體現了數學證明的必要性

這個定理及其證明方法將在後續的分析學習中反覆出現，是理解極限、連續性、微積分的重要基礎。

---

## 定理 1.18：有理數的稠密性（Density of Rationals）

### 問題陳述

**定理 1.18（有理數稠密性）**：若 \(a, b \in \mathbb{R}\) 滿足 \(a < b\)，則存在有理數 \(q \in \mathbb{Q}\)，使得
\[
a < q < b
\]

**說明**：這個定理說明，在任意兩個不相等的實數之間，總能找到一個有理數。換句話說，有理數在實數中是「稠密的」（dense）。

**幾何直觀**：想像數線上任意兩個點 \(a\) 和 \(b\)，無論它們靠得多近，中間總能找到一個有理數點。這意味著有理數在實數軸上「到處都是」。

**重要性**：
- 這是實數理論的基本性質之一
- 說明了有理數雖然是可數集，但在實數中「無處不在」
- 是有理數逼近實數的理論基礎
- 在數值分析和計算中有重要應用

### 證明策略

這個證明巧妙地結合了阿基米德性質（定理 1.16）和整數的 floor 函數。主要思路如下：

#### **核心想法**

要在 \(a\) 和 \(b\) 之間找一個有理數 \(q = \frac{m}{n}\)，其中 \(m \in \mathbb{Z}\)，\(n \in \mathbb{N}\)。

**策略**：
1. 先用阿基米德性質找一個足夠大的 \(n\)，使得 \(\frac{1}{n} < b - a\)
2. 再找一個整數 \(m\)，使得 \(n \cdot a < m \leq n \cdot a + 1\)
3. 那麼 \(q = \frac{m}{n}\) 就會落在 \((a, b)\) 之間

#### **詳細步驟**

**第一步：證明區間長度為正**
- 從 \(a < b\) 得到 \(0 < b - a\)

**第二步：應用阿基米德性質找合適的 \(n\)**
- 應用定理 1.16 於 \(b - a\) 和 \(1\)：存在 \(n \in \mathbb{N}\) 使得 \(1 < n \cdot (b - a)\)
- 證明 \(n > 0\)（用反證法）

**第三步：推導 \(\frac{1}{n} < b - a\)**
- 從 \(1 < n \cdot (b - a)\) 和 \(n > 0\) 推出
- 這保證了 \(a + \frac{1}{n} < b\)

**第四步：構造整數 \(m\)**
- 定義 \(m := \lfloor n \cdot a \rfloor + 1\)（大於 \(n \cdot a\) 的最小整數）
- 證明 \(n \cdot a < m\)（floor 函數的性質）
- 證明 \(m \leq n \cdot a + 1\)（floor 函數的性質）

**第五步：構造有理數 \(q = \frac{m}{n}\)**
- 定義 \(q := \frac{m}{n} \in \mathbb{Q}\)

**第六步：證明 \(a < q\)**
- 從 \(n \cdot a < m\) 得到 \(a = \frac{n \cdot a}{n} < \frac{m}{n} = q\)

**第七步：證明 \(q < b\)**
- 從 \(m \leq n \cdot a + 1\) 得到：
  \[
  q = \frac{m}{n} \leq \frac{n \cdot a + 1}{n} = a + \frac{1}{n} < a + (b - a) = b
  \]

### Lean 4 完整證明（帶詳細註解）

```lean
-- Theorem 1.18 : If a, b ∈ ℝ satisfy a < b, then there is a q ∈ ℚ ∋ a < q < b.
theorem Theorem_1_18 (a b : ℝ) (hab : a < b) : ∃ q : ℚ, a < q ∧ q < b := by  -- 定理 1.18：有理數稠密性，給定 a < b，存在有理數 q 使得 a < q < b
   have h_pos : 0 < b - a := sub_pos.mpr hab  -- 由 a < b 得到 0 < b - a
   have h_arch1 : ∃ n : ℕ, (1 : ℝ) < n * (b - a) := Theorem_1_16 (b - a) 1 h_pos  -- 由阿基米德性質得到存在自然數 n 使得 1 < n * (b - a)
   obtain ⟨n, hn_gt⟩ := h_arch1  -- 取出這樣的 n，並記 hn_gt : 1 < n * (b - a)
   have hn_pos : (n : ℝ) > 0 := by  -- 證明 n > 0（反證法）
      by_contra h_neg  -- 假設 n 不大於 0
      push_neg at h_neg  -- 轉換為 n ≤ 0
      have hn_noneg : (n : ℝ) ≥ 0 := Nat.cast_nonneg n  -- 但自然數必定 ≥ 0
      have hn_zero : (n : ℝ) = 0 := le_antisymm h_neg hn_noneg  -- 所以 n = 0
      rw [hn_zero] at hn_gt  -- 代入得 1 < 0 * (b - a)
      simp at hn_gt  -- 化簡得 1 < 0
      norm_num at hn_gt  -- 這是矛盾，完成反證
   have h_inv : (1 : ℝ) / n < b - a := by  -- 證明 1/n < b - a
      have hn_ne : (n : ℝ) ≠ 0 := ne_of_gt hn_pos  -- n > 0 故 n ≠ 0
      suffices 1 < n * (b - a) by  -- 只需證明 1 < n * (b - a)（反向推理）
         calc (1 : ℝ) / n  -- 計算鏈證明 1/n < b - a
            _ = 1 / n * 1 := by ring  -- 1/n = (1/n) * 1
            _ < 1 / n * (n * (b - a)) := by  -- (1/n) * 1 < (1/n) * (n * (b - a))
               apply mul_lt_mul_of_pos_left this  -- 由 1 < n * (b - a) 和 1/n > 0 得證
               exact div_pos one_pos hn_pos  -- 確認 1/n > 0
            _ = b - a := by field_simp  -- (1/n) * n * (b - a) = b - a
      exact hn_gt  -- 而 1 < n * (b - a) 即為 hn_gt
   let m : ℤ := Int.floor (n * a) + 1  -- 定義 m 為大於 n*a 的最小整數：m = ⌊n*a⌋ + 1
   have hm_gt : (n : ℝ) * a < m := by  -- 證明 n * a < m
      calc (n : ℝ) * a  -- 計算鏈
        _ < ↑⌊n * a⌋ + 1 := Int.lt_floor_add_one (n * a)  -- n*a < ⌊n*a⌋ + 1（floor 的性質）
        _ = ↑(⌊n * a⌋ + 1) := by norm_cast  -- 類型轉換：實數加法轉整數加法
        _ = ↑(Int.floor (n * a) + 1) := rfl  -- 即為 m 的定義
   have hm_le : (m : ℝ) ≤ (n : ℝ) * a + 1 := by  -- 證明 m ≤ n*a + 1
      calc (m : ℝ)  -- 計算鏈
        _ = ↑(Int.floor (n * a) + 1) := by rfl  -- m 的定義
        _ = ↑⌊n * a⌋ + 1 := by norm_cast  -- 類型轉換：整數加法轉實數加法
        _ ≤ (n * a) + 1 := by linarith [Int.floor_le (n * a)]  -- 因為 ⌊n*a⌋ ≤ n*a（floor 的性質）
   let q : ℚ := m / n  -- 構造有理數 q = m/n
   have hq_real : (q : ℝ) = (m : ℝ) / (n : ℝ) := by  -- 證明有理數 q 轉實數等於 m/n
      simp only [q, Rat.cast_div, Rat.cast_intCast, Rat.cast_natCast]  -- 展開有理數到實數的轉換
   use q  -- 使用 q 作為所求的有理數
   constructor  -- 需要證明 a < q 且 q < b 兩個目標
   -- 證明 a < q
   calc (a : ℝ)  -- 計算鏈證明 a < q（在實數域）
     _ = (n : ℝ) * a / n := by field_simp  -- a = (n*a) / n
     _ < (m : ℝ) / n := by exact div_lt_div_of_pos_right hm_gt hn_pos  -- (n*a)/n < m/n（因為 n*a < m 且 n > 0）
     _ = (q : ℝ) := hq_real.symm  -- m/n = q（在實數域）
   -- 證明 q < b
   calc (q : ℝ)  -- 計算鏈證明 q < b（在實數域）
     _ = (m : ℝ) / n := hq_real  -- q = m/n（在實數域）
     _ ≤ ((n : ℝ) * a + 1) / n := by exact div_le_div_of_nonneg_right hm_le (le_of_lt hn_pos)  -- m/n ≤ (n*a + 1)/n（因為 m ≤ n*a + 1 且 n > 0）
     _ = (n : ℝ) * a / n + 1 / n := by ring  -- (n*a + 1)/n = (n*a)/n + 1/n
     _ = a + 1 / n := by field_simp  -- (n*a)/n + 1/n = a + 1/n
     _ < a + (b - a) := by linarith [h_inv]  -- a + 1/n < a + (b - a)（因為 1/n < b - a）
     _ = (b : ℝ) := by ring  -- a + (b - a) = b
```

### 證明步驟詳解

#### 1. 準備工作（第 1397-1407 行）

**目標**：建立基本的不等式和找到合適的 \(n\)

```lean
have h_pos : 0 < b - a := sub_pos.mpr hab
```
- **作用**：從假設 \(a < b\) 推導出 \(0 < b - a\)
- **原理**：使用 `sub_pos` 定理：\(a < b \Leftrightarrow 0 < b - a\)

```lean
have h_arch1 : ∃ n : ℕ, (1 : ℝ) < n * (b - a) := Theorem_1_16 (b - a) 1 h_pos
```
- **作用**：應用阿基米德性質
- **輸入**：\(a = b - a > 0\)，\(b = 1\)
- **輸出**：存在 \(n \in \mathbb{N}\) 使得 \(1 < n \cdot (b - a)\)

```lean
obtain ⟨n, hn_gt⟩ := h_arch1
```
- **作用**：解構存在性命題，得到具體的 \(n\) 和證據 `hn_gt : 1 < n * (b - a)`

```lean
have hn_pos : (n : ℝ) > 0 := by
   by_contra h_neg
   push_neg at h_neg
   have hn_noneg : (n : ℝ) ≥ 0 := Nat.cast_nonneg n
   have hn_zero : (n : ℝ) = 0 := le_antisymm h_neg hn_noneg
   rw [hn_zero] at hn_gt
   simp at hn_gt
   norm_num at hn_gt
```
- **作用**：證明 \(n > 0\)
- **方法**：反證法
  1. 假設 \(n \leq 0\)
  2. 但 \(n\) 是自然數，所以 \(n \geq 0\)
  3. 因此 \(n = 0\)
  4. 代入 `hn_gt` 得 \(1 < 0\)，矛盾
- **技巧**：使用 `by_contra`、`push_neg`、`le_antisymm`、`norm_num`

#### 2. 證明 \(\frac{1}{n} < b - a\)（第 1408-1417 行）

```lean
have h_inv : (1 : ℝ) / n < b - a := by
   have hn_ne : (n : ℝ) ≠ 0 := ne_of_gt hn_pos
   suffices 1 < n * (b - a) by
      calc (1 : ℝ) / n
         _ = 1 / n * 1 := by ring
         _ < 1 / n * (n * (b - a)) := by
            apply mul_lt_mul_of_pos_left this
            exact div_pos one_pos hn_pos
         _ = b - a := by field_simp
   exact hn_gt
```
- **作用**：從 \(1 < n \cdot (b - a)\) 推導 \(\frac{1}{n} < b - a\)
- **方法**：
  1. 用 `suffices` 反向推理：只需證明 \(1 < n \cdot (b - a)\)
  2. 計算鏈：
     - \(\frac{1}{n} = \frac{1}{n} \cdot 1\)
     - \(\frac{1}{n} \cdot 1 < \frac{1}{n} \cdot (n \cdot (b - a))\)（因為 \(1 < n \cdot (b - a)\) 且 \(\frac{1}{n} > 0\)）
     - \(\frac{1}{n} \cdot n \cdot (b - a) = b - a\)（用 `field_simp` 約分）
  3. 而 \(1 < n \cdot (b - a)\) 正是 `hn_gt`
- **技巧**：`suffices`（反向推理）、`mul_lt_mul_of_pos_left`（正數乘不等式）、`field_simp`（域簡化）

#### 3. 構造整數 \(m\)（第 1418-1428 行）

```lean
let m : ℤ := Int.floor (n * a) + 1
```
- **作用**：定義 \(m\) 為大於 \(n \cdot a\) 的最小整數
- **公式**：\(m = \lfloor n \cdot a \rfloor + 1\)
- **性質**：
  - \(n \cdot a < m\)（因為 \(n \cdot a \leq \lfloor n \cdot a \rfloor < \lfloor n \cdot a \rfloor + 1\)）
  - \(m \leq n \cdot a + 1\)（因為 \(\lfloor n \cdot a \rfloor \leq n \cdot a\)）

```lean
have hm_gt : (n : ℝ) * a < m := by
   calc (n : ℝ) * a
     _ < ↑⌊n * a⌋ + 1 := Int.lt_floor_add_one (n * a)
     _ = ↑(⌊n * a⌋ + 1) := by norm_cast
     _ = ↑(Int.floor (n * a) + 1) := rfl
```
- **作用**：證明 \(n \cdot a < m\)
- **方法**：
  1. 使用 `Int.lt_floor_add_one`：對任意實數 \(x\)，\(x < \lfloor x \rfloor + 1\)
  2. 用 `norm_cast` 處理類型轉換：\(\uparrow(\lfloor n \cdot a \rfloor + 1)\)（整數加法）= \(\uparrow\lfloor n \cdot a \rfloor + 1\)（實數加法）
  3. 用 `rfl` 確認這就是 \(m\) 的定義
- **技巧**：`Int.lt_floor_add_one`、`norm_cast`（類型轉換標準化）

```lean
have hm_le : (m : ℝ) ≤ (n : ℝ) * a + 1 := by
   calc (m : ℝ)
     _ = ↑(Int.floor (n * a) + 1) := by rfl
     _ = ↑⌊n * a⌋ + 1 := by norm_cast
     _ ≤ (n * a) + 1 := by linarith [Int.floor_le (n * a)]
```
- **作用**：證明 \(m \leq n \cdot a + 1\)
- **方法**：
  1. 展開 \(m\) 的定義
  2. 用 `norm_cast` 處理類型轉換
  3. 使用 `Int.floor_le`：對任意實數 \(x\)，\(\lfloor x \rfloor \leq x\)
  4. 用 `linarith` 完成線性不等式推理
- **技巧**：`Int.floor_le`、`linarith`

#### 4. 構造有理數並證明（第 1429-1446 行）

```lean
let q : ℚ := m / n
have hq_real : (q : ℝ) = (m : ℝ) / (n : ℝ) := by
   simp only [q, Rat.cast_div, Rat.cast_intCast, Rat.cast_natCast]
```
- **作用**：構造有理數 \(q = \frac{m}{n}\) 並證明其轉實數的性質
- **技巧**：
  - `let` 定義局部變量
  - `simp only` 展開有理數到實數的轉換規則
  - 處理 \(\mathbb{Z} \to \mathbb{Q} \to \mathbb{R}\) 和 \(\mathbb{N} \to \mathbb{Q} \to \mathbb{R}\) 的類型轉換

```lean
use q
constructor
```
- **作用**：使用 \(q\) 作為存在性命題的見證，並開始證明合取 \(a < q \land q < b\)
- **效果**：產生兩個子目標：
  1. 證明 \(a < q\)
  2. 證明 \(q < b\)

**證明 \(a < q\)**（第 1435-1438 行）：
```lean
calc (a : ℝ)
  _ = (n : ℝ) * a / n := by field_simp
  _ < (m : ℝ) / n := by exact div_lt_div_of_pos_right hm_gt hn_pos
  _ = (q : ℝ) := hq_real.symm
```
- **邏輯**：
  1. \(a = \frac{n \cdot a}{n}\)（用 `field_simp` 自動處理）
  2. \(\frac{n \cdot a}{n} < \frac{m}{n}\)（因為 \(n \cdot a < m\) 且 \(n > 0\)，用 `div_lt_div_of_pos_right`）
  3. \(\frac{m}{n} = q\)（在實數域，用 `hq_real.symm`）
- **技巧**：
  - `field_simp`：自動處理域上的等式
  - `div_lt_div_of_pos_right`：若 \(a < b\) 且 \(c > 0\)，則 \(\frac{a}{c} < \frac{b}{c}\)

**證明 \(q < b\)**（第 1440-1446 行）：
```lean
calc (q : ℝ)
  _ = (m : ℝ) / n := hq_real
  _ ≤ ((n : ℝ) * a + 1) / n := by exact div_le_div_of_nonneg_right hm_le (le_of_lt hn_pos)
  _ = (n : ℝ) * a / n + 1 / n := by ring
  _ = a + 1 / n := by field_simp
  _ < a + (b - a) := by linarith [h_inv]
  _ = (b : ℝ) := by ring
```
- **邏輯**：
  1. \(q = \frac{m}{n}\)（在實數域）
  2. \(\frac{m}{n} \leq \frac{n \cdot a + 1}{n}\)（因為 \(m \leq n \cdot a + 1\) 且 \(n > 0\)）
  3. \(\frac{n \cdot a + 1}{n} = \frac{n \cdot a}{n} + \frac{1}{n}\)（分配律）
  4. \(\frac{n \cdot a}{n} + \frac{1}{n} = a + \frac{1}{n}\)（約分）
  5. \(a + \frac{1}{n} < a + (b - a)\)（因為 \(\frac{1}{n} < b - a\)，即 `h_inv`）
  6. \(a + (b - a) = b\)（代數）
- **技巧**：
  - `div_le_div_of_nonneg_right`：若 \(a \leq b\) 且 \(c \geq 0\)，則 \(\frac{a}{c} \leq \frac{b}{c}\)
  - `ring`：多項式環上的等式自動化
  - `linarith`：線性算術自動化
  - `le_of_lt`：從 \(a < b\) 得到 \(a \leq b\)

### 使用的定理和策略

#### **Mathlib 定理**
1. **`sub_pos`**：\(a < b \Leftrightarrow 0 < b - a\)
2. **`Nat.cast_nonneg`**：自然數轉實數後非負
3. **`le_antisymm`**：若 \(a \leq b\) 且 \(b \leq a\)，則 \(a = b\)
4. **`ne_of_gt`**：若 \(a > b\)，則 \(a \neq b\)
5. **`div_pos`**：若 \(a > 0\) 且 \(b > 0\)，則 \(\frac{a}{b} > 0\)
6. **`mul_lt_mul_of_pos_left`**：若 \(a < b\) 且 \(c > 0\)，則 \(c \cdot a < c \cdot b\)
7. **`div_lt_div_of_pos_right`**：若 \(a < b\) 且 \(c > 0\)，則 \(\frac{a}{c} < \frac{b}{c}\)
8. **`div_le_div_of_nonneg_right`**：若 \(a \leq b\) 且 \(c \geq 0\)，則 \(\frac{a}{c} \leq \frac{b}{c}\)
9. **`Int.floor_le`**：\(\lfloor x \rfloor \leq x\)
10. **`Int.lt_floor_add_one`**：\(x < \lfloor x \rfloor + 1\)
11. **`Rat.cast_div`**、**`Rat.cast_intCast`**、**`Rat.cast_natCast`**：有理數類型轉換

#### **自定義定理**
1. **`Theorem_1_16`**：阿基米德性質

#### **證明策略（Tactics）**
1. **`by_contra`**：反證法
2. **`push_neg`**：否定推入
3. **`suffices`**：反向推理
4. **`calc`**：計算鏈（等式/不等式推導）
5. **`obtain`**：解構存在性命題
6. **`let`**：定義局部變量
7. **`constructor`**：證明合取
8. **`use`**：提供存在性見證
9. **`ring`**：多項式環自動化
10. **`field_simp`**：域簡化
11. **`linarith`**：線性算術自動化
12. **`norm_cast`**：類型轉換標準化
13. **`simp`**：化簡
14. **`norm_num`**：數值化簡
15. **`exact`**：精確匹配
16. **`apply`**：應用定理
17. **`rfl`**：反射性（定義相等）
18. **`rw`**：改寫

### 關鍵技術點

#### 1. **類型轉換處理**
這個證明涉及多種數值類型的轉換：
- \(\mathbb{N} \to \mathbb{R}\)：自然數到實數
- \(\mathbb{Z} \to \mathbb{R}\)：整數到實數
- \(\mathbb{Z} \to \mathbb{Q}\)：整數到有理數
- \(\mathbb{Q} \to \mathbb{R}\)：有理數到實數

使用的工具：
- `norm_cast`：標準化類型轉換，處理 \(\uparrow(a + b)\) vs \(\uparrow a + \uparrow b\) 的問題
- `simp only [Rat.cast_*]`：展開有理數轉換規則
- `rfl`：當轉換是定義性相等時

#### 2. **Floor 函數的使用**
Floor 函數 \(\lfloor x \rfloor\) 的關鍵性質：
- \(\lfloor x \rfloor \leq x < \lfloor x \rfloor + 1\)
- \(\lfloor x \rfloor\) 是不超過 \(x\) 的最大整數

在證明中的作用：
- 構造 \(m = \lfloor n \cdot a \rfloor + 1\) 確保 \(m\) 是大於 \(n \cdot a\) 的**最小**整數
- 這保證了 \(m \leq n \cdot a + 1\)，從而 \(\frac{m}{n} \leq a + \frac{1}{n}\)

#### 3. **反向推理（Suffices）**
在證明 \(\frac{1}{n} < b - a\) 時使用：
```lean
suffices 1 < n * (b - a) by
   calc (1 : ℝ) / n
      ...
      _ = b - a := by field_simp
```
- **作用**：將目標 \(\frac{1}{n} < b - a\) 轉換為更簡單的 \(1 < n \cdot (b - a)\)
- **優勢**：後者正是我們已有的 `hn_gt`，直接使用即可

#### 4. **計算鏈（Calc）的有效使用**
證明中大量使用 `calc` 來構建清晰的推理鏈：
```lean
calc (a : ℝ)
  _ = (n : ℝ) * a / n := by field_simp
  _ < (m : ℝ) / n := by exact div_lt_div_of_pos_right hm_gt hn_pos
  _ = (q : ℝ) := hq_real.symm
```
- **優勢**：
  - 每一步都清晰可見
  - 容易檢查和除錯
  - 符合數學證明的書寫習慣

### 學習要點

1. **有理數的構造性**
   - 證明不僅說明有理數存在，還明確構造出 \(q = \frac{m}{n}\)
   - \(m = \lfloor n \cdot a \rfloor + 1\)，\(n\) 來自阿基米德性質

2. **阿基米德性質的應用**
   - 阿基米德性質不僅用於處理「很大」的數
   - 也可用於處理「很小」的數：\(\frac{1}{n}\) 可以任意小

3. **Floor 函數的重要性**
   - Floor 函數提供了從實數到整數的橋樑
   - 在分析中經常用於構造性證明

4. **類型系統的嚴謹性**
   - Lean 的類型系統要求明確處理不同數系之間的轉換
   - 雖然繁瑣，但保證了證明的正確性

5. **多個定理的組合使用**
   - 這個證明展示了如何將阿基米德性質、floor 函數性質、不等式運算等組合起來
   - 體現了數學證明的模組化思維

### 常見錯誤和陷阱

1. **類型轉換錯誤**
   - ❌ 直接使用 `(m : ℚ) / n`，忽略類型轉換問題
   - ✅ 使用 `let q : ℚ := m / n` 然後證明 `(q : ℝ) = (m : ℝ) / (n : ℝ)`

2. **忘記證明 \(n > 0\)**
   - ❌ 假設阿基米德性質給出的 \(n\) 自動是正數
   - ✅ 明確證明 \(n > 0\)（雖然從 \(1 < n \cdot (b - a)\) 可以看出，但需要形式化證明）

3. **Floor 函數的不等式方向**
   - ❌ \(n \cdot a \leq \lfloor n \cdot a \rfloor\)（錯誤！）
   - ✅ \(\lfloor n \cdot a \rfloor \leq n \cdot a < \lfloor n \cdot a \rfloor + 1\)

4. **忽略嚴格不等式和非嚴格不等式的區別**
   - 在證明 \(q < b\) 時，關鍵使用了 \(\frac{1}{n} < b - a\)（嚴格不等式）
   - 即使 \(m \leq n \cdot a + 1\)（非嚴格），最終仍能得到 \(q < b\)（嚴格）

### 推廣和相關定理

1. **無理數的稠密性**
   - 定理：在任意兩個不相等的實數之間也存在無理數
   - 證明策略：找一個有理數 \(q \in (a, b)\)，然後找一個無理數（如 \(q + \frac{\sqrt{2}}{n}\)）

2. **代數數的稠密性**
   - 代數數在實數中也是稠密的
   - 但超越數雖然「更多」，卻也是稠密的

3. **度量空間中的稠密性**
   - 稠密性的概念推廣到一般度量空間
   - 集合 \(A\) 在 \(X\) 中稠密 ⟺ \(\overline{A} = X\)

4. **有理數逼近定理**
   - Dirichlet 逼近定理：對任意無理數 \(\alpha\)，存在無窮多個有理數 \(\frac{p}{q}\) 使得 \(|\alpha - \frac{p}{q}| < \frac{1}{q^2}\)

### 應用實例

1. **數值計算**
   - 計算機使用有理數（或浮點數）來逼近實數
   - 稠密性保證了這種逼近的理論基礎

2. **連續函數的延拓**
   - 若 \(f : \mathbb{Q} \to \mathbb{R}\) 連續且一致連續，可唯一延拓到 \(f : \mathbb{R} \to \mathbb{R}\)

3. **積分理論**
   - Riemann 積分中，使用有理點來構造分割

4. **實數的構造**
   - Dedekind 分割和 Cauchy 序列兩種構造方式都依賴有理數的性質

### 練習題

1. **基礎練習**：證明若 \(a < b\)，則存在有理數 \(q_1, q_2\) 使得 \(a < q_1 < q_2 < b\)（提示：使用兩次定理 1.18）

2. **進階練習**：證明若 \(a < b\)，則存在無理數 \(r\) 使得 \(a < r < b\)（提示：先找有理數 \(q \in (a, b)\)，再考慮 \(q + \frac{\sqrt{2}}{n}\)）

3. **挑戰練習**：證明對任意 \(\varepsilon > 0\) 和實數 \(x\)，存在有理數 \(q\) 使得 \(|x - q| < \varepsilon\)

4. **Lean 練習**：嘗試將證明改寫為使用 `Int.ceil` 而不是 `Int.floor`

### 延伸閱讀

1. **實數的完備性**
   - 有理數的稠密性 vs 實數的完備性
   - 有理數在實數中稠密，但有理數本身不完備

2. **拓撲學觀點**
   - 稠密子集的拓撲定義
   - 可分空間：具有可數稠密子集的空間

3. **測度論觀點**
   - 雖然有理數稠密，但測度為 0
   - 「大小」和「稠密性」的區別

4. **構造主義數學**
   - 這個證明是構造性的（給出了明確的 \(q\)）
   - 在直覺主義邏輯中也成立

---

這個定理是實數理論的基石之一，與阿基米德性質一起，構成了理解實數系統的關鍵。掌握這個證明，不僅能提升形式化證明能力，也能加深對實數結構的理解。

---

## 定義 1.19：下界、下確界與有界（Lower Bound, Infimum, and Bounded）

### 定義陳述

設 \(E \subset \mathbb{R}\) 為非空集合。

#### **i) 下界與有下界（Lower Bound and Bounded Below）**

集合 \(E\) 稱為**有下界**（bounded below），若且唯若存在 \(m \in \mathbb{R}\) 使得對所有 \(a \in E\)，有 \(a \geq m\)。此時稱 \(m\) 為集合 \(E\) 的一個**下界**（lower bound）。

**數學表述**：
\[
\text{is\_lower\_bound}(m, E) :\Leftrightarrow \forall a \in E, m \leq a
\]
\[
\text{bounded\_below}(E) :\Leftrightarrow \exists m \in \mathbb{R}, \text{is\_lower\_bound}(m, E)
\]

#### **ii) 下確界（Infimum / Greatest Lower Bound）**

數 \(t\) 稱為集合 \(E\) 的**下確界**（infimum），若且唯若：
1. \(t\) 是 \(E\) 的下界
2. 對所有 \(E\) 的下界 \(m\)，有 \(t > m\)

此時我們說 \(E\) **有下確界** \(t\)，記作 \(t = \inf E\)。

**數學表述**：
\[
\text{is\_infimum}(t, E) :\Leftrightarrow \text{is\_lower\_bound}(t, E) \land \forall m \in \mathbb{R}, (\text{is\_lower\_bound}(m, E) \Rightarrow m \leq t)
\]

**說明**：下確界是**最大的下界**，與上確界（最小的上界）對偶。

#### **iii) 有界（Bounded）**

集合 \(E\) 稱為**有界**（bounded），若且唯若 \(E\) 既有上界又有下界。

**數學表述**：
\[
\text{bounded}(E) :\Leftrightarrow \text{bounded\_above}(E) \land \text{bounded\_below}(E)
\]

### Lean 4 形式化定義

```lean
-- Definition 1.19 : Bounded below, infimum, and bounded
-- 定義 1.19：下界、下確界和有界

-- i) Lower bound and bounded below
-- 下界：若 m ≤ a 對所有 a ∈ E 成立，則 m 是 E 的下界
def is_lower_bound (m : ℝ) (E : Set ℝ) : Prop :=
  ∀ a ∈ E, m ≤ a

-- 有下界：存在下界
def bounded_below (E : Set ℝ) : Prop :=
  ∃ m : ℝ, is_lower_bound m E

-- ii) Infimum (greatest lower bound)
-- 下確界：t 是下界，且 t 大於所有其他下界
def is_infimum (t : ℝ) (E : Set ℝ) : Prop :=
  is_lower_bound t E ∧ ∀ m : ℝ, is_lower_bound m E → m ≤ t

-- iii) Bounded (both above and below)
-- 有界：既有上界又有下界
def bounded (E : Set ℝ) : Prop :=
  bounded_above E ∧ bounded_below E
```

### 概念解析

#### 1. **上界與下界的對偶性**

定義 1.19 與定義 1.13（上界、上確界）形成完美的對偶關係：

| 概念 | 上界版本 | 下界版本 |
|------|----------|----------|
| **界** | \(M\) 是上界 ⟺ \(\forall a \in E, a \leq M\) | \(m\) 是下界 ⟺ \(\forall a \in E, m \leq a\) |
| **有界** | \(E\) 有上界 ⟺ \(\exists M, \forall a \in E, a \leq M\) | \(E\) 有下界 ⟺ \(\exists m, \forall a \in E, m \leq a\) |
| **確界** | \(s = \sup E\) ⟺ 最小的上界 | \(t = \inf E\) ⟺ 最大的下界 |
| **特徵** | \(s \leq M\) 對所有上界 \(M\) | \(m \leq t\) 對所有下界 \(m\) |

**視覺化**：
```
        上界們
    ──────────────
    M₃  M₂  M₁  s = sup E  ← 最小的上界（上確界）
    ──────────────
         E
    ──────────────
    t = inf E  m₁  m₂  m₃  ← 最大的下界（下確界）
    ──────────────
        下界們
```

#### 2. **下確界的等價刻畫**

下確界 \(t = \inf E\) 等價於以下兩個條件：

**條件 1**（下界性）：
\[
\forall a \in E, t \leq a
\]

**條件 2**（最大性）：
\[
\forall \varepsilon > 0, \exists a \in E, a < t + \varepsilon
\]

**解釋**：
- 條件 1 說明 \(t\) 是下界
- 條件 2 說明沒有比 \(t\) 更大的下界（對偶於上確界的逼近性質）

#### 3. **有界集合的性質**

若 \(E\) 有界，則：
1. **存在包含區間**：存在 \(m, M \in \mathbb{R}\) 使得 \(E \subseteq [m, M]\)
2. **直徑有限**：\(\text{diam}(E) = \sup\{|x - y| : x, y \in E\} < \infty\)
3. **有界序列**：若 \(\{x_n\}\) 是 \(E\) 中的序列，則 \(\{x_n\}\) 有界

### 實例與反例

#### **實例 1：開區間 \((0, 1)\)**
- **上界**：任何 \(M \geq 1\)，例如 \(1, 2, 100\)
- **上確界**：\(\sup(0, 1) = 1\)（最小的上界）
- **下界**：任何 \(m \leq 0\)，例如 \(0, -1, -100\)
- **下確界**：\(\inf(0, 1) = 0\)（最大的下界）
- **有界**：是，因為 \((0, 1) \subseteq [0, 1]\)
- **注意**：上確界和下確界都**不在**集合內

#### **實例 2：閉區間 \([0, 1]\)**
- **上確界**：\(\sup[0, 1] = 1 \in [0, 1]\)
- **下確界**：\(\inf[0, 1] = 0 \in [0, 1]\)
- **有界**：是
- **注意**：上確界和下確界都**在**集合內（稱為最大元和最小元）

#### **實例 3：自然數集 \(\mathbb{N} = \{1, 2, 3, \ldots\}\)**
- **上界**：無（無上界）
- **上確界**：不存在
- **下界**：任何 \(m \leq 1\)
- **下確界**：\(\inf \mathbb{N} = 1 \in \mathbb{N}\)
- **有界**：否（只有下界，沒有上界）

#### **實例 4：倒數序列 \(\{\frac{1}{n} : n \in \mathbb{N}\}\)**
- **上界**：任何 \(M \geq 1\)
- **上確界**：\(\sup = 1\)
- **下界**：任何 \(m \leq 0\)
- **下確界**：\(\inf = 0\)（不在集合內）
- **有界**：是

#### **反例 1：無下界集合 \(\mathbb{Z}\)**（所有整數）
- 既無上界也無下界
- 不是有界集合

#### **反例 2：\(E = \{-n : n \in \mathbb{N}\}\)**（負整數）
- **上界**：任何 \(M \geq -1\)
- **上確界**：\(\sup E = -1\)
- **下界**：無
- **有界**：否

### 重要定理

#### **定理（實數完備性的下確界版本）**

若非空集合 \(E \subset \mathbb{R}\) 有下界，則 \(E\) 有下確界。

**證明思路**：
1. 設 \(F = \{-a : a \in E\}\)（\(E\) 中所有元素取負號）
2. \(E\) 有下界 \(m\) ⟺ \(F\) 有上界 \(-m\)
3. 由完備性公設，\(F\) 有上確界 \(s = \sup F\)
4. 證明 \(t = -s\) 是 \(E\) 的下確界

**結論**：完備性公設的上確界版本和下確界版本是等價的。

### 在 Lean 中的應用

#### **定理：區間有界**

```lean
-- 閉區間 [a, b] 有界
theorem interval_bounded (a b : ℝ) (hab : a ≤ b) : 
  bounded (Set.Icc a b) := by
  constructor
  -- 證明有上界
  · use b
    intro x hx
    exact hx.2
  -- 證明有下界
  · use a
    intro x hx
    exact hx.1
```

#### **定理：有界集合的性質**

```lean
-- 若 E 有界，則存在 M > 0 使得 |x| ≤ M 對所有 x ∈ E
theorem bounded_implies_abs_bounded (E : Set ℝ) (hE : bounded E) :
  ∃ M > 0, ∀ x ∈ E, |x| ≤ M := by
  obtain ⟨⟨M, hM⟩, ⟨m, hm⟩⟩ := hE
  use max (|M|) (|m|) + 1
  constructor
  · linarith [abs_nonneg M, abs_nonneg m]
  · intro x hx
    have hxM := hM x hx
    have hxm := hm x hx
    sorry  -- 需要證明 |x| ≤ max(|M|, |m|)
```

### 與其他概念的關係

#### 1. **最大元與最小元**

- **最大元**（maximum）：若 \(M \in E\) 且 \(M\) 是 \(E\) 的上界，則 \(M = \max E\)
- **最小元**（minimum）：若 \(m \in E\) 且 \(m\) 是 \(E\) 的下界，則 \(m = \min E\)

**關係**：
- 若 \(\max E\) 存在，則 \(\sup E = \max E\)
- 若 \(\min E\) 存在，則 \(\inf E = \min E\)
- 但 \(\sup E\) 或 \(\inf E\) 可能存在而 \(\max E\) 或 \(\min E\) 不存在（例如開區間）

#### 2. **有界函數**

函數 \(f : X \to \mathbb{R}\) 稱為**有界**，若其值域 \(f(X)\) 有界：
\[
\exists M > 0, \forall x \in X, |f(x)| \leq M
\]

#### 3. **有界序列**

序列 \(\{a_n\}\) 稱為**有界**，若集合 \(\{a_n : n \in \mathbb{N}\}\) 有界：
\[
\exists M > 0, \forall n \in \mathbb{N}, |a_n| \leq M
\]

### 常見錯誤與澄清

#### **錯誤 1：混淆確界與極值**

❌ **錯誤**：\(\sup E\) 一定在 \(E\) 中
✅ **正確**：\(\sup E\) 可能不在 \(E\) 中（例如 \(\sup(0, 1) = 1 \notin (0, 1)\)）

#### **錯誤 2：誤解「最大」的含義**

❌ **錯誤**：下確界是最小的下界
✅ **正確**：下確界是**最大**的下界（所有下界中最大的那個）

**記憶方法**：
- \(\sup\)（上確界）= 最**小**的上界 = 從上方逼近
- \(\inf\)（下確界）= 最**大**的下界 = 從下方逼近

#### **錯誤 3：忽略非空條件**

❌ **錯誤**：空集有上確界和下確界
✅ **正確**：定義 1.19 明確要求 \(E\) 非空

**為什麼**：
- 空集的任何實數都是上界（空真命題）
- 沒有「最小的上界」的良定義概念

#### **錯誤 4：誤解有界的必要條件**

❌ **錯誤**：若 \(E \subseteq [a, b]\)，則 \(\sup E = b\) 且 \(\inf E = a\)
✅ **正確**：只能說 \(\sup E \leq b\) 且 \(\inf E \geq a\)

**反例**：\(E = \{\frac{1}{2}\} \subseteq [0, 1]\)，但 \(\sup E = \inf E = \frac{1}{2}\)

### 練習題

#### **基礎練習**

1. **求確界**：求以下集合的上確界和下確界（若存在）：
   - \(E_1 = \{1 - \frac{1}{n} : n \in \mathbb{N}\}\)
   - \(E_2 = \{(-1)^n + \frac{1}{n} : n \in \mathbb{N}\}\)
   - \(E_3 = \{x \in \mathbb{Q} : x^2 < 2\}\)

2. **判斷有界性**：判斷以下集合是否有界：
   - \(\{\sin(n) : n \in \mathbb{N}\}\)
   - \(\{n \sin(\frac{1}{n}) : n \in \mathbb{N}\}\)
   - \(\{\frac{n}{n+1} : n \in \mathbb{N}\}\)

#### **進階練習**

3. **證明**：若 \(E\) 非空且有下界，證明 \(\inf E = -\sup\{-x : x \in E\}\)

4. **證明**：若 \(A, B\) 有界，證明 \(A \cup B\) 有界，且
   \[
   \sup(A \cup B) = \max(\sup A, \sup B)
   \]
   \[
   \inf(A \cup B) = \min(\inf A, \inf B)
   \]

#### **挑戰練習**

5. **Lean 練習**：在 Lean 中證明上面的定理 3 和 4

6. **構造性證明**：給定 \(\varepsilon > 0\) 和有界集合 \(E\)，構造性地找到 \(a \in E\) 使得 \(a < \inf E + \varepsilon\)

### 延伸閱讀

1. **Dedekind 分割**
   - 使用上界和下界的概念來構造實數系統
   - 每個實數對應一個有理數的 Dedekind 分割

2. **極限上下確界**
   - \(\limsup a_n\) 和 \(\liminf a_n\) 的定義
   - 在極限理論中的應用

3. **拓撲學觀點**
   - 有界集合的拓撲性質
   - 緊緻性與有界性的關係（Heine-Borel 定理）

4. **測度論**
   - 外測度的定義使用下確界
   - 內測度的定義使用上確界

---

這些定義是實分析的基礎，為後續的極限、連續性、緊緻性等概念打下堅實基礎。理解上確界和下確界的對偶關係，有助於深入理解實數的完備性結構。

---

## 定理 1.20(1)：上確界與下確界的對偶性

### 定理陳述

**定理 1.20(1)**：設 \(E \subset \mathbb{R}\) 為集合。則：

**(a) 等價性**：\(E\) 有上確界 當且僅當 \(-E\) 有下確界

**(b) 關係式**：若 \(s = \sup E\)，\(t = \inf(-E)\)，則 \(t = -s\)

**符號說明**：
\[
-E := \{-x : x \in E\} = \text{neg\_set}(E)
\]

**數學表述**：
\[
(\exists s, \text{is\_supremum}(s, E)) \Leftrightarrow (\exists t, \text{is\_infimum}(t, -E))
\]
\[
\forall s, t, \quad \text{is\_supremum}(s, E) \land \text{is\_infimum}(t, -E) \Rightarrow t = -s
\]

### 核心思想

這個定理揭示了**上確界與下確界之間的深刻對偶關係**：

**直觀理解**：
- 若 \(s\) 是 \(E\) 中所有元素的「天花板」（最小的上界）
- 則 \(-s\) 是 \(-E\) 中所有元素的「地板」（最大的下界）

**視覺化**：

```
     E:    [  x₁  x₂  x₃  ]  ≤ s (上確界)
                ↓   ↓   ↓
    -E:  [ -x₃ -x₂ -x₁  ]  ≥ -s (下確界)
```

**為什麼這個定理重要？**
1. **理論意義**：完備性公設的上確界版本和下確界版本等價
2. **實用價值**：可以將下確界問題轉化為上確界問題（或反之）
3. **對稱性**：體現了實數系統的內在對稱性

### Lean 4 完整證明（帶詳細註解）

```lean
-- 定義取負的集合：-E = {-x : x ∈ E}
def neg_set (E : Set ℝ) : Set ℝ := {x | -x ∈ E}  -- 注意：x ∈ neg_set E ⟺ -x ∈ E

-- 定理 1.20(1) 包含兩個部分：
-- (a) E 有上確界 ⟺ -E 有下確界（等價性）
-- (b) 若成立，則 inf(-E) = -sup(E)（關係式）
theorem Theorem_1_20_1 (E : Set ℝ):
   ((∃ s, is_supremum s E) ↔ (∃ t, is_infimum t (neg_set E))) ∧  -- 第一部分：等價性
   (∀ s t, is_supremum s E → is_infimum t (neg_set E) → t = -s) := by  -- 第二部分：關係式
   constructor  -- 分解合取（∧）：需要證明兩個部分
   {
      -- 【第一部分】證明等價性：(∃ s, is_supremum s E) ↔ (∃ t, is_infimum t (neg_set E))
      constructor  -- 分解雙向蘊涵（↔）：需要證明 (⇒) 和 (⇐)
      {
         -- 【⇒ 方向】若 E 有上確界 s，則 -E 有下確界 -s
         intro h  -- 假設：h : ∃ s, is_supremum s E
         obtain ⟨s, hs⟩ := h  -- 解構存在性：取出上確界 s 和證據 hs : is_supremum s E
         use -s  -- 聲稱：-s 是 neg_set E 的下確界（需要證明 is_infimum (-s) (neg_set E)）
         constructor  -- 分解 is_infimum 的定義：(1) -s 是下界 ∧ (2) -s 是最大的下界
         {
            -- 【證明 -s 是下界】即證明：∀ x ∈ neg_set E, -s ≤ x
            intro x hx  -- 任取 x ∈ neg_set E（即 -x ∈ E）
            have h1 : -x ≤ s := hs.1 (-x) hx  -- 因為 s 是 E 的上界，所以 -x ≤ s
            linarith  -- 線性算術推理：從 -x ≤ s 得到 -s ≤ x
         }
         {
            -- 【證明 -s 是最大的下界】即證明：∀ m, is_lower_bound m (neg_set E) → m ≤ -s
            intro m hm  -- 任取下界 m（hm : 對所有 x ∈ neg_set E，m ≤ x）
            have h1 : s ≤ -m := by  -- 先證明 s ≤ -m，然後得到 m ≤ -s
               apply hs.2  -- 用上確界的性質：若 -m 是 E 的上界，則 s ≤ -m
               intro a ha  -- 證明 -m 是 E 的上界：任取 a ∈ E，證明 a ≤ -m
               have h2 : m ≤ -a := hm (-a) (by simp [neg_set]; exact ha)  -- 因為 -a ∈ neg_set E 且 m 是下界，所以 m ≤ -a
               linarith  -- 從 m ≤ -a 得到 a ≤ -m
            linarith  -- 從 s ≤ -m 得到 m ≤ -s
         }
      }
      {
         -- 【⇐ 方向】若 -E 有下確界 t，則 E 有上確界 -t
         intro h  -- 假設：h : ∃ t, is_infimum t (neg_set E)
         obtain ⟨t, ht⟩ := h  -- 解構存在性：取出下確界 t 和證據 ht : is_infimum t (neg_set E)
         use -t  -- 聲稱：-t 是 E 的上確界（需要證明 is_supremum (-t) E）
         constructor  -- 分解 is_supremum 的定義：(1) -t 是上界 ∧ (2) -t 是最小的上界
         {
            -- 【證明 -t 是上界】即證明：∀ x ∈ E, x ≤ -t
            intro x hx  -- 任取 x ∈ E
            have h1 : -x ∈ neg_set E := by  -- 先證明 -x ∈ neg_set E
               simp [neg_set]  -- 展開 neg_set 的定義：-x ∈ neg_set E ⟺ -(-x) ∈ E ⟺ x ∈ E
               exact hx  -- 而 hx : x ∈ E
            have h2 : t ≤ -x := ht.1 (-x) h1  -- 因為 t 是 neg_set E 的下界，所以 t ≤ -x
            linarith  -- 從 t ≤ -x 得到 x ≤ -t
         }
         {
            -- 【證明 -t 是最小的上界】即證明：∀ M, is_upper_bound M E → -t ≤ M
            intro m hm  -- 任取上界 m（hm : 對所有 x ∈ E，x ≤ m）
            have h1 : -m ≤ t := by  -- 先證明 -m ≤ t，然後得到 -t ≤ m
               apply ht.2  -- 用下確界的性質：若 -m 是 neg_set E 的下界，則 -m ≤ t
               intro x hx  -- 證明 -m 是 neg_set E 的下界：任取 x ∈ neg_set E，證明 -m ≤ x
               -- hx : x ∈ neg_set E，根據定義就是 -x ∈ E
               have h2 : -x ≤ m := hm (-x) hx  -- 因為 -x ∈ E 且 m 是上界，所以 -x ≤ m
               linarith  -- 從 -x ≤ m 得到 -m ≤ x
            linarith  -- 從 -m ≤ t 得到 -t ≤ m
         }
      }
   }
   {
      -- 【第二部分】證明關係式：若 s 是 E 的上確界，t 是 -E 的下確界，則 t = -s
      intro s t hs ht  -- 引入 s, t 和假設 hs : is_supremum s E, ht : is_infimum t (neg_set E)
      -- 策略：用雙向不等式 t ≤ -s 且 -s ≤ t，然後用 le_antisymm 得到 t = -s
      have h1 : t ≤ -s := by  -- 證明 t ≤ -s
         have h2 : s ≤ -t := by  -- 先證明 s ≤ -t（等價於 t ≤ -s）
            apply hs.2  -- 用上確界的性質：若 -t 是 E 的上界，則 s ≤ -t
            intro a ha  -- 證明 -t 是 E 的上界：任取 a ∈ E，證明 a ≤ -t
            have h3 : t ≤ -a := ht.1 (-a) (by simp [neg_set]; exact ha)  -- 因為 -a ∈ neg_set E 且 t 是下界，所以 t ≤ -a
            linarith  -- 從 t ≤ -a 得到 a ≤ -t
         linarith  -- 從 s ≤ -t 得到 t ≤ -s
      have h2 : -s ≤ t := by  -- 證明 -s ≤ t
         apply ht.2  -- 用下確界的性質：若 -s 是 neg_set E 的下界，則 -s ≤ t
         intro a ha  -- 證明 -s 是 neg_set E 的下界：任取 a ∈ neg_set E，證明 -s ≤ a
         -- ha : a ∈ neg_set E，根據定義就是 -a ∈ E
         have h3 : -a ≤ s := hs.1 (-a) ha  -- 因為 -a ∈ E 且 s 是上界，所以 -a ≤ s
         linarith  -- 從 -a ≤ s 得到 -s ≤ a
      exact le_antisymm h1 h2  -- 由 t ≤ -s 且 -s ≤ t，得到 t = -s（反對稱性）
   }
```

### 證明結構解析

這個證明有**三層結構**：

#### **第一層：合取分解**（`constructor`）

```lean
((∃ s, is_supremum s E) ↔ (∃ t, is_infimum t (neg_set E))) ∧ (...)
           └──────────────── 第一部分 ────────────────┘   └─ 第二部分 ─┘
```

用 `constructor` 分解為兩個子目標：
1. 證明等價性
2. 證明關係式

#### **第二層：等價性分解**（第一個 `constructor`）

```lean
(∃ s, is_supremum s E) ↔ (∃ t, is_infimum t (neg_set E))
      └─── (⇒) ───┘    ↔    └─── (⇐) ───┘
```

用 `constructor` 分解雙向蘊涵為兩個方向：
- **(⇒)**：若 \(E\) 有上確界，則 \(-E\) 有下確界
- **(⇐)**：若 \(-E\) 有下確界，則 \(E\) 有上確界

#### **第三層：確界性質分解**（內層 `constructor`）

對每個方向，證明確界有兩個性質：
1. 是界（上界或下界）
2. 是最優的界（最小或最大）

### 關鍵技巧詳解

#### **技巧 1：`neg_set` 的定義與展開**

```lean
def neg_set (E : Set ℝ) : Set ℝ := {x | -x ∈ E}
```

**重要性質**：
- \(x \in \text{neg\_set}(E) \Leftrightarrow -x \in E\)
- \(-a \in \text{neg\_set}(E) \Leftrightarrow a \in E\)（特別重要！）

**在證明中的使用**：
- 當 `hx : x ∈ neg_set E` 時，直接使用 `hx` 就是 `-x ∈ E`
- 需要證明 `-a ∈ neg_set E` 時，用 `by simp [neg_set]; exact ha`（其中 `ha : a ∈ E`）

#### **技巧 2：不等式方向轉換**

**核心變換**：
\[
t \leq -s \Leftrightarrow s \leq -t
\]

**在證明中**：
```lean
have h1 : t ≤ -s := by
   have h2 : s ≤ -t := by
      -- 證明 s ≤ -t
      ...
   linarith  -- 從 s ≤ -t 推出 t ≤ -s
```

**為什麼這樣做？**
- 目標 `t ≤ -s` 不容易直接證明
- 但 `s ≤ -t` 可以用 `hs.2`（上確界的最小性）
- `linarith` 自動處理線性不等式的轉換

#### **技巧 3：確界的特徵性質**

**上確界的使用**（`hs : is_supremum s E`）：
- `hs.1`：\(s\) 是上界 → 對所有 \(a \in E\)，\(a \leq s\)
- `hs.2`：\(s\) 是最小上界 → 對所有上界 \(M\)，\(s \leq M\)

**下確界的使用**（`ht : is_infimum t (neg_set E)`）：
- `ht.1`：\(t\) 是下界 → 對所有 \(x \in \text{neg\_set}(E)\)，\(t \leq x\)
- `ht.2`：\(t\) 是最大下界 → 對所有下界 \(m\)，\(m \leq t\)

#### **技巧 4：間接證明策略**

**證明 \(m \leq -s\)**：
1. 不直接證明，而是證明 \(s \leq -m\)
2. 用 `hs.2`：只需證明 \(-m\) 是 \(E\) 的上界
3. 從 \(m\) 是 \(-E\) 的下界推導 \(-m\) 是 \(E\) 的上界

**邏輯鏈**：
```
m 是 -E 的下界
    ⇒ ∀ x ∈ -E, m ≤ x
    ⇒ ∀ a ∈ E, m ≤ -a  （取 x = -a）
    ⇒ ∀ a ∈ E, a ≤ -m
    ⇒ -m 是 E 的上界
    ⇒ s ≤ -m  （s 是最小上界）
    ⇒ m ≤ -s
```

#### **技巧 5：雙向不等式證明相等**

```lean
have h1 : t ≤ -s := ...
have h2 : -s ≤ t := ...
exact le_antisymm h1 h2  -- 得到 t = -s
```

**`le_antisymm` 定理**：
\[
a \leq b \land b \leq a \Rightarrow a = b
\]

這是實數（偏序集）的反對稱性。

### 使用的定理和策略

#### **Lean 策略（Tactics）**

1. **`constructor`**：分解合取（\(\land\)）或雙向蘊涵（\(\Leftrightarrow\)）
2. **`intro`**：引入假設或全稱量詞
3. **`obtain ⟨x, hx⟩ := h`**：解構存在性命題
4. **`use`**：提供存在性見證
5. **`apply`**：應用定理或假設
6. **`have`**：引入中間結果
7. **`linarith`**：線性算術自動化
8. **`simp`**：化簡（展開定義）
9. **`exact`**：精確匹配目標
10. **`le_antisymm`**：由 \(a \leq b\) 和 \(b \leq a\) 得 \(a = b\)

#### **關鍵定理**

1. **`is_supremum` 的定義**：
   ```lean
   is_supremum s E := is_upper_bound s E ∧ (∀ M, is_upper_bound M E → s ≤ M)
   ```

2. **`is_infimum` 的定義**：
   ```lean
   is_infimum t E := is_lower_bound t E ∧ (∀ m, is_lower_bound m E → m ≤ t)
   ```

3. **`neg_set` 的定義**：
   ```lean
   def neg_set (E : Set ℝ) := {x | -x ∈ E}
   ```

### 證明流程圖

```
定理 1.20(1)
    │
    ├─ 第一部分：等價性
    │   │
    │   ├─ (⇒) 若 E 有上確界 s
    │   │   │
    │   │   ├─ 聲稱 -s 是 -E 的下確界
    │   │   │   │
    │   │   │   ├─ 證明 -s 是下界
    │   │   │   │   └─ ∀ x ∈ -E, -s ≤ x
    │   │   │   │       └─ 從 -x ≤ s 推出（因為 s 是上界）
    │   │   │   │
    │   │   │   └─ 證明 -s 是最大下界
    │   │   │       └─ ∀ m (下界), m ≤ -s
    │   │   │           └─ 證明 -m 是 E 的上界 → s ≤ -m → m ≤ -s
    │   │   │
    │   │   └─ 完成
    │   │
    │   └─ (⇐) 若 -E 有下確界 t
    │       │
    │       └─ 聲稱 -t 是 E 的上確界（對稱證明）
    │
    └─ 第二部分：關係式 t = -s
        │
        ├─ 證明 t ≤ -s
        │   └─ 證明 s ≤ -t
        │       └─ 證明 -t 是 E 的上界
        │
        ├─ 證明 -s ≤ t
        │   └─ 證明 -s 是 -E 的下界
        │
        └─ 用 le_antisymm 得 t = -s
```

### 常見錯誤與陷阱

#### **錯誤 1：混淆 `neg_set` 的定義**

❌ **錯誤**：以為 `neg_set E = {-x : x ∈ E}`  
✅ **正確**：`neg_set E = {x : -x ∈ E}`

**區別**：
- `neg_set E` 中的元素是 \(x\)，滿足 \(-x \in E\)
- 如果 \(a \in E\)，則 \(-a \in \text{neg\_set}(E)\)

#### **錯誤 2：不等式方向搞錯**

❌ **錯誤**：用 `ht.2` 直接證明 `t ≤ -s`  
✅ **正確**：先證 `s ≤ -t`，然後推出 `t ≤ -s`

**原因**：`ht.2` 的結論是 `m ≤ t`，不是 `t ≤ m`

#### **錯誤 3：忘記 `simp [neg_set]` 或誤用**

在某些情況下：
- ✅ 直接用 `hx`（當 `hx : x ∈ neg_set E` 時，直接就是 `-x ∈ E`）
- ❌ 過度使用 `simp`（有時會 "made no progress"）

**經驗法則**：
- 如果 `hx : x ∈ neg_set E`，直接用，無需 `simp`
- 如果要證明 `x ∈ neg_set E`，可能需要 `simp [neg_set]`

#### **錯誤 4：忽略中間步驟**

❌ **錯誤**：直接從 `hm : is_lower_bound m (neg_set E)` 推出 `m ≤ -s`  
✅ **正確**：先證 `s ≤ -m`，再推 `m ≤ -s`

### 推廣與應用

#### **1. 推廣到一般偏序集**

定理 1.20 可以推廣到任何偏序集 \((P, \leq)\)，只要定義適當的「取負」運算。

#### **2. 實數完備性的等價形式**

**定理**：以下陳述等價：
1. 完備性公設（上確界版本）：非空有上界集合有上確界
2. 完備性公設（下確界版本）：非空有下界集合有下確界

**證明**：直接應用定理 1.20。

#### **3. 在極限理論中的應用**

**極限上確界與極限下確界**：
\[
\limsup_{n \to \infty} a_n = \inf_{n \geq 1} \sup_{k \geq n} a_k
\]
\[
\liminf_{n \to \infty} a_n = \sup_{n \geq 1} \inf_{k \geq n} a_k
\]

定理 1.20 的對偶性在這裡扮演重要角色。

#### **4. 在優化理論中的應用**

**對偶問題**：
- 原問題：\(\min f(x)\)
- 對偶問題：\(\max g(y)\)

上下確界的對偶性是對偶理論的基礎。

### 練習題

#### **基礎練習**

1. **證明**：若 \(E\) 有界，則 \(-E\) 有界。

2. **計算**：設 \(E = (0, 1)\)，求 \(\sup E\)、\(\inf E\)、\(\sup(-E)\)、\(\inf(-E)\)，並驗證 \(\inf(-E) = -\sup E\)。

#### **進階練習**

3. **證明**：若 \(E_1, E_2\) 非空有界，則
   \[
   \sup(E_1 + E_2) = \sup E_1 + \sup E_2
   \]
   其中 \(E_1 + E_2 = \{x + y : x \in E_1, y \in E_2\}\)

4. **證明**：若 \(E\) 非空有界，則
   \[
   \sup E - \inf E = \inf\{|x - y| : x, y \in E\}
   \]
   是否成立？（提示：不成立，右邊是 0）

#### **挑戰練習**

5. **Lean 練習**：證明若 \(E\) 非空有界，則存在 \(a, b \in \mathbb{R}\) 使得 \(E \subseteq [a, b]\)。

6. **推廣**：定理 1.20 能否推廣到 \(\mathbb{R}^n\)？考慮適當的偏序。

### 延伸閱讀

1. **Dedekind 分割與實數構造**
   - 如何用上下確界來定義實數
   - Dedekind 分割的對偶性

2. **凸分析**
   - 凸函數的共軛
   - Fenchel-Legendre 變換

3. **泛函分析**
   - Hahn-Banach 定理
   - 對偶空間理論

4. **優化理論**
   - Lagrange 對偶
   - Minimax 定理

---

這個定理展示了實數系統的深刻對稱性，是理解完備性和確界概念的關鍵。掌握這個證明，不僅能提升形式化證明能力，更能深入理解上下確界的本質。

---

## 定理 1.20(2)：下確界與上確界的對偶性

### 定理陳述

**定理 1.20(2)**：設 \(E \subset \mathbb{R}\) 為集合。則：

**(a) 等價性**：\(E\) 有下確界 當且僅當 \(-E\) 有上確界

**(b) 關係式**：若 \(t = \inf E\)，\(s = \sup(-E)\)，則 \(s = -t\)

**符號說明**：
\[
-E := \{-x : x \in E\} = \text{neg\_set}(E)
\]

**數學表述**：
\[
(\exists t, \text{is\_infimum}(t, E)) \Leftrightarrow (\exists s, \text{is\_supremum}(s, -E))
\]
\[
\forall t, s, \quad \text{is\_infimum}(t, E) \land \text{is\_supremum}(s, -E) \Rightarrow s = -t
\]

### 核心思想

這個定理是**定理 1.20(1) 的對偶版本**，揭示了下確界與上確界的對稱關係：

**直觀理解**：
- 若 \(t\) 是 \(E\) 中所有元素的「地板」（最大的下界）
- 則 \(-t\) 是 \(-E\) 中所有元素的「天花板」（最小的上界）

**視覺化**：

```
     E:  -s ≤ [  x₁  x₂  x₃  ]  (下確界)
                ↓   ↓   ↓
    -E:    [ -x₃ -x₂ -x₁  ]  ≤ -t (上確界)
```

**與定理 1.20(1) 的關係**：
- **定理 1.20(1)**：上確界 ↔ 下確界（\(\sup E\) 與 \(\inf(-E)\)）
- **定理 1.20(2)**：下確界 ↔ 上確界（\(\inf E\) 與 \(\sup(-E)\)）

這兩個定理互為對偶，證明方法也完全對稱！

### Lean 4 完整證明（帶詳細註解）

```lean
-- 定理 1.20(2)：E 有下確界 ⟺ -E 有上確界，且 sup(-E) = -inf(E)
theorem Theorem_1_20_2 (E : Set ℝ):
   ((∃ t, is_infimum t E) ↔ (∃ s, is_supremum s (neg_set E))) ∧  -- 第一部分：等價性
   (∀ t s, is_infimum t E → is_supremum s (neg_set E) → s = -t) := by  -- 第二部分：關係式
   constructor  -- 分解合取（∧）：需要證明兩個部分
   {
      -- 【第一部分】證明等價性：(∃ t, is_infimum t E) ↔ (∃ s, is_supremum s (neg_set E))
      constructor  -- 分解雙向蘊涵（↔）：需要證明 (⇒) 和 (⇐)
      {
         -- 【⇒ 方向】若 E 有下確界 t，則 -E 有上確界 -t
         intro h  -- 假設：h : ∃ t, is_infimum t E
         obtain ⟨t, ht⟩ := h  -- 解構存在性：取出下確界 t 和證據 ht : is_infimum t E
         use -t  -- 聲稱：-t 是 neg_set E 的上確界（需要證明 is_supremum (-t) (neg_set E)）
         constructor  -- 分解 is_supremum 的定義：(1) -t 是上界 ∧ (2) -t 是最小的上界
         {
            -- 【證明 -t 是上界】即證明：∀ x ∈ neg_set E, x ≤ -t
            intro x hx  -- 任取 x ∈ neg_set E（即 -x ∈ E）
            have h1 : -x ∈ E := hx  -- 根據 neg_set 的定義，x ∈ neg_set E 意味著 -x ∈ E
            have h2 : t ≤ -x := ht.1 (-x) h1  -- 因為 t 是 E 的下界，所以 t ≤ -x
            linarith  -- 線性算術推理：從 t ≤ -x 得到 x ≤ -t
         }
         {
            -- 【證明 -t 是最小的上界】即證明：∀ m, is_upper_bound m (neg_set E) → -t ≤ m
            intro m hm  -- 任取上界 m（hm : 對所有 x ∈ neg_set E，x ≤ m）
            have h1 : -m ≤ t := by  -- 先證明 -m ≤ t，然後得到 -t ≤ m
               apply ht.2  -- 用下確界的性質：若 -m 是 E 的下界，則 -m ≤ t
               intro a ha  -- 證明 -m 是 E 的下界：任取 a ∈ E，證明 -m ≤ a
               have h2 : -a ∈ neg_set E := by simp [neg_set]; exact ha  -- 因為 a ∈ E，所以 -a ∈ neg_set E
               have h3 : -a ≤ m := hm (-a) h2  -- 因為 -a ∈ neg_set E 且 m 是上界，所以 -a ≤ m
               linarith  -- 從 -a ≤ m 得到 -m ≤ a
            linarith  -- 從 -m ≤ t 得到 -t ≤ m
         }
      }
      {
         -- 【⇐ 方向】若 -E 有上確界 s，則 E 有下確界 -s
         intro h  -- 假設：h : ∃ s, is_supremum s (neg_set E)
         obtain ⟨s, hs⟩ := h  -- 解構存在性：取出上確界 s 和證據 hs : is_supremum s (neg_set E)
         use -s  -- 聲稱：-s 是 E 的下確界（需要證明 is_infimum (-s) E）
         constructor  -- 分解 is_infimum 的定義：(1) -s 是下界 ∧ (2) -s 是最大的下界
         {
            -- 【證明 -s 是下界】即證明：∀ x ∈ E, -s ≤ x
            intro x hx  -- 任取 x ∈ E
            have h1 : -x ∈ neg_set E := by simp [neg_set]; exact hx  -- 先證明 -x ∈ neg_set E
            have h2 : -x ≤ s := hs.1 (-x) h1  -- 因為 s 是 neg_set E 的上界，所以 -x ≤ s
            linarith  -- 從 -x ≤ s 得到 -s ≤ x
         }
         {
            -- 【證明 -s 是最大的下界】即證明：∀ m, is_lower_bound m E → m ≤ -s
            intro m hm  -- 任取下界 m（hm : 對所有 x ∈ E，m ≤ x）
            have h1 : -m ≥ s := by  -- 先證明 -m ≥ s（即 s ≤ -m），然後得到 m ≤ -s
               apply hs.2  -- 用上確界的性質：若 -m 是 neg_set E 的上界，則 s ≤ -m
               intro y hy  -- 證明 -m 是 neg_set E 的上界：任取 y ∈ neg_set E，證明 y ≤ -m
               have h2 : -y ∈ E := hy  -- hy : y ∈ neg_set E，根據定義就是 -y ∈ E
               have h3 : m ≤ -y := hm (-y) h2  -- 因為 -y ∈ E 且 m 是下界，所以 m ≤ -y
               linarith  -- 從 m ≤ -y 得到 y ≤ -m
            linarith  -- 從 s ≤ -m 得到 m ≤ -s
         }
      }
   }
   {
      -- 【第二部分】證明關係式：若 t 是 E 的下確界，s 是 -E 的上確界，則 s = -t
      intro t s ht hs  -- 引入 t, s 和假設 ht : is_infimum t E, hs : is_supremum s (neg_set E)
      -- 策略：用雙向不等式 s ≤ -t 且 -t ≤ s，然後用 le_antisymm 得到 s = -t
      have h1 : s ≤ -t := by  -- 證明 s ≤ -t
         apply hs.2  -- 用上確界的性質：若 -t 是 neg_set E 的上界，則 s ≤ -t
         intro x hx  -- 證明 -t 是 neg_set E 的上界：任取 x ∈ neg_set E，證明 x ≤ -t
         have h2 : -x ∈ E := hx  -- hx : x ∈ neg_set E，根據定義就是 -x ∈ E
         have h3 : t ≤ -x := ht.1 (-x) h2  -- 因為 t 是 E 的下界，所以 t ≤ -x
         linarith  -- 從 t ≤ -x 得到 x ≤ -t
      have h2 : -t ≤ s := by  -- 證明 -t ≤ s
         have h3 : -s ≤ t := by  -- 先證明 -s ≤ t（等價於 -t ≤ s）
            apply ht.2  -- 用下確界的性質：若 -s 是 E 的下界，則 -s ≤ t
            intro a ha  -- 證明 -s 是 E 的下界：任取 a ∈ E，證明 -s ≤ a
            have h4 : -a ∈ neg_set E := by simp [neg_set]; exact ha  -- 因為 a ∈ E，所以 -a ∈ neg_set E
            have h5 : -a ≤ s := hs.1 (-a) h4  -- 因為 -a ∈ neg_set E 且 s 是上界，所以 -a ≤ s
            linarith  -- 從 -a ≤ s 得到 -s ≤ a
         linarith  -- 從 -s ≤ t 得到 -t ≤ s
      exact le_antisymm h1 h2  -- 由 s ≤ -t 且 -t ≤ s，得到 s = -t（反對稱性）
   }
```

### 證明結構解析

這個證明和定理 1.20(1) 有**完全對稱的結構**：

#### **對稱性對照表**

| 定理 1.20(1) | 定理 1.20(2) |
|-------------|-------------|
| \(E\) 有上確界 | \(E\) 有下確界 |
| \(-E\) 有下確界 | \(-E\) 有上確界 |
| \(\inf(-E) = -\sup E\) | \(\sup(-E) = -\inf E\) |
| \(s = \sup E\) | \(t = \inf E\) |
| \(t = \inf(-E)\) | \(s = \sup(-E)\) |
| \(t = -s\) | \(s = -t\) |

#### **證明結構**（三層）

**第一層：合取分解**
```lean
((∃ t, is_infimum t E) ↔ (∃ s, is_supremum s (neg_set E))) ∧ (...)
           └──────────────── 等價性 ────────────────┘   └─ 關係式 ─┘
```

**第二層：雙向蘊涵分解**
- **(⇒)**：\(E\) 有下確界 \(\Rightarrow\) \(-E\) 有上確界 \(-t\)
- **(⇐)**：\(-E\) 有上確界 \(\Rightarrow\) \(E\) 有下確界 \(-s\)

**第三層：確界性質分解**
- 是界（下界 / 上界）
- 是最優的界（最大 / 最小）

### 關鍵技巧詳解

#### **技巧 1：對偶性的理解**

**定理 1.20(1) vs 定理 1.20(2)**：

兩個定理的證明策略完全對稱，只需要：
- 把「上確界」和「下確界」互換
- 把「上界」和「下界」互換
- 把「最小」和「最大」互換
- 不等式方向翻轉（\(\leq\) 變 \(\geq\)，或反之）

#### **技巧 2：不等式鏈的建立**

**證明 \(-t\) 是上界**：
```
t 是下界
  ⇒ ∀ y ∈ E, t ≤ y
  ⇒ ∀ x ∈ -E, t ≤ -x  （取 y = -x）
  ⇒ ∀ x ∈ -E, x ≤ -t
  ⇒ -t 是上界
```

**證明 \(-t\) 是最小上界**：
```
t 是最大下界
  ⇒ 對任意下界 m', m' ≤ t
  ⇒ 對任意上界 m（令 m' = -m）, -m ≤ t
  ⇒ -t ≤ m
  ⇒ -t 是最小上界
```

#### **技巧 3：雙重取負的處理**

**關鍵性質**：
- \(x \in \text{neg\_set}(E) \Leftrightarrow -x \in E\)
- \(-(-a) = a\)（雙重取負消除）

**在證明中**：
- 要證 \(-a \in \text{neg\_set}(E)\)，需要證 \(-(-a) = a \in E\)
- 用 `simp [neg_set]` 自動處理這個化簡

#### **技巧 4：參數順序的注意**

**注意定理陳述的參數順序**：
```lean
-- 定理 1.20(1): ∀ s t, is_supremum s E → is_infimum t (neg_set E) → t = -s
-- 定理 1.20(2): ∀ t s, is_infimum t E → is_supremum s (neg_set E) → s = -t
```

- 定理 1.20(1)：先 \(s\)（上確界），後 \(t\)（下確界）
- 定理 1.20(2)：先 \(t\)（下確界），後 \(s\)（上確界）

這反映了對偶性！

### 使用的定理和策略

#### **Lean 策略**（與定理 1.20(1) 相同）

1. **`constructor`**：分解合取或雙向蘊涵
2. **`intro` / `obtain`**：引入假設和解構
3. **`use`**：提供存在性見證
4. **`apply`**：應用確界的性質
5. **`have`**：建立中間結果
6. **`linarith`**：處理線性不等式
7. **`simp [neg_set]`**：展開 `neg_set` 定義
8. **`le_antisymm`**：證明相等

#### **核心邏輯**

兩個方向的證明都依賴：
1. **界的對偶性**：\(t\) 是 \(E\) 的下界 \(\Leftrightarrow\) \(-t\) 是 \(-E\) 的上界
2. **最優性的對偶性**：\(t\) 是最大下界 \(\Leftrightarrow\) \(-t\) 是最小上界

### 證明流程圖

```
定理 1.20(2)
    │
    ├─ 第一部分：等價性
    │   │
    │   ├─ (⇒) 若 E 有下確界 t
    │   │   │
    │   │   ├─ 聲稱 -t 是 -E 的上確界
    │   │   │   │
    │   │   │   ├─ 證明 -t 是上界
    │   │   │   │   └─ ∀ x ∈ -E, x ≤ -t
    │   │   │   │       └─ 從 t ≤ -x 推出（因為 t 是下界）
    │   │   │   │
    │   │   │   └─ 證明 -t 是最小上界
    │   │   │       └─ ∀ m (上界), -t ≤ m
    │   │   │           └─ 證明 -m 是 E 的下界 → -m ≤ t → -t ≤ m
    │   │   │
    │   │   └─ 完成
    │   │
    │   └─ (⇐) 若 -E 有上確界 s
    │       │
    │       └─ 聲稱 -s 是 E 的下確界（對稱證明）
    │
    └─ 第二部分：關係式 s = -t
        │
        ├─ 證明 s ≤ -t
        │   └─ 證明 -t 是 -E 的上界
        │
        ├─ 證明 -t ≤ s
        │   └─ 證明 -s ≤ t
        │       └─ 證明 -s 是 E 的下界
        │
        └─ 用 le_antisymm 得 s = -t
```

### 常見錯誤與陷阱

#### **錯誤 1：與定理 1.20(1) 混淆**

❌ **錯誤**：在定理 1.20(2) 中使用定理 1.20(1) 的結論  
✅ **正確**：雖然兩者對稱，但需要獨立證明

#### **錯誤 2：不等式方向搞反**

在定理 1.20(2) 中：
- ❌ **錯誤**：用上確界的性質證明下確界
- ✅ **正確**：\(t\) 是下確界 → \(t \leq y\) （不是 \(y \leq t\)）

#### **錯誤 3：參數順序錯誤**

```lean
-- ❌ 錯誤
intro s t hs ht  -- 順序反了

-- ✅ 正確  
intro t s ht hs  -- 先 t (下確界), 後 s (上確界)
```

### 定理 1.20 的完整圖景

#### **兩個定理的統一視角**

| 面向 | 定理 1.20(1) | 定理 1.20(2) |
|-----|-------------|-------------|
| 起點 | 上確界（\(\sup E\)） | 下確界（\(\inf E\)） |
| 終點 | 下確界（\(\inf(-E)\)） | 上確界（\(\sup(-E)\)） |
| 關係 | \(\inf(-E) = -\sup E\) | \(\sup(-E) = -\inf E\) |
| 核心 | 上 → 下 | 下 → 上 |

#### **四個確界的關係**

對任意集合 \(E\)：

```
        sup E         ←對偶→        inf(-E) = -sup E
          ↑                              ↑
     定理 1.20(1)                   定理 1.20(1)
          ↓                              ↓
        inf E         ←對偶→        sup(-E) = -inf E
```

### 練習題

#### **基礎練習**

1. **證明**：若 \(t = \inf E\)，則 \(-t = \sup(-E)\)。

2. **計算**：設 \(E = [-2, 3)\)，求：
   - \(\inf E\)
   - \(\sup(-E)\)
   - 驗證 \(\sup(-E) = -\inf E\)

#### **進階練習**

3. **證明**：若 \(E_1, E_2\) 非空有下界，則
   \[
   \inf(E_1 + E_2) = \inf E_1 + \inf E_2
   \]

4. **Lean 練習**：證明若 \(\sup E\) 和 \(\inf E\) 都存在，則 \(\inf E \leq \sup E\)。

#### **挑戰練習**

5. **統一證明**：能否寫一個更抽象的定理，同時包含 1.20(1) 和 1.20(2)？

6. **推廣**：定理 1.20 能否推廣到 \(\mathbb{R} \cup \{\pm\infty\}\)？

### 與其他定理的聯繫

#### **與完備性公設的關係**

**完備性公設的兩種表述**：
1. **上確界版本**：非空有上界集合有上確界
2. **下確界版本**：非空有下界集合有下確界

**定理 1.20 證明了兩種表述等價**：
- 由定理 1.20(1)：上確界存在 → 下確界存在
- 由定理 1.20(2)：下確界存在 → 上確界存在

#### **在後續定理中的應用**

- **定理 1.21**：區間套定理
- **定理 1.22**：Bolzano-Weierstrass 定理
- **定理 1.30**：Heine-Borel 定理

這些定理的證明都會用到上下確界的對偶性。

### 延伸思考

#### **哲學意義**

定理 1.20 揭示了一個深刻的對稱性：
- 在實數系統中，「向上」和「向下」是完全對稱的
- 這種對稱性來自於實數的完備性

#### **在其他數學分支中**

- **拓撲學**：開集與閉集的對偶
- **範疇論**：對偶範疇
- **線性代數**：對偶空間
- **優化理論**：原問題與對偶問題

定理 1.20 是這些對偶性的原型！

---

這個定理是定理 1.20(1) 的完美對偶，證明方法完全對稱。掌握這兩個定理，能夠深刻理解上下確界的本質和實數系統的對稱性。

---

## 定理 1.21(1)：子集的上確界不大於母集的上確界

### 定理陳述

**定理 1.21(1)**：設 \(A \subseteq B\) 為實數集合。若 \(s = \sup B\) 且 \(t = \sup A\)，則：
\[
t \leq s
\]

即：**子集的上確界不大於母集的上確界**。

**數學表述**：
\[
\forall s, t \in \mathbb{R}, \quad \text{is\_supremum}(s, B) \land \text{is\_supremum}(t, A) \Rightarrow t \leq s
\]

### 核心思想

這個定理陳述了一個直觀的事實：

**直觀理解**：
- 如果 \(A\) 是 \(B\) 的子集，\(A\) 的元素更少
- 因此 \(A\) 的「天花板」（上確界）不會比 \(B\) 的「天花板」更高

**視覺化**：

```
B:  [●  ●  ●  ●  ●  ●  ●] ≤ s (sup B)
     
A:     [●  ●  ●  ●] ≤ t (sup A)
       
       A ⊆ B  ⟹  t ≤ s
```

**為什麼這個定理重要？**
1. **單調性**：體現上確界運算的單調性
2. **實用性**：比較不同集合的上確界
3. **基礎性**：許多不等式證明的基礎

### Lean 4 完整證明（帶詳細註解）

```lean
-- 定理 1.21(1)：若 A ⊆ B，則 sup(A) ≤ sup(B)
theorem Theorem_1_21_1 (A B : Set ℝ) (hA_sub_B : A ⊆ B) :
   ∀ s t, is_supremum s B → is_supremum t A → t ≤ s := by  -- 若 s = sup B，t = sup A，則 t ≤ s
   intro s t hs ht  -- 引入上確界 s, t 和假設 hs : is_supremum s B, ht : is_supremum t A
   -- 【策略】用 t 的最小性：只需證明 s 是 A 的上界
   apply ht.2  -- 用上確界 t 的最小性：若 s 是 A 的上界，則 t ≤ s
   -- 【證明 s 是 A 的上界】即證明：∀ a ∈ A, a ≤ s
   intro a ha  -- 任取 a ∈ A
   have ha_in_B : a ∈ B := hA_sub_B ha  -- 因為 A ⊆ B 且 a ∈ A，所以 a ∈ B
   exact hs.1 a ha_in_B  -- 因為 s 是 B 的上界且 a ∈ B，所以 a ≤ s（用 hs.1：上界性質）
```

### 證明結構解析

這個證明**非常簡潔**，只有三個關鍵步驟：

#### **證明策略**

要證明 \(t \leq s\)，利用**上確界的最小性**：
- \(t\) 是 \(A\) 的最小上界
- 所以只需證明 \(s\) 是 \(A\) 的上界
- 則自動得到 \(t \leq s\)

#### **證明流程**

```
目標：t ≤ s
  ↓
用 ht.2（t 的最小性）
  ↓
新目標：s 是 A 的上界
  ↓
證明：∀ a ∈ A, a ≤ s
  ↓
  任取 a ∈ A
    → a ∈ B（因為 A ⊆ B）
    → a ≤ s（因為 s 是 B 的上界）
  ↓
完成！
```

### 關鍵技巧詳解

#### **技巧 1：利用上確界的最小性**

**上確界的兩個性質**：
1. **`hs.1`**：\(s\) 是上界 → `∀ x ∈ B, x ≤ s`
2. **`hs.2`**：\(s\) 是最小上界 → `∀ M (上界), s ≤ M`

**在證明中**：
- 用 `ht.2`（\(t\) 的最小性）將目標從 `t ≤ s` 轉換為「證明 \(s\) 是 \(A\) 的上界」
- 這是**間接證明**的典型應用

#### **技巧 2：子集關係的使用**

**子集的定義**：
```lean
A ⊆ B  ⟺  ∀ x, x ∈ A → x ∈ B
```

**在證明中**：
```lean
have ha_in_B : a ∈ B := hA_sub_B ha
```
- `hA_sub_B : A ⊆ B` 是一個函數，可以對 `ha : a ∈ A` 應用
- 得到 `a ∈ B`

#### **技巧 3：傳遞性鏈**

**邏輯鏈**：
```
a ∈ A  (假設)
  → a ∈ B  (子集關係)
  → a ≤ s  (s 是 B 的上界)
```

這個鏈條非常直接，體現了證明的簡潔性。

### 證明的優雅之處

#### **1. 證明長度**

只有 **4 行核心證明**：
```lean
apply ht.2
intro a ha
have ha_in_B : a ∈ B := hA_sub_B ha
exact hs.1 a ha_in_B
```

#### **2. 證明思路**

**關鍵洞察**：
- 不直接比較 \(t\) 和 \(s\)
- 而是證明 \(s\) 也是 \(A\) 的上界
- 利用「最小」的定義自動得出結論

#### **3. 無需反證或複雜構造**

這是一個**構造性證明**，完全基於定義展開。

### 使用的定理和策略

#### **Lean 策略**

1. **`intro`**：引入全稱量詞和假設
2. **`apply`**：應用定理（這裡是上確界的最小性）
3. **`have`**：建立中間結果
4. **`exact`**：精確匹配目標

#### **關鍵定理**

1. **上確界的定義**：
   ```lean
   is_supremum s E := is_upper_bound s E ∧ (∀ M, is_upper_bound M E → s ≤ M)
   ```

2. **子集的定義**：
   ```lean
   A ⊆ B := ∀ x, x ∈ A → x ∈ B
   ```

### 推廣與變形

#### **推廣 1：下確界版本**

**定理**：若 \(A \subseteq B\)，則 \(\inf B \leq \inf A\)

**注意方向**：
- 上確界：\(\sup A \leq \sup B\)（子集的上確界更小）
- 下確界：\(\inf B \leq \inf A\)（子集的下確界更大）

**為什麼方向相反？**
- 子集元素更少，「天花板」更低，「地板」更高

#### **推廣 2：有界集合**

**推論**：若 \(A \subseteq B\) 且 \(B\) 有界，則 \(A\) 有界。

**證明思路**：
- \(B\) 有上界 \(M\) → \(M\) 也是 \(A\) 的上界
- \(B\) 有下界 \(m\) → \(m\) 也是 \(A\) 的下界

#### **推廣 3：不等式鏈**

若 \(A_1 \subseteq A_2 \subseteq \cdots \subseteq A_n\)，則：
\[
\sup A_1 \leq \sup A_2 \leq \cdots \leq \sup A_n
\]

這體現了上確界運算的**單調性**。

### 應用實例

#### **實例 1：區間包含**

**命題**：\([0, 1] \subseteq [0, 2]\)，驗證 \(\sup[0,1] \leq \sup[0,2]\)

**驗證**：
- \(\sup[0, 1] = 1\)
- \(\sup[0, 2] = 2\)
- 確實 \(1 \leq 2\) ✓

#### **實例 2：有理數與實數**

**命題**：\(\mathbb{Q} \cap [0, 1] \subseteq [0, 1]\)

**結論**：
\[
\sup(\mathbb{Q} \cap [0, 1]) \leq \sup[0, 1] = 1
\]

事實上，\(\sup(\mathbb{Q} \cap [0, 1]) = 1\)（因為有理數稠密）

#### **實例 3：數列的上確界**

設 \(a_n = 1 - \frac{1}{n}\)，令：
- \(A_n = \{a_1, a_2, \ldots, a_n\}\)
- \(A = \{a_n : n \in \mathbb{N}\}\)

則 \(A_n \subseteq A\)，所以 \(\sup A_n \leq \sup A = 1\)

### 常見錯誤與陷阱

#### **錯誤 1：方向搞反**

❌ **錯誤**：\(A \subseteq B\) 所以 \(\sup A \geq \sup B\)  
✅ **正確**：\(A \subseteq B\) 所以 \(\sup A \leq \sup B\)

**記憶法**：子集更小，上確界也更小（或相等）

#### **錯誤 2：忘記空集情況**

在某些情況下需要考慮：
- 若 \(A = \emptyset\)，\(\sup A\) 可能未定義
- 定理通常假設集合非空且有上確界

#### **錯誤 3：混淆上界和上確界**

❌ **錯誤**：\(s\) 是 \(B\) 的上界，所以 \(s\) 是 \(A\) 的上確界  
✅ **正確**：\(s\) 是 \(B\) 的上界，所以 \(s\) 是 \(A\) 的**上界**（不一定是上確界）

### 對偶定理：下確界版本

#### **定理 1.21(1') - 下確界版本**

**定理**：設 \(A \subseteq B\)。若 \(m = \inf B\) 且 \(n = \inf A\)，則：
\[
m \leq n
\]

**證明思路**（完全對稱）：
1. 用 \(n\) 的最大性
2. 證明 \(m\) 是 \(A\) 的下界
3. 因為 \(A \subseteq B\) 且 \(m\) 是 \(B\) 的下界

**Lean 證明**：
```lean
theorem Theorem_1_21_1' (A B : Set ℝ) (hA_sub_B : A ⊆ B) :
   ∀ m n, is_infimum m B → is_infimum n A → m ≤ n := by
   intro m n hm hn
   apply hn.2  -- 用 n 的最大性
   intro a ha  -- 證明 m 是 A 的下界
   have ha_in_B : a ∈ B := hA_sub_B ha
   exact hm.1 a ha_in_B
```

### 練習題

#### **基礎練習**

1. **證明**：若 \(A \subseteq B \subseteq C\)，則 \(\sup A \leq \sup C\)。

2. **計算**：設 \(A = \{1, 2, 3\}\)，\(B = \{1, 2, 3, 4, 5\}\)。
   - 計算 \(\sup A\) 和 \(\sup B\)
   - 驗證 \(\sup A \leq \sup B\)

#### **進階練習**

3. **證明**：若 \(A \subseteq B\) 且 \(\sup A = \sup B\)，則 \(\sup B \in A\) 或 \(\sup B\) 是 \(A\) 的極限點。

4. **Lean 練習**：證明下確界版本的定理 1.21(1')。

#### **挑戰練習**

5. **反例**：能否找到 \(A \subseteq B\) 使得 \(\sup A = \sup B\) 但 \(A \neq B\)？

6. **推廣**：若 \(A_1 \subseteq A_2 \subseteq A_3 \subseteq \cdots\)，證明 \(\sup(\bigcup_{n=1}^{\infty} A_n) = \lim_{n \to \infty} \sup A_n\)。

### 與其他定理的聯繫

#### **與完備性公設的關係**

定理 1.21 假設上確界存在，但不保證存在性。結合完備性公設：
- 若 \(B\) 非空有上界，則 \(\sup B\) 存在（完備性）
- 若 \(A \subseteq B\)，則 \(A\) 也有上界（定理 1.21）
- 因此 \(A\) 也有上確界

#### **在後續定理中的應用**

- **區間套定理**（定理 1.21）：需要比較嵌套區間的端點
- **Heine-Borel 定理**：需要比較開覆蓋的上確界
- **極限理論**：比較部分和的上確界

### 延伸閱讀

1. **格論（Lattice Theory）**
   - 上確界作為格上的並運算
   - 單調性是格同態的基本性質

2. **測度論**
   - 子集的測度不大於母集的測度
   - 單調性的推廣

3. **拓撲學**
   - 子空間的緊性
   - 包含關係下的性質傳遞

---

這個定理看似簡單，但揭示了上確界運算的單調性，是許多後續證明的基礎。其證明也展示了如何巧妙地利用上確界的最小性質。

---

## 定理 1.21(2)：子集的下確界不小於母集的下確界

### 定理陳述

**定理 1.21(2)**：設 \(A \subseteq B\) 為實數集合。若 \(s = \inf B\) 且 \(t = \inf A\)，則：
\[
s \leq t
\]

即：**子集的下確界不小於母集的下確界**。

**數學表述**：
\[
\forall t, s \in \mathbb{R}, \quad \text{is\_infimum}(s, B) \land \text{is\_infimum}(t, A) \Rightarrow s \leq t
\]

### 核心思想

這個定理是**定理 1.21(1) 的對偶版本**，方向相反：

**定理 1.21(1) vs 定理 1.21(2)**：
- **上確界**：\(A \subseteq B \Rightarrow \sup A \leq \sup B\)（子集的上確界更小）
- **下確界**：\(A \subseteq B \Rightarrow \inf B \leq \inf A\)（子集的下確界更大）

**直觀理解**：
- 子集 \(A\) 的元素更少
- \(A\) 的「天花板」（上確界）不會比 \(B\) 更高
- \(A\) 的「地板」（下確界）不會比 \(B\) 更低

**視覺化**：

```
B:  m (inf B) ≤ [●  ●  ●  ●  ●  ●  ●]
     
A:              n (inf A) ≤ [●  ●  ●  ●]
       
       A ⊆ B  ⟹  m ≤ n
```

**為什麼方向相反？**
- 上確界是「向上看」，元素越少，上界越低
- 下確界是「向下看」，元素越少，下界越高
- 這體現了上下確界的**對偶性**

### Lean 4 完整證明（帶詳細註解）

```lean
-- 定理 1.21(2)：若 A ⊆ B，則 inf(B) ≤ inf(A)（注意方向與上確界相反）
theorem Theorem_1_21_2 (A B : Set ℝ) (hA_sub_B : A ⊆ B) :
   ∀ t s, is_infimum s B → is_infimum t A → s ≤ t := by  -- 若 s = inf B，t = inf A，則 s ≤ t
   intro t s ht hs  -- 引入下確界 t, s 和假設 ht : is_infimum s B, hs : is_infimum t A
   -- 【策略】用 t 的最大性：只需證明 s 是 A 的下界
   apply hs.2  -- 用下確界 t 的最大性：若 s 是 A 的下界，則 s ≤ t（hs 對應 is_infimum t A）
   -- 【證明 s 是 A 的下界】即證明：∀ a ∈ A, s ≤ a
   intro a ha  -- 任取 a ∈ A
   have ha_in_B : a ∈ B := hA_sub_B ha  -- 因為 A ⊆ B 且 a ∈ A，所以 a ∈ B
   exact ht.1 a ha_in_B  -- 因為 s 是 B 的下界且 a ∈ B，所以 s ≤ a（用 ht.1：下界性質）
```

### 證明結構解析

這個證明和定理 1.21(1) **完全對稱**：

#### **證明策略對照**

| 定理 1.21(1) | 定理 1.21(2) |
|-------------|-------------|
| 證明 \(t \leq s\) | 證明 \(s \leq t\) |
| 用 \(t\) 的最小性 | 用 \(t\) 的最大性 |
| 證明 \(s\) 是 \(A\) 的**上界** | 證明 \(s\) 是 \(A\) 的**下界** |
| \(\forall a \in A, a \leq s\) | \(\forall a \in A, s \leq a\) |

#### **證明流程**

```
目標：s ≤ t
  ↓
用 hs.2（t 的最大性）
  ↓
新目標：s 是 A 的下界
  ↓
證明：∀ a ∈ A, s ≤ a
  ↓
  任取 a ∈ A
    → a ∈ B（因為 A ⊆ B）
    → s ≤ a（因為 s 是 B 的下界）
  ↓
完成！
```

### 關鍵觀察：方向為什麼相反？

#### **直觀解釋**

想像一個集合的「範圍」：

```
       sup B (大集合的天花板，較高)
          ↑
       sup A (小集合的天花板，較低)
          ↑
    [  A 的元素  ]
          ↓
       inf A (小集合的地板，較高)
          ↓
       inf B (大集合的地板，較低)
```

**原因**：
- 元素越多，範圍越大
- 上確界越高，下確界越低

#### **數學推理**

**上確界**：
- \(A \subseteq B\) → 任何 \(B\) 的上界也是 \(A\) 的上界
- 所以 \(\sup B\) 是 \(A\) 的上界
- 因此 \(\sup A \leq \sup B\)（\(\sup A\) 是最小上界）

**下確界**：
- \(A \subseteq B\) → 任何 \(B\) 的下界也是 \(A\) 的下界
- 所以 \(\inf B\) 是 \(A\) 的下界
- 因此 \(\inf B \leq \inf A\)（\(\inf A\) 是最大下界）

### 關鍵技巧詳解

#### **技巧 1：對偶性的運用**

定理 1.21(1) 和 1.21(2) 的證明**完全平行**：
- 把「上」換成「下」
- 把「最小」換成「最大」
- 把 \(\leq\) 換成 \(\geq\)

#### **技巧 2：下確界的最大性**

**下確界的兩個性質**：
1. **`ht.1`**：\(t\) 是下界 → `∀ x ∈ A, t ≤ x`
2. **`hs.2`**：\(t\) 是最大下界 → `∀ m (下界), m ≤ t`

**在證明中**：
```lean
apply hs.2  -- 將目標從 s ≤ t 轉換為「證明 s 是 A 的下界」
```

#### **技巧 3：記住不等式方向**

**常見混淆**：
- ❌ 以為下確界也是「子集更小」
- ✅ 正確：下確界是「子集更大」

**記憶法**：
- 上確界：向上看，子集範圍小，所以上確界小
- 下確界：向下看，子集範圍小，所以下確界大

### 定理 1.21 的完整圖景

#### **兩個部分的統一視角**

對於 \(A \subseteq B\)：

```
                    sup B
                     ↑
                   sup A   ← 上確界：子集更小
                     ↑
    ━━━━━━━━━━━━━━━━━━━━━━━━
                B 的範圍
    ━━━━━━━━━━━━━━━━━━━━━━━━
                     ↓
                   inf A   ← 下確界：子集更大
                     ↓
                    inf B
```

#### **不等式鏈**

\[
\inf B \leq \inf A \leq \sup A \leq \sup B
\]

這四個確界的關係完整描述了兩個集合的包含關係！

### 應用實例

#### **實例 1：區間包含**

**命題**：\([1, 3] \subseteq [0, 5]\)

**驗證**：
- \(\inf[0, 5] = 0 \leq 1 = \inf[1, 3]\) ✓
- \(\sup[1, 3] = 3 \leq 5 = \sup[0, 5]\) ✓

#### **實例 2：收斂數列**

設 \(a_n = \frac{1}{n}\)，令：
- \(A_n = \{a_k : k \geq n\}\)
- \(A_{n+1} \subseteq A_n\)（遞減的集合序列）

則：
\[
\inf A_1 \leq \inf A_2 \leq \cdots \leq \inf A_n \leq \cdots
\]

這是一個**遞增**的下確界序列！

#### **實例 3：函數的值域**

設 \(f : [0, 1] \to \mathbb{R}\)，令：
- \(A = \{f(x) : x \in [0, 1]\}\)
- \(B = \{f(x) : x \in [0, 2]\}\)

若 \([0, 1] \subseteq [0, 2]\)，則：
\[
\inf B \leq \inf A \leq \sup A \leq \sup B
\]

### 常見錯誤與陷阱

#### **錯誤 1：方向搞反（最常見！）**

❌ **錯誤**：\(A \subseteq B\) 所以 \(\inf A \leq \inf B\)  
✅ **正確**：\(A \subseteq B\) 所以 \(\inf B \leq \inf A\)

**提醒**：下確界的方向和上確界**相反**！

#### **錯誤 2：與定理 1.21(1) 混淆**

| 項目 | 定理 1.21(1) | 定理 1.21(2) |
|-----|-------------|-------------|
| 確界類型 | 上確界 | 下確界 |
| 不等式 | \(\sup A \leq \sup B\) | \(\inf B \leq \inf A\) |
| 方向 | 左小右大 | 左小右大 |

注意：雖然不等號方向一致，但左右的集合順序相反！

#### **錯誤 3：忘記方向的原因**

**錯誤思維**：「子集更小，所以所有確界都更小」  
**正確思維**：「子集元素更少，範圍更窄，上確界更低，下確界更高」

### 推廣與應用

#### **推廣 1：區間套的收斂**

若 \(I_1 \supseteq I_2 \supseteq I_3 \supseteq \cdots\) 是遞減的閉區間序列，則：
- 下端點序列 \(a_n = \inf I_n\) 遞增
- 上端點序列 \(b_n = \sup I_n\) 遞減

這是**區間套定理**的基礎！

#### **推廣 2：單調性原理**

對於集合運算，確界滿足：
- **並集**：\(\sup(A \cup B) = \max(\sup A, \sup B)\)
- **交集**：\(A \cap B \subseteq A\) → \(\sup(A \cap B) \leq \sup A\)

#### **推廣 3：測度論**

在測度論中：
- 子集的測度不大於母集的測度
- 這是單調性的推廣

### 練習題

#### **基礎練習**

1. **證明**：若 \(A \subseteq B \subseteq C\)，則 \(\inf C \leq \inf A\)。

2. **計算**：設 \(A = \{-3, -2, -1\}\)，\(B = \{-5, -4, -3, -2, -1, 0\}\)。
   - 計算 \(\inf A\) 和 \(\inf B\)
   - 驗證 \(\inf B \leq \inf A\)

#### **進階練習**

3. **證明**：若 \(A \subseteq B\)，則 \(\sup B - \inf B \geq \sup A - \inf A\)（母集的「寬度」更大）。

4. **Lean 練習**：證明若 \(A \subseteq B\) 且兩者都有上下確界，則 \(\sup A - \inf A \leq \sup B - \inf B\)。

#### **挑戰練習**

5. **反例**：能否找到 \(A \subseteq B\) 使得 \(\inf A = \inf B\) 但 \(A \neq B\)？

6. **推廣**：證明若 \(\{A_n\}\) 是遞減的集合序列（\(A_1 \supseteq A_2 \supseteq \cdots\)），則 \(\{\inf A_n\}\) 是遞增數列。

### 定理 1.21 的完整總結

#### **兩個部分的對照**

| 項目 | 定理 1.21(1) | 定理 1.21(2) |
|-----|-------------|-------------|
| **確界** | 上確界 (\(\sup\)) | 下確界 (\(\inf\)) |
| **不等式** | \(\sup A \leq \sup B\) | \(\inf B \leq \inf A\) |
| **策略** | 用 \(t\) 的最小性 | 用 \(t\) 的最大性 |
| **證明** | \(s\) 是 \(A\) 的上界 | \(s\) 是 \(A\) 的下界 |
| **方向** | 子集的上確界更小 | 子集的下確界更大 |

#### **統一的直覺**

\(A \subseteq B\) 意味著：
- \(A\) 的「範圍」更窄
- 上面的「天花板」更低
- 下面的「地板」更高

#### **在數學中的重要性**

1. **區間套定理**：利用下確界的遞增性
2. **Bolzano-Weierstrass**：利用子序列的確界關係
3. **測度論**：單調性的推廣
4. **優化理論**：可行域縮小時的最優值變化

---

這個定理和定理 1.21(1) 完美對偶，深刻體現了上下確界的對稱性。掌握這兩個定理，特別是**方向相反**的原因，對理解確界概念至關重要！

---

## 定義 1.38：有限集合、可數集合與不可數集合

### 定義陳述

**定義 1.38**：設 \(E\) 為集合。

**i) 有限集合（Finite）**  
\(E\) 稱為**有限的**，當且僅當 \(E = \emptyset\) 或存在 1-1 函數將 \(\{1, 2, \ldots, n\}\) 映射到 \(E\)（對某個 \(n \in \mathbb{N}\)）。

**ii) 可數集合（Countable）**  
\(E\) 稱為**可數的**，當且僅當存在 1-1 函數將 \(\mathbb{N}\) 映射到 \(E\)。

**iii) 至多可數（At most countable）**  
\(E\) 稱為**至多可數的**，當且僅當 \(E\) 是有限的或可數的。

**iv) 不可數集合（Uncountable）**  
\(E\) 稱為**不可數的**，當且僅當 \(E\) 既非有限也非可數。

### 核心思想

這組定義建立了集合大小的層次結構：

```
     有限集合
        ↓
    可數集合（可數無窮）
        ↓
   至多可數集合 = 有限 ∪ 可數
        ↓
    不可數集合
```

**直觀理解**：
- **有限**：可以「數完」（有限個元素）
- **可數**：可以「排成一列」（與自然數一一對應）
- **至多可數**：要麼數得完，要麼排得成一列
- **不可數**：太多了，無法排成一列（比自然數「更多」）

### 重要例子

#### **有限集合**
- \(\{1, 2, 3\}\)
- \([0, 1] \cap \mathbb{Q}\) 的有限子集
- 任何 \(n\) 個元素的集合

#### **可數集合（可數無窮）**
- \(\mathbb{N} = \{1, 2, 3, \ldots\}\)（自然數）
- \(\mathbb{Z} = \{\ldots, -2, -1, 0, 1, 2, \ldots\}\)（整數）
- \(\mathbb{Q}\)（有理數）← 令人驚訝！
- \(\mathbb{N} \times \mathbb{N}\)（自然數對）

#### **不可數集合**
- \(\mathbb{R}\)（實數）← Cantor 對角線論證
- \([0, 1]\)（閉區間）
- \((0, 1)\)（開區間）
- \(\mathbb{R} \setminus \mathbb{Q}\)（無理數）

### Mathlib 中的定義與對應

在 Lean 4 的 Mathlib 中，這些概念已經內建：

#### **Mathlib 定義**

| 概念 | Mathlib 語法 | 意義 |
|------|-------------|------|
| 有限 | `Set.Finite E` | \(E\) 有有限個元素 |
| 可數 | `Set.Countable E` | \(E\) 至多可數（包含有限！） |
| 無限 | `Set.Infinite E` | \(E\) 不是有限的 |
| 不可數 | `¬Set.Countable E` | \(E\) 不是至多可數的 |

#### **Wade 定義與 Mathlib 的對應**

| Wade 術語 | Wade 定義 | Mathlib 表示 |
|-----------|----------|-------------|
| finite | 有限個元素 | `Set.Finite E` |
| countable | 與 ℕ 一一對應 | `Set.Countable E ∧ Set.Infinite E` |
| at most countable | 有限或可數 | `Set.Countable E` |
| uncountable | 非有限且非可數 | `¬Set.Countable E` |

**⚠️ 重要區別**：
- **Wade**：「countable」指可數無窮，不包含有限集合
- **Mathlib**：「Countable」指至多可數，**包含**有限集合

### Lean 4 代碼示例

```lean
-- 導入必要的模組
import Mathlib.Data.Set.Finite
import Mathlib.Data.Set.Countable

-- 示例 1：有限集合
example : Set.Finite ({1, 2, 3} : Set ℝ) := by
   exact Set.finite_insert 1 (Set.finite_insert 2 (Set.finite_singleton 3))

-- 示例 2：自然數集合是可數的
example : Set.Countable (Set.univ : Set ℕ) := Set.countable_univ

-- 示例 3：整數集合是可數的
example : Set.Countable (Set.univ : Set ℤ) := Set.countable_univ

-- 示例 4：實數區間 [0,1] 是不可數的（聲明）
axiom real_interval_uncountable : ¬Set.Countable (Set.Icc (0 : ℝ) 1)

-- 定理：有限集合必定（至多）可數
theorem finite_is_countable {E : Set ℝ} (h : Set.Finite E) : Set.Countable E := 
   Set.Finite.countable h

-- 定理：子集的有限性
theorem subset_finite {A B : Set ℝ} (hAB : A ⊆ B) (hB : Set.Finite B) : Set.Finite A :=
   Set.Finite.subset hB hAB

-- 定理：子集的可數性  
theorem subset_countable {A B : Set ℝ} (hAB : A ⊆ B) (hB : Set.Countable B) : Set.Countable A :=
   Set.Countable.mono hAB hB

-- 定理：有限集合的並集仍是有限的
theorem finite_union {A B : Set ℝ} (hA : Set.Finite A) (hB : Set.Finite B) : 
   Set.Finite (A ∪ B) := 
   Set.Finite.union hA hB

-- 定理：可數集合的並集仍是可數的
theorem countable_union {A B : Set ℝ} (hA : Set.Countable A) (hB : Set.Countable B) : 
   Set.Countable (A ∪ B) := 
   Set.Countable.union hA hB

-- 定理：可數多個可數集合的並集仍是可數的
theorem countable_Union_of_countable {ι : Type*} [Countable ι] {f : ι → Set ℝ} 
   (h : ∀ i, Set.Countable (f i)) : Set.Countable (⋃ i, f i) := 
   Set.countable_iUnion h
```

### 關鍵定理

#### **定理 1：有限性的性質**

1. **子集保持有限性**：若 \(A \subseteq B\) 且 \(B\) 有限，則 \(A\) 有限
2. **並集保持有限性**：若 \(A, B\) 有限，則 \(A \cup B\) 有限
3. **有限集合必定至多可數**：有限 ⇒ 至多可數

#### **定理 2：可數性的性質**

1. **子集保持可數性**：若 \(A \subseteq B\) 且 \(B\) 至多可數，則 \(A\) 至多可數
2. **並集保持可數性**：若 \(A, B\) 至多可數，則 \(A \cup B\) 至多可數
3. **可數並保持可數性**：可數多個至多可數集合的並集仍至多可數

#### **定理 3：有理數是可數的**

**定理**：\(\mathbb{Q}\) 是可數的。

**證明思路**（Cantor 對角線排列）：
```
1/1  1/2  1/3  1/4  1/5  ...
 ↓   ↗    ↓
2/1  2/2  2/3  2/4  ...
     ↓   ↗
3/1  3/2  3/3  ...
         ↓
4/1  4/2  ...
```

按照之字形路徑遍歷，跳過重複的分數，得到：
\[
\mathbb{Q}^+ = \{1/1, 2/1, 1/2, 1/3, 3/1, 4/1, 3/2, 2/3, \ldots\}
\]

#### **定理 4：實數是不可數的**

**定理**（Cantor）：\(\mathbb{R}\) 是不可數的。

**證明思路**（對角線論證）：
假設 \([0,1]\) 可數，可以排成列表：
```
x₁ = 0.a₁₁ a₁₂ a₁₃ a₁₄ ...
x₂ = 0.a₂₁ a₂₂ a₂₃ a₂₄ ...
x₃ = 0.a₃₁ a₃₂ a₃₃ a₃₄ ...
x₄ = 0.a₄₁ a₄₂ a₄₃ a₄₄ ...
```

構造新數 \(y = 0.b₁b₂b₃b₄\ldots\)，其中 \(b_i \neq a_{ii}\)。

則 \(y \in [0,1]\) 但 \(y\) 不在列表中（與每個 \(x_i\) 至少有一位不同）。

矛盾！所以 \([0,1]\) 不可數。

### 重要性質對照表

| 性質 | 有限 | 可數無窮 | 不可數 |
|------|------|---------|--------|
| **元素個數** | 有限個 | 無限個 | 無限個 |
| **可排序** | 是 | 是 | 否 |
| **與 ℕ 關係** | 可映射 | 一一對應 | 無一一對應 |
| **子集** | 保持有限 | 保持可數 | 可能可數 |
| **可數並** | 有限 | 可數 | 可能不可數 |
| **例子** | \(\{1,2,3\}\) | \(\mathbb{N}, \mathbb{Q}\) | \(\mathbb{R}\) |

### 常見錯誤與陷阱

#### **錯誤 1：混淆 Wade 和 Mathlib 的 "countable"**

❌ **錯誤**：在 Mathlib 中，`Set.Countable` 不包含有限集合  
✅ **正確**：Mathlib 的 `Set.Countable` **包含**有限集合

#### **錯誤 2：以為「無窮」就是「不可數」**

❌ **錯誤**：\(\mathbb{N}\) 是無窮的，所以不可數  
✅ **正確**：\(\mathbb{N}\) 是無窮的，但是可數的（可數無窮）

#### **錯誤 3：直覺判斷可數性**

❌ **錯誤**：\(\mathbb{Q}\) 在數線上很「密」，所以不可數  
✅ **正確**：\(\mathbb{Q}\) 雖然稠密，但仍是可數的

#### **錯誤 4：可數並的誤解**

❌ **錯誤**：不可數個可數集合的並集仍可數  
✅ **正確**：**可數**個可數集合的並集才可數

### 應用與推廣

#### **應用 1：測度論**

在測度論中：
- 可數集合的 Lebesgue 測度為 0
- \(\mathbb{Q}\) 的測度為 0（雖然稠密！）
- \([0,1]\) 的測度為 1

#### **應用 2：拓撲學**

- 可數集合的拓撲性質（第一可數、第二可數）
- 不可數離散空間不可度量化

#### **應用 3：實分析**

- 幾乎處處（almost everywhere）的概念
- Lebesgue 積分與 Riemann 積分的差異

#### **應用 4：集合論**

- 不同的無窮大：\(|\mathbb{N}| = \aleph_0 < |\mathbb{R}| = 2^{\aleph_0}\)
- 連續統假設：是否存在集合 \(S\) 使得 \(|\mathbb{N}| < |S| < |\mathbb{R}|\)？

### 練習題

#### **基礎練習**

1. **證明**：任何有限集合的子集仍是有限的。

2. **證明**：兩個可數集合的笛卡爾積 \(\mathbb{N} \times \mathbb{N}\) 是可數的。

3. **判斷**：以下集合哪些是可數的？
   - \(\{n^2 : n \in \mathbb{N}\}\)
   - \(\{1/n : n \in \mathbb{N}\}\)
   - \(\{\sqrt{n} : n \in \mathbb{N}\}\)

#### **進階練習**

4. **證明**：有限多個可數集合的並集是可數的。

5. **證明**：\(\mathbb{Z}\)（整數集）是可數的。（提示：排列為 \(0, 1, -1, 2, -2, \ldots\)）

6. **證明**：所有有限長度的二進制字符串的集合是可數的。

#### **挑戰練習**

7. **證明**：\(\mathbb{Q}\)（有理數）是可數的。（使用對角線排列）

8. **證明**：開區間 \((0, 1)\) 是不可數的。

9. **證明**：若 \(A\) 可數，\(B\) 不可數，則 \(B \setminus A\) 不可數。

10. **Lean 練習**：在 Lean 中證明兩個有限集合的並集是有限的。

### 歷史註記

#### **Cantor 的革命性發現**

Georg Cantor（康托，1845-1918）在 19 世紀末發現：
1. **無窮有不同的大小**（1874）
2. **實數不可數**（1891，對角線論證）
3. **建立了集合論的基礎**

這些發現在當時引起巨大爭議，但最終成為現代數學的基石。

#### **對角線論證的影響**

Cantor 的對角線論證成為：
- **停機問題不可判定**（圖靈）
- **哥德爾不完備定理**
- 許多不可能性證明的模板

### 延伸閱讀

1. **集合論基礎**
   - Cantor 定理：\(|S| < |P(S)|\)（冪集總是更大）
   - 基數算術：\(\aleph_0 + \aleph_0 = \aleph_0\)

2. **實分析中的應用**
   - Baire 綱定理
   - 不可數與完備性

3. **拓撲學**
   - 可數性公理
   - Lindelöf 空間

4. **測度論**
   - 零測集
   - Lebesgue 測度的可數可加性

---

這個定義揭示了無窮的層次結構，是實分析和集合論的基礎概念。Mathlib 提供了完整的形式化框架，讓我們能夠嚴格證明關於可數性的定理。

---

## 第 2 章補充：數列的有界性（定義 2.7）與「收斂 ⇒ 有界」（定理 2.8）

### 定義 2.7：數列的有界性

令 \(\{x_n\}\) 為實數數列。把數列的值域寫成集合：
\[
\mathrm{range}(x) := \{x_n : n \in \mathbb{N}\}.
\]

**(i) 上方有界**：\(\{x_n\}\) 上方有界 \(\Longleftrightarrow \mathrm{range}(x)\) 上方有界。  
**(ii) 下方有界**：\(\{x_n\}\) 下方有界 \(\Longleftrightarrow \mathrm{range}(x)\) 下方有界。  
**(iii) 有界**：\(\{x_n\}\) 有界 \(\Longleftrightarrow\) 同時上方有界且下方有界。

在本專案（`Analysis/Basic.lean`）中，我們直接用集合的有界性來定義數列有界：

```lean
def seq_bounded_above (x : ℕ → ℝ) : Prop :=
  bounded_above (Set.range x)

def seq_bounded_below (x : ℕ → ℝ) : Prop :=
  bounded_below (Set.range x)

def seq_bounded (x : ℕ → ℝ) : Prop :=
  bounded (Set.range x)
```

### 定理 2.8：每個收斂數列都是有界的

**定理 2.8**：若 \(x_n \to a\)，則 \(\{x_n\}\) 有界。

**數學證明主線**（對應 Lean 證明的結構）：
- 取 \(\varepsilon = 1\)。由收斂得存在 \(N\)，使得 \(n \ge N \Rightarrow |x_n-a|<1\)。因此尾部滿足
  \[
  a-1 \le x_n \le a+1 \quad (n \ge N).
  \]
- 頭部 \(\{x_0,\dots,x_{N-1}\}\) 是有限集合，所以一定有上下界。
- 取「尾部界」與「頭部界」做 max/min，即可得到整個數列的上界與下界。

### 完整數學證明（可逐行對照 Lean）

要證明「\(\{x_n\}\) 有界」，等價於同時證明：
\[
\exists M,\ \forall n,\ x_n \le M
\quad\text{以及}\quad
\exists m,\ \forall n,\ m \le x_n.
\]

#### Step 1：取 \(\varepsilon=1\)，得到尾部被夾住

由 \(x_n \to a\)，對 \(\varepsilon=1>0\)，存在 \(N\in\mathbb N\) 使得
\[
n\ge N \Longrightarrow |x_n-a|<1.
\]
而 \(|x_n-a|<1\) 等價於
\[
-1 < x_n-a < 1,
\]
因此當 \(n\ge N\) 時：
\[
a-1 < x_n < a+1.
\]
特別地，我們會用到較弱但更方便的版本：
\[
n\ge N \Longrightarrow x_n \le a+1,
\qquad
n\ge N \Longrightarrow a-1 \le x_n.
\]

#### Step 2：頭部有限項一定有上下界

考慮有限集合（頭部）
\[
H := \{x_0,x_1,\dots,x_{N-1}\}.
\]
因為 \(H\) 是有限集合，所以存在實數 \(M_{\text{head}}\) 與 \(m_{\text{head}}\) 使得：
\[
\forall k\in\{0,\dots,N-1\},\quad x_k \le M_{\text{head}},
\]
\[
\forall k\in\{0,\dots,N-1\},\quad m_{\text{head}} \le x_k.
\]
（這一步在 Lean 用 `Finset.image x (Finset.range N)`，再用 `max'` / `min'` 取得上下界。）

#### Step 3：合併頭尾界，得到整體上界

令
\[
M := \max(a+1,\ M_{\text{head}}).
\]
對任意 \(n\)：
- 若 \(n\ge N\)，由 Step 1 得 \(x_n\le a+1\le M\)。
- 若 \(n<N\)，則 \(x_n\in H\)，由 Step 2 得 \(x_n\le M_{\text{head}}\le M\)。

因此 \(\forall n,\ x_n \le M\)，上方有界成立。

#### Step 4：合併頭尾界，得到整體下界

令
\[
m := \min(a-1,\ m_{\text{head}}).
\]
對任意 \(n\)：
- 若 \(n\ge N\)，由 Step 1 得 \(a-1\le x_n\) 且 \(m\le a-1\)，所以 \(m\le x_n\)。
- 若 \(n<N\)，則 \(x_n\in H\)，由 Step 2 得 \(m_{\text{head}}\le x_n\) 且 \(m\le m_{\text{head}}\)，所以 \(m\le x_n\)。

因此 \(\forall n,\ m \le x_n\)，下方有界成立。

#### 結論

同時得到上方有界與下方有界，所以 \(\{x_n\}\) 有界，證畢。

### Lean 4 證明（行尾註解風格）

```lean
def converge_to (x : ℕ → ℝ) (a : ℝ) : Prop :=  -- xₙ → a
  ∀ ε > 0, ∃ N : ℕ, ∀ n : ℕ, n ≥ N → |x n - a| < ε  -- ε–N 定義

lemma finite_set_has_upper_bound (s : Finset ℝ) (hs : s.Nonempty) :  -- s 非空
    ∃ M, ∀ x ∈ s, x ≤ M := by  -- 存在 M 使得 ∀ x ∈ s, x ≤ M
  use s.max' hs  -- 取 M = s 的最大元素
  intro x hx  -- 任取 x ∈ s
  exact Finset.le_max' s x hx  -- 由 max' 的性質得 x ≤ max'

theorem Theorem_2_8 (x : ℕ → ℝ) (a : ℝ) (h : converge_to x a) : seq_bounded x := by
   unfold seq_bounded bounded bounded_above bounded_below  -- 展開定義
   constructor  -- 上方有界 / 下方有界
   {
      obtain ⟨N, hN⟩ := h 1 (by norm_num : (0 : ℝ) < 1)  -- 取 ε = 1
      have h_tail : ∀ n ≥ N, x n ≤ a + 1 := by  -- 尾部上界
        intro n hn
        have h_conv : |x n - a| < 1 := hN n hn
        have h_parts := abs_sub_lt_iff.mp h_conv
        linarith
      by_cases h_case : N = 0
      · use a + 1
        intro y hy
        obtain ⟨n, rfl⟩ := hy
        have : n ≥ N := by simp [h_case]
        exact h_tail n this
      · let head_set := Finset.image x (Finset.range N)  -- 頭部有限集合
        have h_nonempty : head_set.Nonempty := by
          use x 0
          simp [head_set]
          use 0
          constructor
          · exact Nat.pos_of_ne_zero h_case
          · rfl
        obtain ⟨M_head, hM_head⟩ := finite_set_has_upper_bound head_set h_nonempty
        use max (a + 1) M_head  -- 合併頭尾界
        intro y hy
        obtain ⟨n, rfl⟩ := hy
        rcases lt_or_ge n N with hn | hn
        · have h_in : x n ∈ head_set := by
            simp [head_set]
            refine ⟨n, hn, rfl⟩
          exact le_trans (hM_head (x n) h_in) (le_max_right (a + 1) M_head)
        · exact le_trans (h_tail n hn) (le_max_left (a + 1) M_head)
   }
   {
      obtain ⟨N, hN⟩ := h 1 (by norm_num : (0 : ℝ) < 1)  -- 取 ε = 1
      have h_tail : ∀ n ≥ N, a - 1 ≤ x n := by  -- 尾部下界
        intro n hn
        have h_conv : |x n - a| < 1 := hN n hn
        have h_parts := abs_sub_lt_iff.mp h_conv
        linarith
      by_cases h_case : N = 0
      · use a - 1
        intro y hy
        obtain ⟨n, rfl⟩ := hy
        have : n ≥ N := by simp [h_case]
        exact h_tail n this
      · let head_set := Finset.image x (Finset.range N)
        have h_nonempty : head_set.Nonempty := by
          use x 0
          simp [head_set]
          use 0
          constructor
          · exact Nat.pos_of_ne_zero h_case
          · rfl
        have h_has_min : ∃ m, ∀ x_val ∈ head_set, m ≤ x_val := by
          use head_set.min' h_nonempty
          intro x_val hx
          exact Finset.min'_le head_set x_val hx
        obtain ⟨m_head, hm_head⟩ := h_has_min
        use min (a - 1) m_head  -- 合併頭尾界
        intro y hy
        obtain ⟨n, rfl⟩ := hy
        rcases lt_or_ge n N with hn | hn
        · have h_in : x n ∈ head_set := by
            simp [head_set]
            refine ⟨n, hn, rfl⟩
          exact le_trans (min_le_right (a - 1) m_head) (hm_head (x n) h_in)
        · exact le_trans (min_le_left (a - 1) m_head) (h_tail n hn)
   }
```

### Lean 語法與證明手法詳解（對照上面程式）

這裡把定理 2.8 用到的 **Lean 語法** 與 **證明策略**逐一拆開說明；你之後看到類似的「收斂 ⇒ 有界」都可以照這個模板做。

#### 1) 定義與展開：`def` / `unfold`

- **`def converge_to ... : Prop := ...`**：定義命題（`Prop`），把 ε–N 定義直接翻譯成 Lean。
- **`unfold seq_bounded bounded bounded_above bounded_below`**：把目標中的自定義符號展開成定義。
  - **效果**：把 `seq_bounded x` 變成 `bounded_above (Set.range x) ∧ bounded_below (Set.range x)`。

#### 2) 合取拆目標：`constructor`

- **`constructor`**：當目標是 `P ∧ Q`（或 `P ↔ Q`）時，把證明拆成兩個子目標。
  - 在本定理：第一塊 `{ ... }` 證明上方有界，第二塊 `{ ... }` 證明下方有界。

#### 3) 存在量詞：`obtain ⟨..., ...⟩ := ...` / `use`

- **`obtain ⟨N, hN⟩ := h 1 ...`**：從「存在某個 N」取出見證 `N` 與尾部估計 `hN`。
- **`use M`**：當目標是 `∃ M, ...` 時先給出候選 `M`，剩下證明它真的是界。

#### 4) 全稱量詞：`intro`

- **`intro n hn`**：把 `∀ n` 或 `n ≥ N → ...` 的變數與前提引入上下文。

#### 5) `Set.range`：把集合元素改寫成序列項

- `hy : y ∈ Set.range x` 表示「存在某個 n，使得 y = x n」。
- **`obtain ⟨n, rfl⟩ := hy`**：把 `y` 改寫成 `x n`，之後只需估計 `x n`。

#### 6) 取 ε = 1：把收斂轉成尾部夾住

- **`obtain ⟨N, hN⟩ := h 1 (by norm_num : (0:ℝ) < 1)`**：
  - 得到 `hN : ∀ n ≥ N, |x n - a| < 1`。

#### 7) 絕對值估計：`abs_sub_lt_iff` + `linarith`

- **`abs_sub_lt_iff.mp h_conv`**：把 `|x n - a| < 1` 拆成線性不等式 `x n - a < 1 ∧ a - x n < 1`。
- **`linarith`**：自動解線性不等式；例如推出 `x n ≤ a + 1` 與 `a - 1 ≤ x n`。

#### 8) 分情況：`by_cases` / `rcases lt_or_ge ... with ... | ...`

- **`by_cases h_case : N = 0`**：
  - `N = 0`：頭部為空，整個序列都屬於尾部，直接用尾部界。
  - `N ≠ 0`：需要處理有限頭部 `{x 0, ..., x (N-1)}`。
- **`rcases lt_or_ge n N with hn | hn`**：把索引 `n` 分成 `n < N`（頭部）或 `n ≥ N`（尾部）。

#### 9) 有限頭部：`Finset.range` / `Finset.image` / `max'` / `min'`

- **`Finset.range N`**：有限索引集合 `{0,1,...,N-1}`。
- **`Finset.image x (Finset.range N)`**：把頭部索引映到數列上，得到頭部有限值集合。
- **`max'` / `min'`**：在 `Finset` 上取最大/最小值（需要 `Nonempty`）。

#### 10) 合併頭尾界：`max` / `min` + `le_trans`

- 上界取 `max (a + 1) M_head`、下界取 `min (a - 1) m_head`。
- **`le_trans`**：把 `p ≤ q` 與 `q ≤ r` 串成 `p ≤ r`。

#### 11) `simp` / `refine`（穩定手打的關鍵）

- **`simp [h_case]`**：在 `N = 0` 分支，把 `n ≥ N` 化成 `n ≥ 0`。
- **`refine ⟨n, hn, rfl⟩`**：一次塞入存在見證與證據，避免 tactic 狀態卡住。

### 一句話模板

**收斂 ⇒ 有界**：取 ε=1 得尾部夾住；把前 N 項做成 `Finset` 取 `max'/min'`；用 `max/min` 合併頭尾界。

---

## 定理 2.9(i)：夾擠定理（Squeeze Theorem）

### 定理敘述

設 \(\{x_n\}, \{y_n\}, \{w_n\}\) 為實數數列，且存在同一個 \(a \in \mathbb{R}\) 使得：
- \(x_n \to a\)
- \(y_n \to a\)
- 並且存在 \(N_0\in\mathbb{N}\) 使得對所有 \(n \ge N_0\)，有
  \[
  x_n \le w_n \le y_n.
  \]

則 \(w_n \to a\)。

### 完整數學證明（逐步）

要證 \(w_n \to a\)，依 ε–N 定義，只要證明：
\[
\forall \varepsilon>0,\ \exists N,\ \forall n\ge N,\ |w_n-a|<\varepsilon.
\]

取任意 \(\varepsilon>0\)。

1. 由 \(x_n \to a\)，存在 \(N_x\) 使得 \(n \ge N_x \Rightarrow |x_n-a|<\varepsilon\)。
2. 由 \(y_n \to a\)，存在 \(N_y\) 使得 \(n \ge N_y \Rightarrow |y_n-a|<\varepsilon\)。
3. 由夾擠條件，存在 \(N_0\) 使得 \(n \ge N_0 \Rightarrow x_n \le w_n \le y_n\)。

令
\[
N := \max(\max(N_x,N_y),N_0).
\]
則對任意 \(n \ge N\)，同時有 \(n \ge N_x\)、\(n \ge N_y\)、\(n \ge N_0\)。

因此：
- 由 \(|y_n-a|<\varepsilon\) 可推出 \(y_n-a<\varepsilon\)；
  又 \(w_n\le y_n\) 得 \(w_n-a \le y_n-a\)，所以
  \[
  w_n-a < \varepsilon.
  \]
- 由 \(|x_n-a|<\varepsilon\) 可推出 \(a-x_n<\varepsilon\)；
  又 \(x_n\le w_n\) 得 \(a-w_n \le a-x_n\)，所以
  \[
  a-w_n < \varepsilon.
  \]

兩式合併即得：
\[
|w_n-a|<\varepsilon.
\]
因此 \(w_n \to a\)，證畢。

### Lean 證明（行尾註解風格）

```lean
theorem Theorem_2_9_i (x y w : ℕ → ℝ) (a : ℝ)
   (hx : converge_to x a) (hy : converge_to y a)  -- 假設：xₙ → a 且 yₙ → a
   (hxy : ∃ N₀ : ℕ, ∀ (n : ℕ), n ≥ N₀ → x n ≤ w n ∧ w n ≤ y n) :  -- 假設：存在 N₀，使得 n ≥ N₀ 時 xₙ ≤ wₙ ≤ yₙ
   converge_to w a := by  -- 目標：wₙ → a
   unfold converge_to  -- 展開收斂定義：∀ ε > 0, ∃ N, ∀ n ≥ N, |w n - a| < ε
   intro ε hε  -- 任取 ε > 0
   obtain ⟨Nx, hNx⟩ := hx ε hε  -- 由 xₙ → a 得到 Nx：n ≥ Nx ⇒ |x n - a| < ε
   obtain ⟨Ny, hNy⟩ := hy ε hε  -- 由 yₙ → a 得到 Ny：n ≥ Ny ⇒ |y n - a| < ε
   obtain ⟨N₀, hN₀⟩ := hxy  -- 由夾擠條件取出 N₀：n ≥ N₀ ⇒ x n ≤ w n ∧ w n ≤ y n
   refine ⟨max (max Nx Ny) N₀, ?_⟩  -- 取 N = max(max Nx Ny) N₀
   intro n hn  -- 任取 n ≥ N
   have hn_max : n ≥ max Nx Ny := le_trans (le_max_left _ _) hn  -- 得 n ≥ max Nx Ny
   have hnNx : n ≥ Nx := le_trans (le_max_left _ _) hn_max  -- 得 n ≥ Nx
   have hnNy : n ≥ Ny := le_trans (le_max_right _ _) hn_max  -- 得 n ≥ Ny
   have hnN₀ : n ≥ N₀ := le_trans (le_max_right _ _) hn  -- 得 n ≥ N₀
   have hw : x n ≤ w n ∧ w n ≤ y n := hN₀ n hnN₀  -- 得 x n ≤ w n 且 w n ≤ y n
   apply (abs_sub_lt_iff).2  -- 將 |w n - a| < ε 改寫成 (w n - a < ε) ∧ (a - w n < ε)
   constructor  -- 分成兩個不等式
   {
      have hy_abs : |y n - a| < ε := hNy n hnNy  -- |y n - a| < ε
      have hy_lt : y n - a < ε := (abs_sub_lt_iff.mp hy_abs).1  -- 取出 y n - a < ε
      have hw_le : w n - a ≤ y n - a := sub_le_sub_right hw.2 a  -- 由 w n ≤ y n 推出 w n - a ≤ y n - a
      exact lt_of_le_of_lt hw_le hy_lt  -- 串接得到 w n - a < ε
   }
   {
      have hx_abs : |x n - a| < ε := hNx n hnNx  -- |x n - a| < ε
      have hx_lt : a - x n < ε := (abs_sub_lt_iff.mp hx_abs).2  -- 取出 a - x n < ε
      have hw_ge : a - w n ≤ a - x n := sub_le_sub_left hw.1 a  -- 由 x n ≤ w n 推出 a - w n ≤ a - x n
      exact lt_of_le_of_lt hw_ge hx_lt  -- 串接得到 a - w n < ε
   }
```

### Lean 手法拆解（更細）

- **核心策略**：先定義 \(N = \max(\max N_x N_y) N_0\)，確保一次取得三個「門檻」。
- **`obtain ⟨Nx, hNx⟩ := hx ε hε`**：把收斂的「∃N」拆出見證與尾部估計。
- **`have hn_max ...`**：用 `le_trans` + `le_max_left/right` 把 `n ≥ max(...)` 拆成 `n ≥ Nx`、`n ≥ Ny`、`n ≥ N₀`。
- **`abs_sub_lt_iff`**：
  - `abs_sub_lt_iff.mp`：把 `|t-a|<ε` 拆成兩個方向不等式。
  - `abs_sub_lt_iff.mpr` / `(abs_sub_lt_iff).2`：把兩個方向不等式合成 `|t-a|<ε`。
- **`sub_le_sub_right` / `sub_le_sub_left`**：
  - `w ≤ y` ⇒ `w - a ≤ y - a`
  - `x ≤ w` ⇒ `a - w ≤ a - x`
- **`lt_of_le_of_lt`**：把「≤」和「<」串起來得到「<」。

---

## 定理 2.9(ii)：收斂到 0 的數列乘上有界數列仍收斂到 0

### 定理敘述

若 \(x_n \to 0\) 且 \(\{y_n\}\) 有界，則
\[
x_n y_n \to 0.
\]

### 完整數學證明（逐步，ε–N）

因為 \(\{y_n\}\) 有界，存在 \(B \ge 0\) 使得對所有 \(n\)，有
\[
|y_n| \le B.
\]

要證 \(x_n y_n \to 0\)，取任意 \(\varepsilon > 0\)。由 \(x_n \to 0\)，對
\[
\delta := \frac{\varepsilon}{B+1} > 0
\]
存在 \(N\) 使得 \(n \ge N \Rightarrow |x_n| < \delta\)。

因此當 \(n \ge N\) 時：
\[
|x_n y_n| = |x_n|\,|y_n| \le |x_n|\,B < \frac{\varepsilon}{B+1}\,B \le \varepsilon.
\]

所以 \(\forall \varepsilon>0\)，存在 \(N\) 使得 \(n\ge N \Rightarrow |x_n y_n|<\varepsilon\)，故 \(x_n y_n \to 0\)，證畢。

> 為什麼用 \(B+1\) 而不是 \(B\)？  
> 因為可能 \(B=0\)，用 \(B+1\) 可以保證分母正且不為 0，避免分母為 0 的特殊討論。

### Lean 證明（行尾註解風格）

```lean
theorem Theorem_2_9_ii (x y : ℕ → ℝ) (h : converge_to x 0) (hy : seq_bounded y) :
   converge_to (fun n => x n * y n) 0 := by  -- 目標：xₙ → 0 且 y 有界 ⇒ (xₙ*yₙ) → 0
      unfold converge_to  -- 展開收斂定義
      intro ε hε  -- 任取 ε > 0
      have hy' : bounded (Set.range y) := by
         -- seq_bounded y 的定義就是 bounded (Set.range y)
         simpa [seq_bounded] using hy
      have hy_above : bounded_above (Set.range y) := hy'.1  -- y 的值域有上界
      have hy_below : bounded_below (Set.range y) := hy'.2  -- y 的值域有下界
      obtain ⟨U, hU⟩ := hy_above  -- 取上界 U：∀ z ∈ range y, z ≤ U
      obtain ⟨L, hL⟩ := hy_below  -- 取下界 L：∀ z ∈ range y, L ≤ z
      -- 定義 B，並證明 ∀ n, |y n| ≤ B
      let B : ℝ := max |L| |U|  -- 取 B = max(|L|,|U|)，用來控制 |y n|
      have hB0 : 0 ≤ B := by
         have : 0 ≤ |L| := abs_nonneg L
         exact le_trans this (le_max_left _ _)
      have h_abs_y : ∀ n : ℕ, |y n| ≤ B := by
         intro n
         have hyU : y n ≤ U := hU (y n) ⟨n, rfl⟩  -- 由上界性質得 y n ≤ U
         have hyL : L ≤ y n := hL (y n) ⟨n, rfl⟩  -- 由下界性質得 L ≤ y n
         have hy_le_B : y n ≤ B := by
            have : y n ≤ |U| := le_trans hyU (le_abs_self U)
            exact le_trans this (le_max_right _ _)
         have hnegB_le_y : -B ≤ y n := by
            have : - |L| ≤ L := neg_abs_le L
            have h1 : - |L| ≤ y n := le_trans this hyL
            have h2 : - B ≤ - |L| := by
               have : |L| ≤ B := le_max_left _ _
               exact neg_le_neg this
            exact le_trans h2 h1
         have : -B ≤ y n ∧ y n ≤ B := ⟨hnegB_le_y, hy_le_B⟩
         exact (abs_le).2 this  -- 由 -B ≤ y n ≤ B 得 |y n| ≤ B
      have hB1_pos : 0 < B + 1 := by linarith [hB0]  -- B ≥ 0 ⇒ B+1 > 0
      obtain ⟨N, hN⟩ := h (ε / (B + 1)) (by exact div_pos hε hB1_pos)  -- 用 ε/(B+1) 套用 xₙ → 0，得到 N
      refine ⟨N, ?_⟩  -- 取這個 N 作為收斂到 0 的門檻
      intro n hn  -- 任取 n ≥ N
      have hx_small : |x n| < ε / (B + 1) := by
         simpa [sub_zero] using hN n hn  -- 由 |x n - 0| < ε/(B+1) 得 |x n| < ε/(B+1)
      have hy_bd : |y n| ≤ B := h_abs_y n  -- 由有界性得 |y n| ≤ B
      -- 目標：|x n * y n - 0| < ε
      have h_mul_abs : |x n * y n| < ε := by
         have hmul : |x n * y n| = |x n| * |y n| := by
            simp [abs_mul]
         have h1 : |x n| * |y n| ≤ |x n| * B :=
            mul_le_mul_of_nonneg_left hy_bd (abs_nonneg (x n))
         have hB_le : B ≤ B + 1 := by linarith
         have h2 : |x n| * B ≤ |x n| * (B + 1) :=
            mul_le_mul_of_nonneg_left hB_le (abs_nonneg (x n))
         have hne : (B + 1) ≠ 0 := ne_of_gt hB1_pos
         have hx_mul : |x n| * (B + 1) < ε := by
            have htmp := (mul_lt_mul_of_pos_right hx_small hB1_pos)
            have hR : (ε / (B + 1)) * (B + 1) = ε := by
               field_simp [hne]
            simpa [hR] using htmp
         have : |x n| * |y n| < ε := lt_of_le_of_lt (le_trans h1 h2) hx_mul
         simpa [hmul] using this
      simpa [sub_zero] using h_mul_abs  -- |x n * y n - 0| = |x n * y n|
```

### Lean 手法拆解（重點）

- **把「有界」轉成可用的上下界**：`seq_bounded y` 展開成 `bounded (range y)`，再拆成上界 `U` 與下界 `L`。
- **用 `B := max |L| |U|` 控制絕對值**：先證 `-B ≤ y n ≤ B`，再用 `(abs_le).2` 得 `|y n| ≤ B`。
- **選擇 \(\delta = \varepsilon/(B+1)\)**：確保分母正且非 0（`hB1_pos`、`hne`）。
- **乘法界**：
  - `abs_mul`：`|x*y| = |x|*|y|`
  - `mul_le_mul_of_nonneg_left`：用 `|y n| ≤ B` 推 `|x|*|y| ≤ |x|*B`
  - `mul_lt_mul_of_pos_right`：把 `|x| < ε/(B+1)` 乘上正數 `B+1`
  - `field_simp [hne]`：化簡 `(ε/(B+1))*(B+1)=ε`

## 後續練習題

（此處將添加更多第一章的練習題）
