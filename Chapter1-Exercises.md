# 第一章：實數系統 練習題

這份教材包含第一章的練習題，每題都附有詳細的證明步驟和說明。

---

## 體公設與順序公設語法說明

在進行練習題之前，我們需要先了解實數系統的基本公設及其在 Lean 中的語法表達。實數滿足有序域（Ordered Field）的所有公理，這些公理構成了我們證明所有定理的基礎。

### 一、體公設（Field Axioms）

體公設定義了實數的加法、乘法和它們之間的關係。

#### 1. 加法公理

**公設 1.1：加法交換律（Additive Commutativity）**
- **語法**：`∀ a b : ℝ, a + b = b + a`
- **說明**：`∀ a b : ℝ` 是 `∀ a : ℝ, ∀ b : ℝ` 的簡寫
- **Lean 定理**：`add_comm`
- **完整語法範例**：`example (a b : ℝ) : a + b = b + a := add_comm a b`

**公設 1.2：加法結合律（Additive Associativity）**
- **語法**：`∀ a b c : ℝ, (a + b) + c = a + (b + c)`
- **說明**：括號表示運算順序，無論先加哪兩個，結果都相同
- **Lean 定理**：`add_assoc`
- **完整語法範例**：`example (a b c : ℝ) : (a + b) + c = a + (b + c) := add_assoc a b c`

**公設 1.3：加法單位元（零元）（Additive Identity）**
- **語法**：`∀ a : ℝ, a + 0 = a` 和 `∀ a : ℝ, 0 + a = a`
- **說明**：`0 : ℝ` 表示實數零，零是加法的單位元
- **Lean 定理**：`add_zero : a + 0 = a` 和 `zero_add : 0 + a = a`

**公設 1.4：加法逆元（負元）（Additive Inverse）**
- **語法**：`∀ a : ℝ, a + (-a) = 0` 和 `∀ a : ℝ, (-a) + a = 0`
- **說明**：`-a` 表示 a 的加法逆元（負數），每個數都有加法逆元
- **Lean 定理**：`add_neg_cancel : a + (-a) = 0` 和 `neg_add_cancel : (-a) + a = 0`

#### 2. 乘法公理

**公設 2.1：乘法交換律（Multiplicative Commutativity）**
- **語法**：`∀ a b : ℝ, a * b = b * a`
- **Lean 定理**：`mul_comm`

**公設 2.2：乘法結合律（Multiplicative Associativity）**
- **語法**：`∀ a b c : ℝ, (a * b) * c = a * (b * c)`
- **Lean 定理**：`mul_assoc`

**公設 2.3：乘法單位元（Multiplicative Identity）**
- **語法**：`∀ a : ℝ, a * 1 = a` 和 `∀ a : ℝ, 1 * a = a`
- **說明**：`1 : ℝ` 表示實數一，一是乘法的單位元
- **Lean 定理**：`mul_one : a * 1 = a` 和 `one_mul : 1 * a = a`

**公設 2.4：乘法逆元（倒數，對非零元）（Multiplicative Inverse）**
- **語法**：`∀ a : ℝ, a ≠ 0 → a * a⁻¹ = 1`
- **說明**：
  - `a⁻¹` 或 `1 / a` 表示 a 的乘法逆元（倒數）
  - `a ≠ 0` 表示 a 不等於零
  - `→` 表示蘊含（implies），這裡表示"如果 a ≠ 0，則..."
- **Lean 定理**：`mul_inv_cancel`（透過類型類解析自動應用）
- **注意**：`a / a = 1` 等價於 `a * a⁻¹ = 1`，因為 `a / a = a * a⁻¹`

#### 3. 分配律（Distributivity）

**公設 3.1：左分配律**
- **語法**：`∀ a b c : ℝ, a * (b + c) = a * b + a * c`
- **Lean 定理**：`mul_add`

**公設 3.2：右分配律**
- **語法**：`∀ a b c : ℝ, (a + b) * c = a * c + b * c`
- **Lean 定理**：`add_mul`

### 二、順序公設（Order Axioms）

順序公設定義了實數之間的大小關係。

**公設 4.1：全序性（Total Order）**
- **語法**：`∀ a b : ℝ, a ≤ b ∨ b ≤ a`
- **說明**：
  - `≤` 表示小於等於關係
  - `∨` 表示邏輯或（or）
  - 表示任意兩個實數都可以比較大小
- **Lean 定理**：`le_total`

**公設 4.2：傳遞性（Transitivity）**
- **語法**：`∀ a b c : ℝ, a ≤ b → b ≤ c → a ≤ c`
- **說明**：`→` 表示蘊含，可以鏈式使用。如果 a ≤ b 且 b ≤ c，則 a ≤ c
- **Lean 定理**：`le_trans`

**公設 4.3：反身性（Reflexivity）**
- **語法**：`∀ a : ℝ, a ≤ a`
- **說明**：每個數都小於等於自己
- **Lean 定理**：`le_refl`

**公設 4.4：加法保序（Order Preservation under Addition）**
- **語法**：`∀ a b c : ℝ, a ≤ b → a + c ≤ b + c`
- **說明**：如果 a ≤ b，則兩邊同時加 c 後仍保持 ≤
- **Lean 定理**：`add_le_add_right`

**公設 4.5：乘法保序（正數）（Order Preservation under Multiplication by Positive）**
- **語法**：`∀ a b c : ℝ, 0 ≤ c → a ≤ b → a * c ≤ b * c`
- **說明**：如果 c ≥ 0 且 a ≤ b，則 a * c ≤ b * c
- **Lean 定理**：`mul_le_mul_of_nonneg_right`

### 三、常用語法符號

在 Lean 中，我們會用到以下符號：

- **全稱量詞**：`∀` 表示"對於所有"（for all）
- **存在量詞**：`∃` 表示"存在"（exists）
- **蘊含**：`→` 表示"如果...則..."（implies）
- **雙向蘊含**：`↔` 表示"若且唯若"（iff）
- **邏輯與**：`∧` 表示"且"（and）
- **邏輯或**：`∨` 表示"或"（or）
- **邏輯非**：`¬` 表示"非"（not）
- **等於**：`=` 表示等於
- **小於等於**：`≤` 表示小於等於
- **大於等於**：`≥` 表示大於等於
- **小於**：`<` 表示小於
- **大於**：`>` 表示大於

### 四、在證明中使用公設

在 Lean 中，這些公設通常以定理的形式存在，我們可以直接使用：

```lean
-- 使用加法交換律
example (a b : ℝ) : a + b = b + a := add_comm a b

-- 使用加法結合律
example (a b c : ℝ) : (a + b) + c = a + (b + c) := add_assoc a b c

-- 使用分配律
example (a b c : ℝ) : a * (b + c) = a * b + a * c := mul_add a b c
example (a b c : ℝ) : (a + b) * c = a * c + b * c := add_mul a b c
```

在證明中，我們可以使用 `rw`（rewrite）策略來應用這些定理：

```lean
example (a : ℝ) : a + 0 = a := by
   rw [add_zero]  -- 使用 add_zero 定理
```

或者使用 `←` 來反向應用：

```lean
example (a : ℝ) : a = a + 0 := by
   rw [← add_zero]  -- 反向使用 add_zero 定理
```

---

## 練習題 1：證明 0 · a = 0

### 題目

**定理**：對於任意實數 \(a\)，有 \(0 \cdot a = 0\)

**說明**：這個定理說明零乘以任何數都等於零。這是實數系統中一個重要的基本性質。

### 證明思路

使用以下基本公理：
- 分配律（公設 3）
- 加法結合律（公設 1.2）
- 加法單位元（公設 1.3）
- 加法逆元（公設 1.4）

### 完整證明

```lean
example (a : ℝ) : 0 * a = 0 := by
   -- 步驟 1：使用加法單位元公理（公設 1.3）
   -- `add_zero` 定理：`a + 0 = a`
   -- 這裡將 `0 * a` 寫成 `0 * a + 0` 的形式
   have h0a_add_0 : 0 * a = 0 * a + 0 := by
      rw [add_zero]

   -- 步驟 2：使用加法逆元公理（公設 1.4）
   -- `add_neg_cancel` 定理：`a + (-a) = 0`
   -- 取其對稱形式：`0 = a + (-a)`
   -- 這裡 `a` 是 `0 * a`，所以 `0 = 0 * a + (- (0 * a))`
   have h0_eq_0a_add_0a : 0 = 0 * a + (- (0 * a)) :=
      (add_neg_cancel (0 * a)).symm

   -- 步驟 3：將步驟 1 中的 `0` 替換成步驟 2 中的表達式
   -- 從 `0 * a = 0 * a + 0` 得到 `0 * a = 0 * a + (0 * a + (- (0 * a)))`
   -- 使用 `convert` 和 `rw [← h0_eq_0a_add_0a]` 來替換
   have h3 : 0 * a = 0 * a + (0 * a + (- (0 * a))) := by
      -- 從 h0a_add_0: 0 * a = 0 * a + 0
      -- 把右邊的 0 替換成 0 * a + (- (0 * a))（用 h0_eq_0a_add_0a 的反向）
      convert h0a_add_0 using 2
      rw [← h0_eq_0a_add_0a]

   -- 步驟 4：使用加法結合律（公設 1.2）
   -- `add_assoc` 定理：`(a + b) + c = a + (b + c)`
   -- 取其對稱形式：`a + (b + c) = (a + b) + c`
   -- 這裡將 `0 * a + (0 * a + (- (0 * a)))` 重組為 `(0 * a + 0 * a) + (- (0 * a))`
   have h4 : 0 * a + (0 * a + - (0 * a)) = (0 * a + 0 * a) + (- (0 * a)) :=
      (add_assoc (0 * a) (0 * a) (- (0 * a))).symm

   -- 步驟 5：使用分配律（公設 3）和加法單位元
   -- 首先用右分配律將 `0 * a + 0 * a` 寫成 `(0 + 0) * a`
   -- 然後用 `add_zero` 將 `(0 + 0) * a` 簡化為 `0 * a`
   -- 最終得到 `(0 * a + 0 * a) + (- (0 * a)) = 0 * a + (-(0 * a))`
   have h5 : (0 * a + 0 * a) + (- (0 * a)) = 0 * a + (-(0 * a)) := by
      -- 子步驟 5.1：使用右分配律 `add_mul` 的逆方向
      -- `add_mul` 定理：`(a + b) * c = a * c + b * c`
      -- 逆方向：`a * c + b * c = (a + b) * c`
      -- 這裡 `a = 0`, `b = 0`, `c = a`，所以 `0 * a + 0 * a = (0 + 0) * a`
      have h6 : 0 * a + 0 * a = (0 + 0) * a := by
         rw [← add_mul]
      -- 子步驟 5.2：使用加法單位元 `add_zero`
      -- `add_zero` 定理：`a + 0 = a`
      -- 這裡 `0 + 0 = 0`，所以 `(0 + 0) * a = 0 * a`
      rw [h6]
      rw [add_zero]

   -- 步驟 6：使用加法逆元公理（公設 1.4）
   -- `add_neg_cancel` 定理：`a + (-a) = 0`
   -- 這裡 `a` 是 `0 * a`，所以 `0 * a + (-(0 * a)) = 0`
   have h7 : 0 * a + (-(0 * a)) = 0 := add_neg_cancel (0 * a)

   -- 最終步驟：使用 `calc` 將以上所有步驟串聯起來
   -- 這是一個等式鏈式證明，每一步都使用前面建立的引理
   calc
      0 * a = 0 * a + (0 * a + - (0 * a)) := h3
      _ = (0 * a + 0 * a) + (- (0 * a)) := h4
      _ = 0 * a + (-(0 * a)) := h5
      _ = 0 := h7
```

### 證明步驟說明

#### 步驟 1：引入加法單位元
我們從 `0 * a = 0 * a + 0` 開始，這是加法單位元公理（`add_zero`）的直接應用。

#### 步驟 2：建立零的等價表達
使用加法逆元公理，我們知道 `0 = 0 * a + (-(0 * a))`。這為後續的替換做準備。

#### 步驟 3：替換零
將步驟 1 中的 `0` 替換成步驟 2 中的表達式，得到：
\[
0 \cdot a = 0 \cdot a + (0 \cdot a + (-(0 \cdot a)))
\]

#### 步驟 4：應用結合律
使用加法結合律重組表達式：
\[
0 \cdot a + (0 \cdot a + (-(0 \cdot a))) = (0 \cdot a + 0 \cdot a) + (-(0 \cdot a))
\]

#### 步驟 5：應用分配律
這是關鍵步驟：
1. 使用右分配律的逆方向：`0 \cdot a + 0 \cdot a = (0 + 0) \cdot a`
2. 使用加法單位元：`(0 + 0) \cdot a = 0 \cdot a`

因此得到：`(0 \cdot a + 0 \cdot a) + (-(0 \cdot a)) = 0 \cdot a + (-(0 \cdot a))`

#### 步驟 6：應用加法逆元
使用加法逆元公理：`0 \cdot a + (-(0 \cdot a)) = 0`

#### 最終：鏈式證明
使用 `calc` 將所有步驟串聯起來，完成證明。

### 使用的公理和定理

1. **加法單位元（公設 1.3）**：`add_zero : a + 0 = a`
2. **加法逆元（公設 1.4）**：`add_neg_cancel : a + (-a) = 0`
3. **加法結合律（公設 1.2）**：`add_assoc : (a + b) + c = a + (b + c)`
4. **右分配律（公設 3）**：`add_mul : (a + b) * c = a * c + b * c`

### 學習重點

1. **分配律的應用**：這是證明中最重要的步驟，展示了如何將 `0 \cdot a + 0 \cdot a` 轉換為 `(0 + 0) \cdot a`。

2. **等式鏈式證明**：使用 `calc` 可以清晰地展示證明的每一步。

3. **公理的組合使用**：這個證明展示了如何組合使用多個基本公理來證明一個看似簡單但重要的定理。

### 相關練習

- 嘗試證明 `a · 0 = 0`（使用類似的方法）
- 思考為什麼需要分配律來證明這個定理
- 比較這個證明與直接使用 `zero_mul` 定理的差異

---

## 練習題 2：證明 -a = (-1) · a

### 題目

**定理**：對於任意實數 \(a\)，有 \(-a = (-1) \cdot a\)

**說明**：這個定理說明一個數的負數等於 -1 乘以這個數。這是實數系統中另一個重要的基本性質，展示了負數與乘法的關係。

### 證明思路

使用以下基本公理和定理：
- 乘法單位元（公設 2.3）
- 右分配律（公設 3.2）
- 加法逆元（公設 1.4）
- 零乘任何數等於零（練習題 1 的結果）
- `eq_neg_of_add_eq_zero_right` 定理

### 完整證明

```lean
example (a : ℝ) : -a = (-1) * a := by
   -- 步驟 1：證明 a + (-1) * a = 0
   -- 這是證明的關鍵中間步驟，我們將使用分配律和加法逆元
   have h1 : a + (-1) * a = 0 := by
      calc
         a + (-1) * a
         -- 子步驟 1.1：使用乘法單位元（公設 2.3）
         -- `one_mul` 定理：`1 * a = a`
         -- 將 `a` 寫成 `1 * a` 的形式，以便後續使用分配律
         _ = 1 * a + (-1) * a := by rw [one_mul a]
         -- 子步驟 1.2：使用右分配律（公設 3.2）的逆方向
         -- `add_mul` 定理：`(a + b) * c = a * c + b * c`
         -- 逆方向：`a * c + b * c = (a + b) * c`
         -- 這裡 `a = 1`, `b = -1`, `c = a`，所以 `1 * a + (-1) * a = (1 + (-1)) * a`
         _ = (1 + (-1)) * a := by rw [← add_mul]
         -- 子步驟 1.3：使用加法逆元（公設 1.4）
         -- `add_neg_cancel` 定理：`a + (-a) = 0`
         -- 這裡 `a = 1`，所以 `1 + (-1) = 0`
         _ = 0 * a := by rw [add_neg_cancel (1 : ℝ)]
         -- 子步驟 1.4：使用零乘任何數等於零（前面已證明的定理）
         -- `zero_mul` 定理：`0 * a = 0`
         _ = 0 := by rw [zero_mul]
   
   -- 步驟 2：從 a + (-1) * a = 0 推導出 -a = (-1) * a
   -- 使用 `eq_neg_of_add_eq_zero_right` 定理
   -- 這個定理說：如果 `a + b = 0`，則 `b = -a`
   -- 這裡 `a = a`, `b = (-1) * a`，所以 `(-1) * a = -a`
   -- 然後使用 `eq_comm` 交換等式的兩邊，得到 `-a = (-1) * a`
   rw [eq_comm]
   exact eq_neg_of_add_eq_zero_right h1
```

### 證明步驟說明

#### 步驟 1：證明 a + (-1) · a = 0

這是證明的關鍵中間步驟。我們使用 `calc` 來建立等式鏈：

1. **子步驟 1.1**：使用乘法單位元將 `a` 寫成 `1 * a`
   - 這使得我們可以將 `a + (-1) * a` 寫成 `1 * a + (-1) * a`
   - 為後續使用分配律做準備

2. **子步驟 1.2**：使用右分配律的逆方向
   - 將 `1 * a + (-1) * a` 合併為 `(1 + (-1)) * a`
   - 這是分配律的逆應用

3. **子步驟 1.3**：使用加法逆元
   - `1 + (-1) = 0`，所以 `(1 + (-1)) * a = 0 * a`

4. **子步驟 1.4**：使用零乘任何數等於零
   - 這是練習題 1 的結果：`0 * a = 0`

#### 步驟 2：推導出最終結果

從 `a + (-1) * a = 0` 推導出 `-a = (-1) * a`：

1. 使用 `eq_neg_of_add_eq_zero_right` 定理
   - 這個定理說：如果 `a + b = 0`，則 `b = -a`
   - 這裡 `b = (-1) * a`，所以 `(-1) * a = -a`

2. 使用 `eq_comm` 交換等式的兩邊
   - 從 `(-1) * a = -a` 得到 `-a = (-1) * a`

### 使用的公理和定理

1. **乘法單位元（公設 2.3）**：`one_mul : 1 * a = a`
2. **右分配律（公設 3.2）**：`add_mul : (a + b) * c = a * c + b * c`
3. **加法逆元（公設 1.4）**：`add_neg_cancel : a + (-a) = 0`
4. **零乘任何數等於零**：`zero_mul : 0 * a = 0`（練習題 1 的結果）
5. **等式交換律**：`eq_comm : a = b ↔ b = a`
6. **加法逆元的推論**：`eq_neg_of_add_eq_zero_right : a + b = 0 → b = -a`

### 學習重點

1. **分配律的逆應用**：這個證明展示了如何將 `1 * a + (-1) * a` 合併為 `(1 + (-1)) * a`，這是分配律的逆方向應用。

2. **中間步驟的重要性**：證明 `a + (-1) * a = 0` 是關鍵的中間步驟，它連接了分配律和最終結果。

3. **定理的組合使用**：這個證明展示了如何組合使用多個基本公理和已證明的定理來證明新的定理。

4. **等式變換的技巧**：使用 `eq_comm` 來交換等式的兩邊，這是在證明中常用的技巧。

### 相關練習

- 嘗試證明 `(-a) * b = -(a * b)`（使用類似的方法）
- 思考為什麼需要先證明 `a + (-1) * a = 0`
- 比較這個證明與直接使用 `neg_one_mul` 定理的差異（如果存在）

---

## 練習題 3：證明 -(-a) = a

### 題目

**定理**：對於任意實數 \(a\)，有 \(-(-a) = a\)

**說明**：這個定理說明一個數的負數的負數等於原數。這是實數系統中一個重要的基本性質，展示了負數運算的基本規則。

### 證明思路

使用以下基本公理：
- 加法逆元（公設 1.4）
- 加法交換律（公設 1.1）
- 加法消去律（可從體公設推導）

### 完整證明

```lean
example (a : ℝ) : -(-a) = a := by
   -- 步驟 1：使用加法逆元公理（公設 1.4）
   -- `add_neg_cancel` 定理：`a + (-a) = 0`
   -- 對 `a` 應用：`a + (-a) = 0`
   have h1 : a + (-a) = 0 := add_neg_cancel a
   -- 對 `-a` 應用：`(-a) + (-(-a)) = 0`
   -- 這表示 `-a` 的加法逆元是 `-(-a)`
   have h2 : (-a) + (-(-a)) = 0 := add_neg_cancel (-a)
   
   -- 步驟 2：使用加法交換律（公設 1.1）
   -- `add_comm` 定理：`a + b = b + a`
   -- 將 h1 轉換為 `(-a) + a = 0` 的形式
   -- 這樣我們就有兩個以 `-a` 開頭的等式，方便後續使用消去律
   have h3 : (-a) + a = 0 := by rw [add_comm, h1]
   
   -- 步驟 3：使用加法消去律
   -- 如果 `x + y = 0` 且 `x + z = 0`，則 `y = z`
   -- 這裡 `x = -a`, `y = a`, `z = -(-a)`
   -- 從 `(-a) + a = 0` 和 `(-a) + (-(-a)) = 0` 得到 `a = -(-a)`
   -- 然後使用 `eq_comm` 交換等式的兩邊，得到 `-(-a) = a`
   have h5 : a = -(-a) := by
      -- 子步驟 3.1：建立等式 `(-a) + a = (-a) + (-(-a))`
      -- 我們有 `(-a) + a = 0`（h3）和 `(-a) + (-(-a)) = 0`（h2）
      -- 因為兩邊都等於 0，所以 `(-a) + a = (-a) + (-(-a))`
      have h6 : (-a) + a = (-a) + (-(-a)) := by
         rw [h3, h2]
      -- 子步驟 3.2：使用左消去律 `add_left_cancel`
      -- `add_left_cancel` 定理：如果 `a + b = a + c`，則 `b = c`
      -- 這裡 `a = -a`, `b = a`, `c = -(-a)`
      -- 從 `(-a) + a = (-a) + (-(-a))` 得到 `a = -(-a)`
      exact add_left_cancel h6
   
   -- 步驟 4：交換等式的兩邊
   -- 使用 `eq_comm` 從 `a = -(-a)` 得到 `-(-a) = a`
   rw [eq_comm]
   exact h5
```

### 證明步驟說明

#### 步驟 1：建立兩個加法逆元等式

使用加法逆元公設（公設 1.4）建立兩個關鍵等式：

1. **對 `a` 應用**：`a + (-a) = 0`
   - 這表示 `-a` 是 `a` 的加法逆元

2. **對 `-a` 應用**：`(-a) + (-(-a)) = 0`
   - 這表示 `-(-a)` 是 `-a` 的加法逆元

#### 步驟 2：使用交換律統一形式

使用加法交換律（公設 1.1）將第一個等式轉換為：
\[
(-a) + a = 0
\]

這樣我們就有兩個以 `-a` 開頭的等式，為後續使用消去律做準備。

#### 步驟 3：應用加法消去律

這是證明的關鍵步驟：

1. **建立等式**：從 `(-a) + a = 0` 和 `(-a) + (-(-a)) = 0`，我們得到：
   \[
   (-a) + a = (-a) + (-(-a))
   \]

2. **應用左消去律**：使用 `add_left_cancel` 定理
   - 如果 `a + b = a + c`，則 `b = c`
   - 這裡 `a = -a`, `b = a`, `c = -(-a)`
   - 因此得到：`a = -(-a)`

#### 步驟 4：交換等式兩邊

使用 `eq_comm` 從 `a = -(-a)` 得到最終結果：`-(-a) = a`

### 使用的公理和定理

1. **加法逆元（公設 1.4）**：`add_neg_cancel : a + (-a) = 0`
2. **加法交換律（公設 1.1）**：`add_comm : a + b = b + a`
3. **加法消去律**：`add_left_cancel : a + b = a + c → b = c`
4. **等式交換律**：`eq_comm : a = b ↔ b = a`

### 學習重點

1. **消去律的應用**：這個證明展示了如何使用加法消去律來比較兩個表達式。當我們有 `x + y = 0` 和 `x + z = 0` 時，可以推導出 `y = z`。

2. **交換律的戰略使用**：通過使用交換律將等式轉換為相同的形式（都以 `-a` 開頭），我們可以應用消去律。

3. **只使用基本公設**：這個證明完全基於體公設，沒有使用高階定理，展示了如何從基本公設推導出重要的性質。

4. **負數運算的基本規則**：這個定理是負數運算的基礎，在後續的證明中會經常使用。

### 相關練習

- 嘗試證明 `(-a) * b = -(a * b)`（使用類似的方法）
- 思考為什麼需要交換律來統一等式的形式
- 證明加法消去律可以從體公設推導出來

---

## 練習題 4：證明 -(a - b) = b - a

### 題目

**定理**：對於任意實數 \(a, b\)，有 \(-(a - b) = b - a\)

**說明**：這個定理說明一個減法的負數等於交換被減數和減數後的減法。這是實數系統中減法運算的一個重要性質。

### 證明思路

使用以下基本公理和已證明的定理：
- 減法轉加法的性質：`sub_eq_add_neg`
- 負數與乘法的關係（練習題 2）：`-a = (-1) * a`
- 左分配律（公設 3.1）
- 負數的負數等於原數（練習題 3）：`-(-a) = a`
- 加法交換律（公設 1.1）

### 完整證明

```lean
example (a b : ℝ) : -(a - b) = b - a := by
   calc
      -(a - b)
      -- 步驟 1：將減法轉換為加法形式
      -- `sub_eq_add_neg` 定理：`a - b = a + (-b)`
      -- 所以 `-(a - b) = -(a + (-b))`
      _ = -(a + (-b)) := by rw [sub_eq_add_neg]
      
      -- 步驟 2：使用負數與乘法的關係（練習題 2 的結果）
      -- `neg_one_mul` 定理：`-a = (-1) * a`
      -- 逆方向：`-x = (-1) * x`
      -- 這裡 `x = a + (-b)`，所以 `-(a + (-b)) = (-1) * (a + (-b))`
      _ = (-1) * (a + (-b)) := by rw [← neg_one_mul]
      
      -- 步驟 3：使用左分配律（公設 3.1）
      -- `mul_add` 定理：`a * (b + c) = a * b + a * c`
      -- 這裡 `a = -1`, `b = a`, `c = -b`
      -- 所以 `(-1) * (a + (-b)) = (-1) * a + (-1) * (-b)`
      _ = (-1) * a + (-1) * (-b) := by rw [mul_add]
      
      -- 步驟 4：使用負數與乘法的關係
      -- `neg_one_mul` 定理：`(-1) * a = -a`
      -- 所以 `(-1) * a + (-1) * (-b) = (-a) + (-1) * (-b)`
      _ = (-a) + (-1) * (-b) := by rw [neg_one_mul]
      
      -- 步驟 5：使用負數的負數等於原數（練習題 3 的結果）
      -- `neg_one_mul` 定理：`(-1) * (-b) = -(-b)`
      -- `neg_neg` 定理：`-(-b) = b`
      -- 所以 `(-a) + (-1) * (-b) = (-a) + b`
      _ = (-a) + b := by rw [neg_one_mul, neg_neg]
      
      -- 步驟 6：使用加法交換律（公設 1.1）
      -- `add_comm` 定理：`a + b = b + a`
      -- 所以 `(-a) + b = b + (-a)`
      _ = b + (-a) := by rw [add_comm]
      
      -- 步驟 7：轉換回減法形式
      -- `sub_eq_add_neg` 定理的逆方向：`a + (-b) = a - b`
      -- 所以 `b + (-a) = b - a`
      _ = b - a := by rw [← sub_eq_add_neg]
```

### 證明步驟說明

#### 步驟 1：將減法轉換為加法

使用 `sub_eq_add_neg` 將 `a - b` 轉換為 `a + (-b)`，這樣我們就可以使用加法的性質。

#### 步驟 2：使用負數與乘法的關係

使用練習題 2 的結果：`-x = (-1) * x`，將 `-(a + (-b))` 轉換為 `(-1) * (a + (-b))`。

#### 步驟 3：應用左分配律

使用左分配律（公設 3.1）將 `(-1) * (a + (-b))` 展開為 `(-1) * a + (-1) * (-b)`。

#### 步驟 4：簡化第一項

使用 `neg_one_mul` 將 `(-1) * a` 簡化為 `-a`。

#### 步驟 5：簡化第二項

使用 `neg_one_mul` 和 `neg_neg`（練習題 3 的結果）將 `(-1) * (-b)` 簡化為 `b`。

#### 步驟 6：使用交換律

使用加法交換律（公設 1.1）將 `(-a) + b` 轉換為 `b + (-a)`。

#### 步驟 7：轉換回減法

使用 `sub_eq_add_neg` 的逆方向將 `b + (-a)` 轉換回 `b - a`。

### 使用的公理和定理

1. **減法轉加法**：`sub_eq_add_neg : a - b = a + (-b)`
2. **負數與乘法的關係（練習題 2）**：`neg_one_mul : -a = (-1) * a`
3. **左分配律（公設 3.1）**：`mul_add : a * (b + c) = a * b + a * c`
4. **負數的負數等於原數（練習題 3）**：`neg_neg : -(-a) = a`
5. **加法交換律（公設 1.1）**：`add_comm : a + b = b + a`

### 學習重點

1. **calc 的清晰性**：使用 `calc` 建立等式鏈比大量 `rw` 更清晰，每一步的轉換都清楚可見。

2. **定理的組合使用**：這個證明展示了如何組合使用多個已證明的定理（練習題 2 和 3）來證明新的定理。

3. **減法與加法的轉換**：通過在減法和加法之間轉換，我們可以利用加法的性質來處理減法問題。

4. **負數運算的性質**：這個定理是負數運算的重要性質，在後續的證明中會經常使用。

### 相關練習

- 嘗試證明 `(a - b) - c = a - (b + c)`（使用類似的方法）
- 思考為什麼需要將減法轉換為加法
- 比較這個證明與使用消去律的證明方法的差異

---

## 練習題 5：證明 ab = 0 → a = 0 ∨ b = 0（零乘積性質）

### 題目

**定理**：對於任意實數 \(a, b\)，如果 \(a \cdot b = 0\)，則 \(a = 0\) 或 \(b = 0\)

**說明**：這個定理說明如果兩個數的乘積為零，則至少有一個為零。這是實數系統中一個重要的性質，在解方程時經常使用。

### 證明思路

使用反證法：
1. 假設結論不成立：\(a \neq 0\) 且 \(b \neq 0\)
2. 從 \(a \cdot b = 0\) 和 \(a \neq 0\) 推導出 \(b = 0\)
3. 這與 \(b \neq 0\) 矛盾
4. 因此原結論成立

### 完整證明

```lean
example (a b : ℝ) : a * b = 0 → a = 0 ∨ b = 0 := by
   -- 步驟 1：引入前提
   -- 假設 a * b = 0
   intro h
   
   -- 步驟 2：使用反證法
   -- 假設結論不成立：a ≠ 0 且 b ≠ 0
   by_contra h_not
   -- h_not 是 ¬(a = 0 ∨ b = 0)，即 a ≠ 0 且 b ≠ 0
   
   -- 步驟 3：使用德摩根定律展開否定
   -- `push_neg` 將 ¬(a = 0 ∨ b = 0) 轉換為 a ≠ 0 ∧ b ≠ 0
   push_neg at h_not
   
   -- 步驟 4：分解假設
   -- 從 h_not : a ≠ 0 ∧ b ≠ 0 得到兩個假設
   have ha_neq_0 : a ≠ 0 := h_not.left
   have hb_neq_0 : b ≠ 0 := h_not.right
   
   -- 步驟 5：從 a * b = 0 和 a ≠ 0 推導出 b = 0
   -- 這是反證法的關鍵步驟
   have hb_eq_0 : b = 0 := by
      calc
         b
         -- 子步驟 5.1：使用乘法單位元（公設 2.3）
         -- `one_mul` 定理：`1 * b = b`
         _ = 1 * b := by rw [one_mul]
         -- 子步驟 5.2：使用乘法逆元（公設 2.4）
         -- 因為 a ≠ 0，所以 a 有乘法逆元 a⁻¹
         -- `mul_inv_cancel` 定理：`a * a⁻¹ = 1`
         -- 使用 `field_simp` 自動處理類型推斷，將 1 替換為 a * a⁻¹
         _ = (a * a⁻¹) * b := by
            field_simp [ha_neq_0]
         -- 子步驟 5.3：使用乘法交換律和結合律（公設 2.1, 2.2）
         -- `mul_comm` 定理：`a * a⁻¹ = a⁻¹ * a`
         -- `mul_assoc` 定理：`(a⁻¹ * a) * b = a⁻¹ * (a * b)`
         _ = a⁻¹ * (a * b) := by rw [mul_comm a a⁻¹, mul_assoc]
         -- 子步驟 5.4：使用前提 h : a * b = 0
         -- 將 a * b 替換為 0
         _ = a⁻¹ * 0 := by rw [h]
         -- 子步驟 5.5：使用零乘任何數等於零（練習題 1 的結果）
         -- `mul_zero` 定理：`a * 0 = 0`
         _ = 0 := by rw [mul_zero]
   
   -- 步驟 6：得出矛盾
   -- 我們有 hb_neq_0 : b ≠ 0 和 hb_eq_0 : b = 0
   -- 這兩個命題矛盾，因此原假設不成立
   -- 所以 a = 0 ∨ b = 0 成立
   exact hb_neq_0 hb_eq_0
```

### 證明步驟說明

#### 步驟 1：引入前提

使用 `intro h` 引入前提 `a * b = 0`。

#### 步驟 2：使用反證法

使用 `by_contra h_not` 開始反證法，假設結論 `a = 0 ∨ b = 0` 不成立。

#### 步驟 3：展開否定

使用 `push_neg` 將 `¬(a = 0 ∨ b = 0)` 轉換為 `a ≠ 0 ∧ b ≠ 0`。

#### 步驟 4：分解假設

從 `a ≠ 0 ∧ b ≠ 0` 中提取兩個假設：
- `ha_neq_0 : a ≠ 0`
- `hb_neq_0 : b ≠ 0`

#### 步驟 5：推導矛盾

這是證明的關鍵步驟。從 `a * b = 0` 和 `a ≠ 0` 推導出 `b = 0`：

1. **使用乘法單位元**：將 `b` 寫成 `1 * b`
2. **使用乘法逆元**：因為 `a ≠ 0`，所以 `a` 有乘法逆元 `a⁻¹`，且 `a * a⁻¹ = 1`
3. **重組表達式**：使用交換律和結合律將 `(a * a⁻¹) * b` 重組為 `a⁻¹ * (a * b)`
4. **使用前提**：將 `a * b` 替換為 `0`
5. **使用零乘性質**：`a⁻¹ * 0 = 0`

因此得到 `b = 0`。

#### 步驟 6：得出矛盾

我們有 `hb_neq_0 : b ≠ 0` 和 `hb_eq_0 : b = 0`，這兩個命題矛盾。因此原假設不成立，所以 `a = 0 ∨ b = 0` 成立。

### 使用的公理和定理

1. **乘法單位元（公設 2.3）**：`one_mul : 1 * a = a`
2. **乘法逆元（公設 2.4）**：`mul_inv_cancel : a ≠ 0 → a * a⁻¹ = 1`
3. **乘法交換律（公設 2.1）**：`mul_comm : a * b = b * a`
4. **乘法結合律（公設 2.2）**：`mul_assoc : (a * b) * c = a * (b * c)`
5. **零乘任何數等於零（練習題 1）**：`mul_zero : a * 0 = 0`
6. **反證法策略**：`by_contra`、`push_neg`

### 學習重點

1. **反證法的使用**：這個證明展示了如何使用反證法來證明一個"或"命題。當直接證明困難時，反證法是一個有力的工具。

2. **乘法逆元的應用**：當我們有 `a * b = 0` 且 `a ≠ 0` 時，可以使用乘法逆元來"消去" `a`，從而得到 `b = 0`。

3. **field_simp 的使用**：`field_simp` 可以自動處理類型類實例的推斷，特別是在處理域（Field）相關的運算時非常有用。

4. **零乘積性質的重要性**：這個定理在解方程時非常重要，例如解 `(x - 1)(x - 2) = 0` 時，我們知道 `x - 1 = 0` 或 `x - 2 = 0`。

### 相關練習

- 嘗試證明：如果 `a * b = 0` 且 `a ≠ 0`，則 `b = 0`（不使用反證法）
- 思考為什麼需要 `a ≠ 0` 才能使用乘法逆元
- 證明：如果 `a * b * c = 0`，則 `a = 0` 或 `b = 0` 或 `c = 0`

---

## 練習題 6：證明 a ≠ 0 → a² > 0（平方的正性）

### 題目

**定理**：對於任意實數 \(a\)，如果 \(-1 < a < 1\) 且 \(a \neq 0\)，則 \(a^2 > 0\)

**說明**：這個定理說明在區間 \((-1, 1)\) 內的非零實數，其平方必為正數。實際上，對於任意非零實數，其平方都為正數，這個條件只是題目給出的額外限制。

### 證明思路

使用以下基本公理和定理：
- 全序性（公設 4.1）：將 \(a \neq 0\) 轉換為 \(a < 0\) 或 \(a > 0\)
- 分情況證明：分別處理 \(a < 0\) 和 \(a > 0\) 兩種情況
- 乘法保序性質：正數的乘積為正，負數的乘積也為正

### 完整證明

```lean
example (a : ℝ) : -1 < a → a < 1 → a ≠ 0 → a^2 > 0 := by
   -- 步驟 1：引入前提
   -- h1 : -1 < a（雖然在證明中不需要用到，但這是題目給出的條件）
   -- h2 : a < 1（雖然在證明中不需要用到，但這是題目給出的條件）
   -- h3 : a ≠ 0（這是證明的關鍵條件）
   intro h1 h2 h3
   
   -- 步驟 2：使用全序性（公設 4.1）將 a ≠ 0 轉換為 a < 0 或 a > 0
   -- `ne_iff_lt_or_gt` 定理：`a ≠ 0 ↔ a < 0 ∨ a > 0`
   -- 使用 `.mp` 得到：如果 a ≠ 0，則 a < 0 或 a > 0
   have h4 : a < 0 ∨ a > 0 := ne_iff_lt_or_gt.mp h3
   
   -- 步驟 3：建立 a² 與 a * a 的等價關係
   -- `pow_two` 定理：`a^2 = a * a`
   -- 這允許我們在 a² 和 a * a 之間轉換
   have h5 : a^2 = a * a := pow_two a
   
   -- 步驟 4：分情況證明
   -- 使用 `cases` 對 h4 進行分情況討論
   cases h4 with
   -- 情況 1：a < 0
   | inl h_neg => 
      -- 子步驟 4.1：證明 a * a > 0（當 a < 0 時）
      -- `mul_pos_of_neg_of_neg` 定理：如果 a < 0 且 b < 0，則 a * b > 0
      -- 這裡 a < 0 且 a < 0，所以 a * a > 0
      have h6 : a * a > 0 := mul_pos_of_neg_of_neg h_neg h_neg
      -- 子步驟 4.2：使用 calc 建立不等式鏈
      calc 
         a^2
         -- 將 a² 轉換為 a * a
         _ = a * a := by rw [h5]
         -- 使用 h6 得到 a * a > 0
         _ > 0 := by exact h6
   -- 情況 2：a > 0
   | inr h_pos => 
      -- 子步驟 4.3：證明 a * a > 0（當 a > 0 時）
      -- `mul_pos` 定理：如果 a > 0 且 b > 0，則 a * b > 0
      -- 這裡 a > 0 且 a > 0，所以 a * a > 0
      have h6 : a * a > 0 := mul_pos h_pos h_pos
      -- 子步驟 4.4：使用 calc 建立不等式鏈
      calc 
         a^2
         -- 將 a² 轉換為 a * a
         _ = a * a := by rw [h5]
         -- 使用 h6 得到 a * a > 0
         _ > 0 := by exact h6
```

### 證明步驟說明

#### 步驟 1：引入前提

使用 `intro` 引入三個前提：
- `h1 : -1 < a`
- `h2 : a < 1`
- `h3 : a ≠ 0`

**注意**：雖然 `h1` 和 `h2` 給出了 `a` 的範圍限制，但在證明 `a^2 > 0` 時實際上不需要用到這兩個條件，因為只要 `a \neq 0` 就有 `a^2 > 0`。

#### 步驟 2：使用全序性轉換

使用 `ne_iff_lt_or_gt.mp` 將 `a ≠ 0` 轉換為 `a < 0 ∨ a > 0`。這是全序性的應用：對於任意實數，要麼小於 0，要麼等於 0，要麼大於 0。由於 `a ≠ 0`，所以只能是 `a < 0` 或 `a > 0`。

#### 步驟 3：建立等價關係

使用 `pow_two` 建立 `a^2 = a * a` 的等價關係，這樣我們就可以在平方和乘積之間轉換。

#### 步驟 4：分情況證明

使用 `cases` 對 `a < 0 ∨ a > 0` 進行分情況討論：

**情況 1：a < 0**
- 使用 `mul_pos_of_neg_of_neg` 定理：如果兩個負數相乘，結果為正數
- 因此 `a * a > 0`，即 `a^2 > 0`

**情況 2：a > 0**
- 使用 `mul_pos` 定理：如果兩個正數相乘，結果為正數
- 因此 `a * a > 0`，即 `a^2 > 0`

### 使用的公理和定理

1. **全序性（公設 4.1）**：`ne_iff_lt_or_gt : a ≠ 0 ↔ a < 0 ∨ a > 0`
2. **平方的定義**：`pow_two : a^2 = a * a`
3. **正數乘積為正**：`mul_pos : a > 0 → b > 0 → a * b > 0`
4. **負數乘積為正**：`mul_pos_of_neg_of_neg : a < 0 → b < 0 → a * b > 0`

### 學習重點

1. **分情況證明**：當我們有 `P ∨ Q` 時，可以使用 `cases` 分別證明每種情況，這是處理"或"命題的標準方法。

2. **全序性的應用**：`ne_iff_lt_or_gt` 是將不等於關係轉換為嚴格不等式的有用工具。

3. **平方的正性**：這個定理說明非零實數的平方總是正數，這是實數系統的一個重要性質。

4. **calc 用於不等式**：`calc` 不僅可以用於等式，也可以用於不等式鏈式證明。

### 相關練習

- 嘗試證明：對於任意實數 \(a\)，有 \(a^2 \geq 0\)（不需要 \(a \neq 0\) 的條件）
- 思考為什麼 `-1 < a < 1` 這個條件在證明中不需要用到
- 證明：如果 \(a^2 = 0\)，則 \(a = 0\)

---

## 練習題 7：證明 0 < a < 1 → 0 < a² < a

### 題目

**定理**：對於任意實數 \(a\)，如果 \(0 < a < 1\)，則 \(0 < a^2 < a\)

**說明**：這個定理說明在區間 \((0, 1)\) 內的實數，其平方也在 \((0, a)\) 內，即平方比原數小。這是實數系統中一個重要的不等式性質。

### 證明思路

分別證明兩個部分：
1. **a² > 0**：使用正數乘積為正的性質
2. **a² < a**：使用乘法保序性質，因為 \(a < 1\) 且 \(a > 0\)

### 完整證明

```lean
example (a : ℝ) : 0 < a → a < 1 → 0 < a^2 ∧ a^2 < a := by
   -- 步驟 1：引入前提
   -- h1 : 0 < a（a 是正數）
   -- h2 : a < 1（a 小於 1）
   intro h1 h2
   
   -- 步驟 2：建立 a² 與 a * a 的等價關係
   -- `pow_two` 定理：`a^2 = a * a`
   -- 這允許我們在 a² 和 a * a 之間轉換
   have h3 : a^2 = a * a := pow_two a
   
   -- 步驟 3：證明 a * a > 0
   -- `mul_pos` 定理：如果 a > 0 且 b > 0，則 a * b > 0
   -- 這裡 a > 0 (h1) 且 a > 0 (h1)，所以 a * a > 0
   have h4 : a * a > 0 := mul_pos h1 h1
   
   -- 步驟 4：證明 a² > 0
   -- 使用 calc 從 a² = a * a 和 a * a > 0 得到 a² > 0
   have h5 : a^2 > 0 := by 
      calc 
         a^2
         -- 將 a² 轉換為 a * a
         _ = a * a := h3 
         -- 使用 h4：a * a > 0
         _ > 0 := h4 
   
   -- 步驟 5：證明 a² < a
   -- 這是證明的關鍵步驟，需要使用乘法保序性質
   have h6 : a^2 < a := by
      -- 先將 a² 轉換為 a * a
      rw [h3]
      calc 
         a * a
         -- 子步驟 5.1：使用乘法保序（公設 4.5）
         -- `mul_lt_mul_of_pos_right` 定理：如果 a < b 且 0 < c，則 c * a < c * b
         -- 這裡 a < 1 (h2) 且 0 < a (h1)，所以 a * a < a * 1
         -- 但我們需要 a * a < 1 * a，所以使用 mul_lt_mul_of_pos_right
         _ < 1 * a := mul_lt_mul_of_pos_right h2 h1
         -- 子步驟 5.2：使用乘法單位元（公設 2.3）
         -- `one_mul` 定理：`1 * a = a`
         _ = a := by rw [one_mul]
   
   -- 步驟 6：組合兩個結果
   -- 使用 `⟨h5, h6⟩` 將 `a^2 > 0` 和 `a^2 < a` 組合成 `0 < a^2 ∧ a^2 < a`
   exact ⟨h5, h6⟩
```

### 證明步驟說明

#### 步驟 1：引入前提

使用 `intro` 引入兩個前提：
- `h1 : 0 < a`：a 是正數
- `h2 : a < 1`：a 小於 1

#### 步驟 2：建立等價關係

使用 `pow_two` 建立 `a^2 = a * a` 的等價關係，這樣我們就可以在平方和乘積之間轉換。

#### 步驟 3：證明 a * a > 0

使用 `mul_pos` 定理：如果兩個正數相乘，結果為正數。因為 `a > 0`，所以 `a * a > 0`。

#### 步驟 4：證明 a² > 0

使用 `calc` 從 `a^2 = a * a` 和 `a * a > 0` 得到 `a^2 > 0`。

#### 步驟 5：證明 a² < a

這是證明的關鍵步驟：

1. **使用乘法保序**：`mul_lt_mul_of_pos_right` 定理說：如果 `a < b` 且 `0 < c`，則 `c * a < c * b`
   - 這裡 `a < 1` (h2) 且 `0 < a` (h1)
   - 所以 `a * a < a * 1`

2. **使用乘法單位元**：`one_mul` 將 `1 * a` 簡化為 `a`

因此得到 `a^2 < a`。

#### 步驟 6：組合結果

使用 `⟨h5, h6⟩` 將兩個結果組合成 `0 < a^2 ∧ a^2 < a`。

### 使用的公理和定理

1. **平方的定義**：`pow_two : a^2 = a * a`
2. **正數乘積為正**：`mul_pos : a > 0 → b > 0 → a * b > 0`
3. **乘法保序（右側）**：`mul_lt_mul_of_pos_right : a < b → 0 < c → c * a < c * b`
4. **乘法單位元（公設 2.3）**：`one_mul : 1 * a = a`

### 學習重點

1. **分步證明合取命題**：當需要證明 `P ∧ Q` 時，可以分別證明 `P` 和 `Q`，然後使用 `⟨hP, hQ⟩` 組合。

2. **乘法保序的應用**：`mul_lt_mul_of_pos_right` 和 `mul_lt_mul_of_pos_left` 是處理不等式乘法的有力工具。

3. **區間 (0, 1) 的性質**：這個定理說明在開區間 (0, 1) 內，平方函數是遞減的（相對於原數）。

4. **calc 用於不等式**：`calc` 不僅可以用於等式，也可以用於不等式鏈式證明。

### 相關練習

- 嘗試證明：如果 \(a > 1\)，則 \(a^2 > a\)
- 思考為什麼需要 \(0 < a\) 這個條件
- 證明：如果 \(0 < a < b < 1\)，則 \(a^2 < b^2\)

---

## 練習題 8：證明 |a · b| = |a| · |b|（絕對值的乘性）

### 題目

**定理**：對於任意實數 \(a, b\)，有 \(|a \cdot b| = |a| \cdot |b|\)

**說明**：這個定理說明絕對值對乘法是保持的，即乘積的絕對值等於絕對值的乘積。這是絕對值運算的一個重要性質。

### 證明思路

使用分情況證明：
1. 對 \(a\) 分情況：\(a \leq 0\) 或 \(a \geq 0\)
2. 對 \(b\) 分情況：\(b \leq 0\) 或 \(b \geq 0\)
3. 總共有四種情況組合，分別證明每種情況

### 完整證明

```lean
example (a b : ℝ) : |a * b| = |a| * |b| := by 
   have h_a : a ≤ 0 ∨ 0 ≤ a := le_total a 0  -- 對 a 分情況：a ≤ 0 或 a ≥ 0
   have h_b : b ≤ 0 ∨ 0 ≤ b := le_total b 0  -- 對 b 分情況：b ≤ 0 或 b ≥ 0
   cases h_a with  -- 對 a 的情況進行分情況討論
   | inl ha_neg =>  -- 情況 1：a ≤ 0
      cases h_b with  -- 對 b 的情況進行分情況討論
         | inl hb_neg =>  -- 情況 1.1：a ≤ 0 且 b ≤ 0
            have h_ab : a * b ≥ 0 := mul_nonneg_of_nonpos_of_nonpos ha_neg hb_neg
            have h1 : |a * b| = a * b := by rw [abs_of_nonneg h_ab]
            have h2 : |a| = -a := by rw [abs_of_nonpos ha_neg]
            have h3 : |b| = -b := by rw [abs_of_nonpos hb_neg]
            have h4 : |a| * |b| = -a * -b := by rw [h2, h3]
            have h5 : -a * -b = a * b := by rw [neg_mul_neg]
            have h6 : |a| * |b| = a * b := by 
               calc 
                  |a| * |b|
                  _ = -a * -b := h4 
                  _ = a * b := h5 
            have h7 :|a * b| = |a| * |b| := by 
               calc 
                  |a * b|
                  _ = a * b := h1 
                  _ = |a| * |b| := h6.symm
            exact h7
         | inr hb_pos =>  -- 情況 1.2：a ≤ 0 且 b ≥ 0
            have h_ab : a * b ≤ 0 := mul_nonpos_of_nonpos_of_nonneg ha_neg hb_pos
            have h1 : |a * b| = - (a * b) := by rw [abs_of_nonpos h_ab]
            have h2 : |a| = -a := by rw [abs_of_nonpos ha_neg]
            have h3 : |b| = b := by rw [abs_of_nonneg hb_pos]
            have h4 : |a| * |b| = (-a) * b := by rw [h2, h3]
            have h5 : -(a * b) = (-a) * b := by rw [neg_mul]
            have h6 : |a * b| = |a| * |b| := by 
               calc 
                  |a * b|
                  _ = - (a * b) := h1
                  _ = (-a) * b := h5 
                  _ = |a| * |b| := h4.symm
            exact h6
   | inr ha_pos =>  -- 情況 2：a ≥ 0
      cases h_b with
      | inl hb_neg =>  -- 情況 2.1：a ≥ 0 且 b ≤ 0
         have h_ab : b * a ≤ 0 := mul_nonpos_of_nonpos_of_nonneg hb_neg ha_pos
         have h1 : a * b = b * a := by rw [mul_comm]
         have h2 : a * b ≤ 0 := by 
            calc
               a * b
               _ = b * a := h1
               _ ≤ 0 := h_ab
         have h3 : |a * b| = - (a * b) := by rw [abs_of_nonpos h2]
         have h4 : |a| = a := by rw [abs_of_nonneg ha_pos]
         have h5 : |b| = -b := by rw [abs_of_nonpos hb_neg]
         have h6 : |a| * |b| = a * (-b) := by rw [h4, h5]
         have h7 : - (a * b) = a * (-b) := by rw [← mul_neg]
         have h8 : |a * b| = |a| * |b| := by 
            calc 
               |a * b|
               _ = - (a * b) := h3
               _ = a * (-b) := h7 
               _ = |a| * |b| := h6.symm
         exact h8
      | inr hb_pos =>  -- 情況 2.2：a ≥ 0 且 b ≥ 0
         have h_ab : a * b ≥ 0 := mul_nonneg ha_pos hb_pos
         have h1 : |a * b| = a * b := by rw [abs_of_nonneg h_ab]
         have h2 : |a| = a := by rw [abs_of_nonneg ha_pos]
         have h3 : |b| = b := by rw [abs_of_nonneg hb_pos]
         have h4 : |a| * |b| = a * b := by rw [h2, h3]
         have h6 : |a * b| = |a| * |b| := by 
            calc 
               |a * b|
               _ = a * b := h1 
               _ = |a| * |b| := h4.symm
         exact h6
```

### 證明步驟說明

#### 整體結構：分情況證明

這個證明使用嵌套的分情況討論，總共有四種情況：

1. **情況 1.1**：\(a \leq 0\) 且 \(b \leq 0\)
2. **情況 1.2**：\(a \leq 0\) 且 \(b \geq 0\)
3. **情況 2.1**：\(a \geq 0\) 且 \(b \leq 0\)
4. **情況 2.2**：\(a \geq 0\) 且 \(b \geq 0\)

#### 情況 1.1：a ≤ 0 且 b ≤ 0

**步驟說明：**
1. **確定 a * b 的符號**：使用 `mul_nonneg_of_nonpos_of_nonpos` 得到 `a * b ≥ 0`（兩個非正數相乘為非負數）
2. **計算 |a * b|**：因為 `a * b ≥ 0`，所以 `|a * b| = a * b`
3. **計算 |a| 和 |b|**：因為 `a ≤ 0` 和 `b ≤ 0`，所以 `|a| = -a` 和 `|b| = -b`
4. **計算 |a| * |b|**：`|a| * |b| = (-a) * (-b) = a * b`（使用 `neg_mul_neg`）
5. **組合結果**：`|a * b| = a * b = |a| * |b|`

#### 情況 1.2：a ≤ 0 且 b ≥ 0

**步驟說明：**
1. **確定 a * b 的符號**：使用 `mul_nonpos_of_nonpos_of_nonneg` 得到 `a * b ≤ 0`（非正數乘以非負數為非正數）
2. **計算 |a * b|**：因為 `a * b ≤ 0`，所以 `|a * b| = -(a * b)`
3. **計算 |a| 和 |b|**：`|a| = -a` 和 `|b| = b`
4. **計算 |a| * |b|**：`|a| * |b| = (-a) * b`
5. **使用負數的分配**：`-(a * b) = (-a) * b`（使用 `neg_mul`）
6. **組合結果**：`|a * b| = -(a * b) = (-a) * b = |a| * |b|`

#### 情況 2.1：a ≥ 0 且 b ≤ 0

**步驟說明：**
1. **確定 a * b 的符號**：先證明 `b * a ≤ 0`，然後使用交換律得到 `a * b ≤ 0`
2. **計算 |a * b|**：因為 `a * b ≤ 0`，所以 `|a * b| = -(a * b)`
3. **計算 |a| 和 |b|**：`|a| = a` 和 `|b| = -b`
4. **計算 |a| * |b|**：`|a| * |b| = a * (-b)`
5. **使用負數的分配**：`-(a * b) = a * (-b)`（使用 `mul_neg` 的逆方向）
6. **組合結果**：`|a * b| = -(a * b) = a * (-b) = |a| * |b|`

#### 情況 2.2：a ≥ 0 且 b ≥ 0

**步驟說明：**
1. **確定 a * b 的符號**：使用 `mul_nonneg` 得到 `a * b ≥ 0`（兩個非負數相乘為非負數）
2. **計算 |a * b|**：因為 `a * b ≥ 0`，所以 `|a * b| = a * b`
3. **計算 |a| 和 |b|**：`|a| = a` 和 `|b| = b`
4. **計算 |a| * |b|**：`|a| * |b| = a * b`
5. **組合結果**：`|a * b| = a * b = |a| * |b|`

### 使用的公理和定理

1. **全序性（公設 4.1）**：`le_total : a ≤ b ∨ b ≤ a`
2. **絕對值的性質**：
   - `abs_of_nonneg : a ≥ 0 → |a| = a`
   - `abs_of_nonpos : a ≤ 0 → |a| = -a`
3. **乘法的符號性質**：
   - `mul_nonneg : a ≥ 0 → b ≥ 0 → a * b ≥ 0`
   - `mul_nonneg_of_nonpos_of_nonpos : a ≤ 0 → b ≤ 0 → a * b ≥ 0`
   - `mul_nonpos_of_nonpos_of_nonneg : a ≤ 0 → b ≥ 0 → a * b ≤ 0`
   - `mul_nonpos_of_nonneg_of_nonpos : a ≥ 0 → b ≤ 0 → a * b ≤ 0`
4. **負數的乘法性質**：
   - `neg_mul_neg : (-a) * (-b) = a * b`
   - `neg_mul : (-a) * b = -(a * b)`
   - `mul_neg : a * (-b) = -(a * b)`
5. **乘法交換律（公設 2.1）**：`mul_comm : a * b = b * a`

### 學習重點

1. **分情況證明的嵌套結構**：當需要對多個變數分情況時，可以使用嵌套的 `cases` 語句。

2. **絕對值的計算規則**：
   - 如果 \(a \geq 0\)，則 \(|a| = a\)
   - 如果 \(a \leq 0\)，則 \(|a| = -a\)

3. **乘法的符號規則**：
   - 正數 × 正數 = 正數
   - 負數 × 負數 = 正數
   - 正數 × 負數 = 負數
   - 負數 × 正數 = 負數

4. **負數的分配性質**：`-(a * b) = (-a) * b = a * (-b)`

5. **calc 用於等式鏈**：使用 `calc` 可以清晰地展示每一步的轉換。

### 相關練習

- 嘗試證明：\(|a / b| = |a| / |b|\)（當 \(b \neq 0\) 時）
- 思考為什麼需要分四種情況
- 證明：\(|a^n| = |a|^n\)（對任意自然數 \(n\)）

---

## 練習題 9：證明 |a| ≤ M ↔ -M ≤ a ≤ M（絕對值不等式的等價形式）

### 題目

**定理 1.6**：對於任意實數 \(a\) 和 \(M \geq 0\)，有 \(|a| \leq M\) 若且唯若 \(-M \leq a \leq M\)

**說明**：這個定理說明絕對值不等式 \(|a| \leq M\) 等價於 \(a\) 在區間 \([-M, M]\) 內。這是絕對值運算的一個重要性質，在分析學中經常使用。

### 證明思路

使用雙向等價證明：
1. **方向 1**：證明 \(|a| \leq M \to -M \leq a \leq M\)
   - 分情況討論 \(a\) 的符號（\(a \leq 0\) 或 \(a \geq 0\)）
   - 每種情況分別證明 \(-M \leq a\) 和 \(a \leq M\)
2. **方向 2**：證明 \(-M \leq a \leq M \to |a| \leq M\)
   - 同樣分情況討論 \(a\) 的符號
   - 每種情況分別證明 \(|a| \leq M\)

### 完整證明

```lean
theorem Theorem_1_6 (a M : ℝ) (hM : M ≥ 0): |a| ≤ M ↔ -M ≤ a ∧ a ≤ M := by
   constructor  -- 分別處理雙向等價的兩個方向
   · intro h  -- 方向 1：假設 |a| ≤ M
      have h_a : a ≤ 0 ∨ 0 ≤ a := le_total a 0  -- 對 a 分情況
      cases h_a with
      | inl ha_neg =>  -- 情況 1.1：a ≤ 0
         have h1 : |a| = -a := by rw [abs_of_nonpos ha_neg]  -- 因為 a ≤ 0，所以 |a| = -a
         have h2 : -a ≤ M := by  -- 從 |a| ≤ M 得到 -a ≤ M
            calc
               -a
               _ = |a| := h1.symm
               _ ≤ M := h
         have h3 : (-1 : ℝ) ≤ 0 := by norm_num  -- 證明 -1 ≤ 0
         have h4 : M * (-1) ≤ (-a) * (-1) := mul_le_mul_of_nonpos_right h2 h3  -- 使用負數乘法保序
         have h5 : -M = M * (-1) := by rw [mul_neg_one]  -- M * (-1) = -M
         have h6 : (-a) * (-1) = a := by  -- 證明 (-a) * (-1) = a
            calc
               (-a) * (-1)
               _ = (-1) * (-a) := by rw [mul_comm]
               _ = -(-a) := by rw [neg_one_mul]
               _ = a := by rw [neg_neg]
         have h7 : -M ≤ a := by  -- 組合得到 -M ≤ a
            calc
               -M
               _ = M * (-1) := h5
               _ ≤ (-a) * (-1) := h4
               _ = a := h6
         have h8 : a ≤ M := by  -- 因為 a ≤ 0 且 M ≥ 0
            calc
               a
               _ ≤ 0 := ha_neg
               _ ≤ M := hM
         exact ⟨h7, h8⟩  -- 組合得到 -M ≤ a ∧ a ≤ M
      | inr ha_pos =>  -- 情況 1.2：a ≥ 0
         have h1 : |a| = a := by rw [abs_of_nonneg ha_pos]  -- 因為 a ≥ 0，所以 |a| = a
         have h2 : a ≤ M := by  -- 從 |a| ≤ M 得到 a ≤ M
            calc
               a
               _ = |a| := h1.symm
               _ ≤ M := h
         have h3 : -M ≤ a := by  -- 因為 a ≥ 0 且 M ≥ 0
            calc
               -M
               _ ≤ 0 := neg_nonpos.mpr hM  -- 因為 M ≥ 0，所以 -M ≤ 0
               _ ≤ a := ha_pos  -- 因為 a ≥ 0，所以 0 ≤ a
         have h4 : a ≤ M := by  -- 從 |a| ≤ M 得到 a ≤ M
            calc
               a
               _ = |a| := h1.symm
               _ ≤ M := h
         exact ⟨h3, h4⟩  -- 組合得到 -M ≤ a ∧ a ≤ M
   · intro h  -- 方向 2：假設 -M ≤ a ∧ a ≤ M
      rcases h with ⟨h1, h2⟩  -- 分解為 h1 : -M ≤ a 和 h2 : a ≤ M
      have h_a : a ≤ 0 ∨ 0 ≤ a := le_total a 0  -- 對 a 分情況
      cases h_a with
      | inl ha_neg =>  -- 情況 2.1：a ≤ 0
         have h3 : |a| = -a := by rw [abs_of_nonpos ha_neg]  -- 因為 a ≤ 0，所以 |a| = -a
         have h4 : |a| ≤ M := by  -- 證明 |a| ≤ M
            have h4a : -a ≤ M := by  -- 從 -M ≤ a 得到 -a ≤ M
               have h4a1 : (-1 : ℝ) ≤ 0 := by norm_num  -- 證明 -1 ≤ 0
               calc
                  -a
                  _ = a * (-1) := by rw [mul_neg_one]  -- -a = a * (-1)
                  _ ≤ -M * (-1) := mul_le_mul_of_nonpos_right h1 h4a1  -- 使用負數乘法保序
                  _ = -(-M) := by rw [mul_neg_one]  -- -M * (-1) = -(-M)
                  _ = M := by rw [neg_neg]  -- -(-M) = M
            calc
               |a|
               _ = -a := h3
               _ ≤ M := h4a
         exact h4
      | inr ha_pos =>  -- 情況 2.2：a ≥ 0
         have h1 : |a| = a := by rw [abs_of_nonneg ha_pos]  -- 因為 a ≥ 0，所以 |a| = a
         have h2 : |a| ≤ M := by  -- 從 a ≤ M 得到 |a| ≤ M
            calc
               |a|
               _ = a := h1
               _ ≤ M := h2
         exact h2
```

### 證明步驟說明

#### 整體結構：雙向等價證明

這個證明使用 `constructor` 將雙向等價分成兩個方向分別證明。

#### 方向 1：|a| ≤ M → -M ≤ a ≤ M

**情況 1.1：a ≤ 0**

**步驟說明：**
1. **計算 |a|**：因為 `a ≤ 0`，所以 `|a| = -a`
2. **證明 -a ≤ M**：從 `|a| ≤ M` 得到 `-a ≤ M`
3. **證明 -M ≤ a**：
   - 使用負數乘法保序：從 `-a ≤ M` 和 `-1 ≤ 0`，得到 `M * (-1) ≤ (-a) * (-1)`
   - 簡化：`M * (-1) = -M`，`(-a) * (-1) = a`
   - 因此 `-M ≤ a`
4. **證明 a ≤ M**：因為 `a ≤ 0` 且 `M ≥ 0`，所以 `a ≤ M`
5. **組合結果**：`-M ≤ a ∧ a ≤ M`

**情況 1.2：a ≥ 0**

**步驟說明：**
1. **計算 |a|**：因為 `a ≥ 0`，所以 `|a| = a`
2. **證明 a ≤ M**：從 `|a| ≤ M` 得到 `a ≤ M`
3. **證明 -M ≤ a**：因為 `a ≥ 0` 且 `M ≥ 0`，所以 `-M ≤ 0 ≤ a`，即 `-M ≤ a`
4. **組合結果**：`-M ≤ a ∧ a ≤ M`

#### 方向 2：-M ≤ a ≤ M → |a| ≤ M

**情況 2.1：a ≤ 0**

**步驟說明：**
1. **計算 |a|**：因為 `a ≤ 0`，所以 `|a| = -a`
2. **證明 -a ≤ M**：
   - 從 `-M ≤ a`，使用負數乘法保序：`a * (-1) ≤ -M * (-1)`
   - 簡化：`a * (-1) = -a`，`-M * (-1) = M`
   - 因此 `-a ≤ M`
3. **得到結果**：`|a| = -a ≤ M`

**情況 2.2：a ≥ 0**

**步驟說明：**
1. **計算 |a|**：因為 `a ≥ 0`，所以 `|a| = a`
2. **證明 a ≤ M**：從前提 `a ≤ M` 直接得到
3. **得到結果**：`|a| = a ≤ M`

### 使用的公理和定理

1. **全序性（公設 4.1）**：`le_total : a ≤ b ∨ b ≤ a`
2. **絕對值的性質**：
   - `abs_of_nonneg : a ≥ 0 → |a| = a`
   - `abs_of_nonpos : a ≤ 0 → |a| = -a`
3. **負數乘法保序**：
   - `mul_le_mul_of_nonpos_right : c ≤ 0 → a ≤ b → b * c ≤ a * c`
4. **負數的運算性質**：
   - `mul_neg_one : a * (-1) = -a`
   - `neg_one_mul : (-1) * a = -a`
   - `neg_neg : -(-a) = a`
   - `neg_nonpos : M ≥ 0 → -M ≤ 0`
5. **乘法交換律（公設 2.1）**：`mul_comm : a * b = b * a`

### 學習重點

1. **雙向等價的證明結構**：使用 `constructor` 將 `↔` 分成兩個 `→` 分別證明。

2. **分情況證明的應用**：根據 `a` 的符號（正、負、零）分別處理，每種情況使用不同的絕對值計算規則。

3. **負數乘法保序的使用**：
   - 當乘以負數時，不等式的方向會反轉
   - `mul_le_mul_of_nonpos_right`：如果 `c ≤ 0` 且 `a ≤ b`，則 `b * c ≤ a * c`

4. **負數運算的簡化**：
   - `a * (-1) = -a`
   - `(-a) * (-1) = a`
   - 這些性質在處理絕對值不等式時非常有用

5. **區間表示**：這個定理將絕對值不等式轉換為區間表示，在分析學中非常重要。

### 相關練習

- 證明：\(|a| < M \leftrightarrow -M < a < M\)（當 \(M > 0\) 時）
- 證明：\(|a| \geq M \leftrightarrow a \leq -M \vee a \geq M\)（當 \(M \geq 0\) 時）
- 思考：為什麼需要條件 \(M \geq 0\)？

---

## 練習題 10：證明 |a| ≥ 0 且 |a| = 0 ↔ a = 0（絕對值的非負性與零性）

### 題目

**定理 1.7(1)**：對於任意實數 \(a\)，有 \(|a| \geq 0\) 且 \(|a| = 0\) 若且唯若 \(a = 0\)

**說明**：這個定理說明絕對值非負，且絕對值為零當且僅當數本身為零。這是絕對值運算的基本性質。

### 證明思路

使用雙向等價證明：
1. **方向 1**：證明 \(|a| \geq 0 \wedge |a| = 0 \to a = 0\)
   - 使用反證法，假設 \(a \neq 0\)
   - 分情況討論 \(a < 0\) 或 \(a > 0\)
   - 每種情況都推導出 \(|a| \neq 0\)，與前提矛盾
2. **方向 2**：證明 \(a = 0 \to |a| \geq 0 \wedge |a| = 0\)
   - 直接使用 \(|0| = 0\) 和 \(|a| \geq 0\) 的性質

### 完整證明

```lean
theorem Theorem_1_7_1 (a : ℝ) : |a| ≥ 0 ∧ |a| = 0 ↔ a = 0 := by
   constructor  -- 分別處理雙向等價的兩個方向
   intro h  -- 方向 1：假設 |a| ≥ 0 ∧ |a| = 0
   have h1 : |a| ≥ 0 := h.1  -- 提取 |a| ≥ 0
   have h2 : |a| = 0 := h.2  -- 提取 |a| = 0
   by_contra h_not  -- 假設 a ≠ 0（反證法）
   have h3 : a < 0 ∨ 0 < a := ne_iff_lt_or_gt.mp h_not  -- 從 a ≠ 0 得到 a < 0 或 a > 0
   cases h3 with
   | inl ha_neg =>  -- 情況 1：a < 0
      have h4 : |a| = -a := by rw [abs_of_neg ha_neg]  -- 因為 a < 0，所以 |a| = -a
      have h5 : -a > 0 := by  -- 證明 -a > 0
         have h5a : (-1 : ℝ) < 0 := by norm_num  -- 證明 -1 < 0
         calc
            -a
            _ = a * (-1) := by rw [mul_neg_one]  -- -a = a * (-1)
            _ > 0 * (-1) := mul_lt_mul_of_neg_right ha_neg h5a  -- 使用負數乘法保序（嚴格）
            _ = 0 := by rw [zero_mul]  -- 0 * (-1) = 0
      have h6 : |a| ≠ 0 := by  -- 證明 |a| ≠ 0
         rw [h4]  -- 將 |a| 替換為 -a
         exact ne_of_gt h5  -- 從 -a > 0 得到 -a ≠ 0
      exact h6 h2  -- 與 h2 : |a| = 0 矛盾
   | inr ha_pos =>  -- 情況 2：0 < a
      have h4 : |a| = a := by rw [abs_of_pos ha_pos]  -- 因為 0 < a，所以 |a| = a
      have h5 : |a| ≠ 0 := by  -- 證明 |a| ≠ 0
         rw [h4]  -- 將 |a| 替換為 a
         exact ne_of_gt ha_pos  -- 從 a > 0 得到 a ≠ 0
      exact h5 h2  -- 與 h2 : |a| = 0 矛盾
   intro h  -- 方向 2：假設 a = 0
   have h1 : |a| = 0 := by  -- 證明 |a| = 0
      calc
         |a|
         _ = |0| := by rw [h]  -- 將 a 替換為 0
         _ = 0 := abs_zero  -- |0| = 0
   have h2 : |a| ≥ 0 := abs_nonneg a  -- |a| ≥ 0（絕對值非負）
   exact ⟨h2, h1⟩  -- 組合得到 |a| ≥ 0 ∧ |a| = 0
```

### 證明步驟說明

#### 整體結構：雙向等價證明

這個證明使用 `constructor` 將雙向等價分成兩個方向分別證明。

#### 方向 1：|a| ≥ 0 ∧ |a| = 0 → a = 0

**證明方法：反證法**

**步驟說明：**
1. **假設結論不成立**：假設 \(a \neq 0\)
2. **分類討論**：從 \(a \neq 0\) 得到 \(a < 0\) 或 \(a > 0\)

**情況 1：a < 0**

**步驟說明：**
1. **計算 |a|**：因為 `a < 0`，所以 `|a| = -a`
2. **證明 -a > 0**：
   - 使用負數乘法保序：從 `a < 0` 和 `-1 < 0`，得到 `a * (-1) > 0 * (-1)`
   - 簡化：`a * (-1) = -a`，`0 * (-1) = 0`
   - 因此 `-a > 0`
3. **推導矛盾**：從 `-a > 0` 得到 `-a ≠ 0`，即 `|a| ≠ 0`，與前提 `|a| = 0` 矛盾

**情況 2：0 < a**

**步驟說明：**
1. **計算 |a|**：因為 `0 < a`，所以 `|a| = a`
2. **推導矛盾**：從 `a > 0` 得到 `a ≠ 0`，即 `|a| ≠ 0`，與前提 `|a| = 0` 矛盾

#### 方向 2：a = 0 → |a| ≥ 0 ∧ |a| = 0

**步驟說明：**
1. **證明 |a| = 0**：
   - 從 `a = 0`，得到 `|a| = |0|`
   - 使用 `abs_zero`：`|0| = 0`
   - 因此 `|a| = 0`
2. **證明 |a| ≥ 0**：
   - 使用 `abs_nonneg`：`|a| ≥ 0`（絕對值非負）
3. **組合結果**：`|a| ≥ 0 ∧ |a| = 0`

### 使用的公理和定理

1. **反證法**：`by_contra` 用於假設結論不成立
2. **全序性**：`ne_iff_lt_or_gt : a ≠ 0 ↔ a < 0 ∨ a > 0`
3. **絕對值的性質**：
   - `abs_of_neg : a < 0 → |a| = -a`
   - `abs_of_pos : 0 < a → |a| = a`
   - `abs_zero : |0| = 0`
   - `abs_nonneg : |a| ≥ 0`
4. **負數乘法保序（嚴格）**：
   - `mul_lt_mul_of_neg_right : c < 0 → a < b → b * c < a * c`
5. **負數的運算性質**：
   - `mul_neg_one : a * (-1) = -a`
   - `zero_mul : 0 * a = 0`
6. **不等於的性質**：
   - `ne_of_gt : a > 0 → a ≠ 0`

### 學習重點

1. **反證法的應用**：當直接證明困難時，可以假設結論不成立，然後推導出矛盾。

2. **分情況證明的必要性**：根據 \(a\) 的符號（正、負、零）分別處理，每種情況使用不同的絕對值計算規則。

3. **負數乘法保序（嚴格不等式）**：
   - 當乘以負數時，嚴格不等式的方向會反轉
   - `mul_lt_mul_of_neg_right`：如果 `c < 0` 且 `a < b`，則 `b * c < a * c`

4. **絕對值的基本性質**：
   - 絕對值非負：`|a| ≥ 0`
   - 絕對值為零當且僅當數本身為零：`|a| = 0 ↔ a = 0`

5. **矛盾的使用**：在反證法中，推導出與已知前提矛盾的結論，從而證明原命題成立。

### 相關練習

- 證明：\(|a| > 0 \leftrightarrow a \neq 0\)
- 證明：\(|a| = |b| \leftrightarrow a = b \vee a = -b\)
- 思考：為什麼絕對值非負這個性質很重要？

---

## 練習題 11：證明 |a - b| = |b - a|（絕對值對減法的交換性）

### 題目

**定理 1.7(2)**：對於任意實數 \(a, b\)，有 \(|a - b| = |b - a|\)

**說明**：這個定理說明絕對值對減法具有交換性，即 \(|a - b| = |b - a|\)。這是一個簡單但重要的性質，在分析學中經常使用。

### 證明思路

使用絕對值的性質：
1. 首先證明 \(a - b = -(b - a)\)
2. 然後使用 \(|-(b - a)| = |b - a|\)（絕對值對負數的性質）

### 完整證明

```lean
theorem Theorem_1_7_2 (a b : ℝ) : |a - b| = |b - a| := by
   have h1 : a - b = -(b - a) := by rw [neg_sub]  -- a - b = -(b - a)
   calc
      |a - b|
      _ = |-(b - a)| := by rw [h1]  -- 將 a - b 替換為 -(b - a)
      _ = |b - a| := by rw [abs_neg]  -- |-(b - a)| = |b - a|
```

### 證明步驟說明

#### 整體結構：直接計算證明

這個證明使用 `calc` 來建立等式鏈，步驟非常簡潔。

#### 步驟說明

**步驟 1：證明 a - b = -(b - a)**

使用 `neg_sub` 定理：\(a - b = -(b - a)\)

這個定理可以直接從減法的定義和負數的性質得到。

**步驟 2：應用絕對值**

1. **替換**：將 \(|a - b|\) 中的 \(a - b\) 替換為 \(-(b - a)\)，得到 \(|-(b - a)|\)
2. **使用絕對值性質**：使用 `abs_neg` 定理：\(|-x| = |x|\)
3. **得到結果**：\(|-(b - a)| = |b - a|\)

### 使用的公理和定理

1. **減法與負數的關係**：
   - `neg_sub : a - b = -(b - a)`
2. **絕對值對負數的性質**：
   - `abs_neg : |-a| = |a|`

### 學習重點

1. **減法的性質**：\(a - b = -(b - a)\) 是一個基本的減法性質，在證明中經常使用。

2. **絕對值對負數的性質**：\(|-a| = |a|\) 說明絕對值函數是偶函數，即對稱於原點。

3. **簡潔的證明**：這個證明展示了如何使用基本性質來快速證明看似複雜的等式。

4. **calc 的使用**：使用 `calc` 可以清晰地展示每一步的轉換。

### 相關練習

- 證明：\(|a - b| = 0 \leftrightarrow a = b\)
- 證明：\(|a - b| = |a| - |b|\) 是否成立？如果不成立，在什麼條件下成立？
- 思考：為什麼 \(|a - b| = |b - a|\) 這個性質在分析學中很重要？

---

## 練習題 12：證明三角不等式和反向三角不等式

### 題目

**定理 1.7(3)**：對於任意實數 \(a, b\)，有 \(|a + b| \leq |a| + |b|\) 且 \(||a| - |b|| \leq |a - b|\)

**說明**：這個定理包含兩個部分：
1. **三角不等式**：\(|a + b| \leq |a| + |b|\) - 這是分析學中最重要的不等式之一
2. **反向三角不等式**：\(||a| - |b|| \leq |a - b|\) - 這是三角不等式的推論

### 證明思路

#### 第一部分：三角不等式 \(|a + b| \leq |a| + |b|\)

使用分情況證明：
1. 對 \(a + b\) 的符號分情況：\(a + b \leq 0\) 或 \(a + b \geq 0\)
2. 每種情況都需要證明 \(a \leq |a|\) 和 \(b \leq |b|\)（或對應的負數形式）
3. 然後使用加法保序性質

#### 第二部分：反向三角不等式 \(||a| - |b|| \leq |a - b|\)

使用第一部分（三角不等式）來證明：
1. 從 \(|a| = |(a - b) + b| \leq |a - b| + |b|\) 得到 \(|a| - |b| \leq |a - b|\)
2. 從 \(|b| = |(b - a) + a| \leq |b - a| + |a| = |a - b| + |a|\) 得到 \(-|a - b| \leq |a| - |b|\)
3. 組合這兩個結果得到 \(||a| - |b|| \leq |a - b|\)

### 完整證明

由於證明非常長（約290行），這裡只展示關鍵部分。完整證明請參考 `Analysis/Basic.lean` 文件。

#### 第一部分：三角不等式

```lean
-- 對 a + b 分情況
have h_ab : a + b ≤ 0 ∨ 0 ≤ a + b := le_total (a + b) 0
cases h_ab with
| inl hab_neg =>  -- 情況 1：a + b ≤ 0
   calc
      |a + b|
      _ = -(a + b) := by rw [abs_of_nonpos hab_neg]
      _ = -a - b := by ring
      _ ≤ |a| + |b| := by
         -- 需要證明 -a ≤ |a| 和 -b ≤ |b|
         -- 然後使用加法保序
| inr hab_pos =>  -- 情況 2：a + b ≥ 0
   calc
      |a + b|
      _ = a + b := by rw [abs_of_nonneg hab_pos]
      _ ≤ |a| + |b| := by
         -- 需要證明 a ≤ |a| 和 b ≤ |b|
         -- 然後使用加法保序
```

#### 第二部分：反向三角不等式

```lean
-- 證明 ||a| - |b|| ≤ |a - b|
have h1 : |a| - |b| ≤ |a - b| := by
   -- 從 |a| = |(a - b) + b| ≤ |a - b| + |b| 得到
   have h1a : |a| = |(a - b) + b| := by ring
   have h1b : |(a - b) + b| ≤ |a - b| + |b| := by
      -- 重複使用第一部分（三角不等式）的證明過程
   calc
      |a| - |b|
      _ = |(a - b) + b| - |b| := by rw [h1a]
      _ ≤ (|a - b| + |b|) - |b| := sub_le_sub_right h1b |b|
      _ = |a - b| := by ring

have h2 : -|a - b| ≤ |a| - |b| := by
   -- 類似地從 |b| = |(b - a) + a| ≤ |a - b| + |a| 得到
   -- （證明過程類似）

exact abs_le.mpr ⟨h2, h1⟩  -- 組合得到 ||a| - |b|| ≤ |a - b|
```

### 證明步驟說明

#### 第一部分：三角不等式 \(|a + b| \leq |a| + |b|\)

**情況 1：a + b ≤ 0**

**步驟說明：**
1. **計算 |a + b|**：因為 `a + b ≤ 0`，所以 `|a + b| = -(a + b) = -a - b`
2. **證明 -a ≤ |a|**：
   - 如果 `a ≤ 0`，則 `|a| = -a`，所以 `-a = |a| ≤ |a|`
   - 如果 `a ≥ 0`，則 `|a| = a`，所以 `-a ≤ 0 ≤ a = |a|`
3. **證明 -b ≤ |b|**：類似地分情況證明
4. **組合結果**：使用加法保序 `add_le_add`，得到 `-a - b ≤ |a| + |b|`

**情況 2：a + b ≥ 0**

**步驟說明：**
1. **計算 |a + b|**：因為 `a + b ≥ 0`，所以 `|a + b| = a + b`
2. **證明 a ≤ |a|**：
   - 如果 `a ≤ 0`，則 `|a| = -a`，所以 `a ≤ 0 ≤ -a = |a|`
   - 如果 `a ≥ 0`，則 `|a| = a`，所以 `a = |a| ≤ |a|`
3. **證明 b ≤ |b|**：類似地分情況證明
4. **組合結果**：使用加法保序，得到 `a + b ≤ |a| + |b|`

#### 第二部分：反向三角不等式 \(||a| - |b|| \leq |a - b|\)

**步驟說明：**
1. **證明 |a| - |b| ≤ |a - b|**：
   - 使用 `|a| = |(a - b) + b|`
   - 對 `|(a - b) + b|` 應用三角不等式，得到 `|(a - b) + b| ≤ |a - b| + |b|`
   - 因此 `|a| - |b| ≤ |a - b|`

2. **證明 -|a - b| ≤ |a| - |b|**：
   - 使用 `|b| = |(b - a) + a|`
   - 對 `|(b - a) + a|` 應用三角不等式，得到 `|(b - a) + a| ≤ |b - a| + |a| = |a - b| + |a|`
   - 因此 `|b| - |a| ≤ |a - b|`
   - 使用負數保序（方向反轉），得到 `-|a - b| ≤ -(|b| - |a|) = |a| - |b|`

3. **組合結果**：
   - 從 `-|a - b| ≤ |a| - |b| ≤ |a - b|`，使用 `abs_le.mpr` 得到 `||a| - |b|| ≤ |a - b|`

### 使用的公理和定理

1. **全序性（公設 4.1）**：`le_total : a ≤ b ∨ b ≤ a`
2. **絕對值的性質**：
   - `abs_of_nonneg : a ≥ 0 → |a| = a`
   - `abs_of_nonpos : a ≤ 0 → |a| = -a`
3. **加法保序（公設 4.4）**：`add_le_add : a ≤ b → c ≤ d → a + c ≤ b + d`
4. **減法保序**：`sub_le_sub_right : a ≤ b → a - c ≤ b - c`
5. **負數保序**：`neg_le_neg : a ≤ b → -b ≤ -a`
6. **絕對值不等式**：`abs_le : ||a| - |b|| ≤ |a - b| ↔ -|a - b| ≤ |a| - |b| ≤ |a - b|`
7. **絕對值交換性**：`abs_sub_comm : |a - b| = |b - a|`

### 學習重點

1. **三角不等式的重要性**：這是分析學中最基本的不等式之一，在後續的極限、連續性、微積分等內容中都會頻繁使用。

2. **分情況證明的嵌套結構**：這個證明展示了如何使用嵌套的分情況討論來處理複雜的不等式。

3. **遞歸使用已證明的結果**：第二部分（反向三角不等式）的證明重複使用了第一部分（三角不等式）的證明過程，展示了如何利用已證明的結果。

4. **基本性質的應用**：
   - `a ≤ |a|` 和 `-a ≤ |a|` 是絕對值的基本性質
   - 這些性質在證明中起到關鍵作用

5. **減法保序的使用**：從 `|a| ≤ |a - b| + |b|` 得到 `|a| - |b| ≤ |a - b|`，需要使用減法保序性質。

6. **負數保序的方向反轉**：當對不等式兩邊取負號時，不等式的方向會反轉。

### 相關練習

- 證明：\(|a_1 + a_2 + \cdots + a_n| \leq |a_1| + |a_2| + \cdots + |a_n|\)（廣義三角不等式）
- 證明：\(|a - b| \geq ||a| - |b||\)
- 思考：三角不等式在幾何上有什麼直觀意義？
- 應用：使用三角不等式證明 \(|a| < 1\) 和 \(|b| < 1\) 時，\(|a + b| < 2\)

---

## 練習題 13：證明 (∀ ε > 0, x < y + ε) ↔ x ≤ y（ε-δ 定義的基礎）

### 題目

**定理 1.9(1)**：對於任意實數 \(x, y\)，有 \((\forall \varepsilon > 0, x < y + \varepsilon) \leftrightarrow x \leq y\)

**說明**：這個定理說明 \(x\) 小於等於 \(y\) 若且唯若對於所有正數 \(\varepsilon\)，\(x\) 都小於 \(y + \varepsilon\)。這是分析學中重要的等價關係，是 \(\varepsilon\)-\(\delta\) 定義的基礎，在處理極限和連續性時會頻繁使用。

### 證明思路

使用雙向等價證明：
1. **方向 1**：證明 \((\forall \varepsilon > 0, x < y + \varepsilon) \to x \leq y\)
   - 使用反證法，假設 \(x > y\)
   - 構造特定的 \(\varepsilon_0 = x - y > 0\)
   - 應用假設得到 \(x < y + (x - y) = x\)，矛盾
2. **方向 2**：證明 \(x \leq y \to (\forall \varepsilon > 0, x < y + \varepsilon)\)
   - 直接證明，分情況討論 \(x < y\) 或 \(x = y\)
   - 每種情況都得到 \(x < y + \varepsilon\)

### 完整證明

```lean
theorem Theorem_1_9_1 (x y : ℝ) : (∀ ε > 0, x < y + ε) ↔ x ≤ y := by
   constructor  -- 分別處理雙向等價的兩個方向
   · intro h  -- 方向 1：假設 ∀ ε > 0, x < y + ε
      by_contra h_not  -- 假設 ¬(x ≤ y)，即 x > y（反證法）
      have h1 : x > y := lt_of_not_le h_not  -- 從 ¬(x ≤ y) 得到 x > y
      have h2 : x - y > 0 := by  -- 從 x > y 得到 x - y > 0
         calc
            x - y
            _ > y - y := sub_lt_sub_right h1 y  -- 從 x > y 得到 x - y > y - y
            _ = 0 := sub_self y  -- y - y = 0
      have h3 : x < y + (x - y) := h (x - y) h2  -- 對 ε = x - y 應用假設 h
      have h4 : y + (x - y) = x := by ring  -- y + (x - y) = x
      rw [h4] at h3  -- 將 y + (x - y) 替換為 x
      exact lt_irrefl x h3  -- 矛盾：x < x
   · intro h  -- 方向 2：假設 x ≤ y
      intro ε hε  -- 引入任意 ε > 0
      have h_cases : x < y ∨ x = y := lt_or_eq_of_le h  -- 從 x ≤ y 得到 x < y 或 x = y
      cases h_cases with
      | inl h_lt =>  -- 情況 1：x < y
         calc
            x
            _ < y := h_lt  -- x < y
            _ < y + ε := lt_add_of_pos_right y hε  -- 因為 ε > 0，所以 y < y + ε
      | inr h_eq =>  -- 情況 2：x = y
         calc
            x
            _ = y := h_eq  -- x = y
            _ < y + ε := lt_add_of_pos_right y hε  -- 因為 ε > 0，所以 y < y + ε
```

### 證明步驟說明

#### 整體結構：雙向等價證明

這個證明使用 `constructor` 將雙向等價分成兩個方向分別證明。

#### 方向 1：(∀ ε > 0, x < y + ε) → x ≤ y

**證明方法：反證法**

**步驟說明：**
1. **假設結論不成立**：假設 \(x > y\)（即 \(\neg(x \leq y)\)）
2. **構造特定的 ε**：
   - 從 \(x > y\) 得到 \(x - y > 0\)
   - 選擇 \(\varepsilon_0 = x - y > 0\)
3. **應用假設**：
   - 對 \(\varepsilon_0 = x - y\) 應用假設 \(h : \forall \varepsilon > 0, x < y + \varepsilon\)
   - 得到 \(x < y + (x - y)\)
4. **推導矛盾**：
   - 簡化：\(y + (x - y) = x\)
   - 因此 \(x < x\)，這違反了嚴格不等式的反身性（一個數不能嚴格小於自己）
5. **得出結論**：假設 \(x > y\) 導致矛盾，因此 \(x \leq y\) 必須成立

#### 方向 2：x ≤ y → (∀ ε > 0, x < y + ε)

**證明方法：直接證明，分情況討論**

**步驟說明：**
1. **引入前提**：假設 \(x \leq y\) 和任意 \(\varepsilon > 0\)
2. **分類討論**：從 \(x \leq y\) 得到 \(x < y\) 或 \(x = y\)

**情況 1：x < y**

**步驟說明：**
1. 從 \(x < y\) 和 \(\varepsilon > 0\)，使用加法保序性質
2. 因為 \(\varepsilon > 0\)，所以 \(y < y + \varepsilon\)
3. 由傳遞性得到 \(x < y < y + \varepsilon\)，即 \(x < y + \varepsilon\)

**情況 2：x = y**

**步驟說明：**
1. 從 \(x = y\) 和 \(\varepsilon > 0\)
2. 因為 \(\varepsilon > 0\)，所以 \(y < y + \varepsilon\)
3. 因此 \(x = y < y + \varepsilon\)，即 \(x < y + \varepsilon\)

### 使用的公理和定理

1. **反證法**：`by_contra` 用於假設結論不成立
2. **否定與不等式的關係**：
   - `lt_of_not_le : ¬(x ≤ y) → x > y`
3. **減法保序（嚴格）**：
   - `sub_lt_sub_right : x < y → x - z < y - z`
4. **減法性質**：
   - `sub_self : a - a = 0`
5. **加法保序（嚴格）**：
   - `lt_add_of_pos_right : 0 < c → a < b → a < b + c`
6. **全序性**：
   - `lt_or_eq_of_le : x ≤ y → x < y ∨ x = y`
7. **嚴格不等式的反身性**：
   - `lt_irrefl : ¬(a < a)`（一個數不能嚴格小於自己）

### 學習重點

1. **反證法的應用**：當直接證明困難時，可以假設結論不成立，然後構造特定的反例來推導矛盾。

2. **構造特定值**：在反證法中，選擇特定的 \(\varepsilon_0 = x - y\) 是關鍵步驟。這個值利用了假設 \(x > y\)，使得應用假設後能直接得到矛盾。

3. **分情況證明的應用**：從 \(x \leq y\) 得到 \(x < y\) 或 \(x = y\)，每種情況都需要單獨處理。

4. **ε-δ 定義的基礎**：這個定理是分析學中 \(\varepsilon\)-\(\delta\) 定義的基礎，在後續的極限、連續性、導數等內容中會頻繁使用。

5. **全稱量詞的處理**：在證明涉及全稱量詞的命題時，需要對任意值證明；在應用全稱量詞的假設時，可以選擇特定的值。

### 相關練習

- 證明：\((\forall \varepsilon > 0, x \leq y + \varepsilon) \leftrightarrow x \leq y\)
- 證明：\((\forall \varepsilon > 0, |x - a| < \varepsilon) \leftrightarrow x = a\)
- 思考：為什麼這個定理在分析學中如此重要？
- 應用：使用這個定理證明極限的唯一性

---

## 練習題 14：證明 (∀ ε > 0, x > y - ε) ↔ x ≥ y

### 題目

**定理 1.9(2)**：對於任意實數 \(x, y\)，有 \((\forall \varepsilon > 0, x > y - \varepsilon) \leftrightarrow x \geq y\)

**說明**：這個定理說明 \(x\) 大於等於 \(y\) 若且唯若對於所有正數 \(\varepsilon\)，\(x\) 都大於 \(y - \varepsilon\)。這是定理 1.9(1) 的對偶形式，同樣是分析學中重要的等價關係。

### 證明思路

使用雙向等價證明，與定理 1.9(1) 類似：
1. **方向 1**：證明 \((\forall \varepsilon > 0, x > y - \varepsilon) \to x \geq y\)
   - 使用反證法，假設 \(x < y\)
   - 構造特定的 \(\varepsilon_0 = y - x > 0\)
   - 應用假設得到 \(x > y - (y - x) = x\)，矛盾
2. **方向 2**：證明 \(x \geq y \to (\forall \varepsilon > 0, x > y - \varepsilon)\)
   - 直接證明，分情況討論 \(x > y\) 或 \(x = y\)
   - 每種情況都得到 \(x > y - \varepsilon\)

### 完整證明

```lean
theorem Theorem_1_9_2 (x y : ℝ) : (∀ ε > 0, x > y - ε) ↔ x ≥ y := by
   constructor  -- 分別處理雙向等價的兩個方向
   intro h  -- 方向 1：假設 ∀ ε > 0, x > y - ε
   by_contra h_not  -- 假設 ¬(x ≥ y)，即 x < y（反證法）
   push_neg at h_not  -- 將 ¬(x ≥ y) 轉換為 x < y
   have h1 : y - x > 0 := by  -- 從 x < y 得到 y - x > 0
      calc
         y - x
         _ > x - x := sub_lt_sub_right h_not x  -- 從 x < y 得到 y - x > x - x
         _ = 0 := sub_self x  -- x - x = 0
   have h2 : x > y - (y - x) := h (y - x) h1  -- 對 ε = y - x 應用假設 h
   have h3 : y - (y - x) = x := by ring  -- y - (y - x) = x
      rw [h3] at h2  -- 將 y - (y - x) 替換為 x
      exact lt_irrefl x h2  -- 矛盾：x > x
   intro h  -- 方向 2：假設 x ≥ y
      intro ε hε  -- 引入任意 ε > 0
      have h_cases : y < x ∨ y = x := lt_or_eq_of_le h  -- 從 x ≥ y（即 y ≤ x）得到 y < x 或 y = x
      cases h_cases with
      | inl h_lt =>  -- 情況 1：y < x，即 x > y
         calc
            x
            _ > y := h_lt  -- 從 y < x 得到 x > y
            _ > y - ε := by  -- 需要證明 y > y - ε
               calc
                  y
                  _ = y - 0 := by ring  -- y = y - 0
                  _ > y - ε := sub_lt_sub_left hε y  -- 從 0 < ε 得到 y - 0 > y - ε
      | inr h_eq =>  -- 情況 2：y = x，即 x = y
         calc
            x
            _ = y := h_eq.symm  -- x = y
            _ > y - ε := by  -- 需要證明 y > y - ε
               calc
                  y
                  _ = y - 0 := by ring  -- y = y - 0
                  _ > y - ε := sub_lt_sub_left hε y  -- 從 0 < ε 得到 y - 0 > y - ε
```

### 證明步驟說明

#### 整體結構：雙向等價證明

這個證明使用 `constructor` 將雙向等價分成兩個方向分別證明，與定理 1.9(1) 的結構類似。

#### 方向 1：(∀ ε > 0, x > y - ε) → x ≥ y

**證明方法：反證法**

**步驟說明：**
1. **假設結論不成立**：假設 \(x < y\)（即 \(\neg(x \geq y)\)）
2. **構造特定的 ε**：
   - 從 \(x < y\) 得到 \(y - x > 0\)
   - 選擇 \(\varepsilon_0 = y - x > 0\)
3. **應用假設**：
   - 對 \(\varepsilon_0 = y - x\) 應用假設 \(h : \forall \varepsilon > 0, x > y - \varepsilon\)
   - 得到 \(x > y - (y - x)\)
4. **推導矛盾**：
   - 簡化：\(y - (y - x) = x\)
   - 因此 \(x > x\)，這違反了嚴格不等式的反身性
5. **得出結論**：假設 \(x < y\) 導致矛盾，因此 \(x \geq y\) 必須成立

#### 方向 2：x ≥ y → (∀ ε > 0, x > y - ε)

**證明方法：直接證明，分情況討論**

**步驟說明：**
1. **引入前提**：假設 \(x \geq y\) 和任意 \(\varepsilon > 0\)
2. **分類討論**：從 \(x \geq y\)（即 \(y \leq x\)）得到 \(y < x\) 或 \(y = x\)

**情況 1：y < x（即 x > y）**

**步驟說明：**
1. 從 \(y < x\) 得到 \(x > y\)
2. 需要證明 \(y > y - \varepsilon\)：
   - 使用 \(y = y - 0\)
   - 從 \(0 < \varepsilon\)，使用 `sub_lt_sub_left` 得到 \(y - 0 > y - \varepsilon\)
   - 因此 \(y > y - \varepsilon\)
3. 由傳遞性得到 \(x > y > y - \varepsilon\)，即 \(x > y - \varepsilon\)

**情況 2：y = x（即 x = y）**

**步驟說明：**
1. 從 \(y = x\) 得到 \(x = y\)
2. 需要證明 \(y > y - \varepsilon\)：
   - 使用 \(y = y - 0\)
   - 從 \(0 < \varepsilon\)，使用 `sub_lt_sub_left` 得到 \(y - 0 > y - \varepsilon\)
   - 因此 \(y > y - \varepsilon\)
3. 因此 \(x = y > y - \varepsilon\)，即 \(x > y - \varepsilon\)

### 使用的公理和定理

1. **反證法**：`by_contra` 用於假設結論不成立
2. **否定與不等式的關係**：
   - `push_neg` 將 `¬(x ≥ y)` 轉換為 `x < y`
3. **減法保序（嚴格）**：
   - `sub_lt_sub_right : x < y → x - z < y - z`
   - `sub_lt_sub_left : a < b → a - c < b - c`
4. **減法性質**：
   - `sub_self : a - a = 0`
5. **全序性**：
   - `lt_or_eq_of_le : x ≤ y → x < y ∨ x = y`
6. **嚴格不等式的反身性**：
   - `lt_irrefl : ¬(a < a)`（一個數不能嚴格小於自己）

### 學習重點

1. **對偶定理**：這個定理是定理 1.9(1) 的對偶形式，證明的結構和方法都非常相似。

2. **減法保序的應用**：
   - `sub_lt_sub_left : a < b → a - c < b - c`
   - 從 `0 < ε` 得到 `0 - y < ε - y`，即 `-y < ε - y`
   - 這等價於 `y - ε < y - 0`，即 `y - ε < y`，即 `y > y - ε`

3. **構造特定值**：在反證法中，選擇特定的 \(\varepsilon_0 = y - x\) 是關鍵步驟。

4. **分情況證明的應用**：從 \(x \geq y\)（即 \(y \leq x\)）得到 \(y < x\) 或 \(y = x\)，每種情況都需要單獨處理。

### 相關練習

- 比較這個定理與定理 1.9(1) 的異同
- 證明：\((\forall \varepsilon > 0, x \geq y - \varepsilon) \leftrightarrow x \geq y\)
- 思考：為什麼這兩個定理在分析學中如此重要？

---

## 練習題 15：證明 (∀ ε > 0, |a| < ε) ↔ a = 0

### 問題陳述

**定理 1.9(3)**：對於任意實數 \(a\)，有
\[
(\forall \varepsilon > 0, |a| < \varepsilon) \leftrightarrow a = 0
\]

這個定理說明：一個數的絕對值小於任意正數，當且僅當這個數本身為零。

### 證明策略

這個定理的證明分為兩個方向：

1. **方向 1（→）**：假設 \(\forall \varepsilon > 0, |a| < \varepsilon\)，證明 \(a = 0\)
   - 將 \(|a| < \varepsilon\) 改寫為 \(|a| < 0 + \varepsilon\)
   - 使用定理 1.9(1) 得到 \(|a| \leq 0\)
   - 結合 \(|a| \geq 0\)（絕對值非負），得到 \(|a| = 0\)
   - 使用定理 1.7(1) 得到 \(a = 0\)

2. **方向 2（←）**：假設 \(a = 0\)，證明 \(\forall \varepsilon > 0, |a| < \varepsilon\)
   - 使用定理 1.7(1) 得到 \(|a| = 0\)
   - 對於任意 \(\varepsilon > 0\)，有 \(|a| = 0 < \varepsilon\)

### Lean 程式碼

```lean
theorem Theorem_1_9_3 (a : ℝ) : (∀ ε > 0, |a| < ε) ↔ a = 0 := by
   constructor  -- 分別處理雙向等價的兩個方向
   intro h  -- 方向 1：假設 ∀ ε > 0, |a| < ε
   have h1 : ∀ ε > 0, |a| < 0 + ε := by  -- 將 |a| < ε 改寫為 |a| < 0 + ε
      intro ε hε  -- 引入 ε 和 ε > 0
      calc
         |a|
         _ < ε := h ε hε  -- 應用 h
         _ = 0 + ε := by ring  -- ε = 0 + ε
   have h2 : |a| ≤ 0 := (Theorem_1_9_1 |a| 0).1 h1  -- 使用 Theorem 1.9(1) 得到 |a| ≤ 0
   have h3 : |a| ≥ 0 := abs_nonneg a  -- |a| ≥ 0（絕對值非負）
   have h4 : |a| = 0 := le_antisymm h2 h3  -- 從 |a| ≤ 0 和 |a| ≥ 0 得到 |a| = 0
   have h5 : a = 0 := (Theorem_1_7_1 a).1 ⟨h3, h4⟩  -- 使用 Theorem 1.7(1) 得到 a = 0
   exact h5  -- 完成方向 1 的證明
   intro h  -- 方向 2：假設 a = 0
   have h1 : |a| ≥ 0 ∧ |a| = 0 := (Theorem_1_7_1 a).mpr h  -- 使用 Theorem 1.7(1) 得到 |a| ≥ 0 ∧ |a| = 0
   have h2 : |a| = 0 := h1.2  -- 提取 |a| = 0
   have h3 : ∀ ε > 0, |a| < ε := by  -- 證明 ∀ ε > 0, |a| < ε
      intro ε hε  -- 引入 ε 和 ε > 0
      calc
         |a|
         _ = 0 := h2  -- |a| = 0
         _ < ε := hε  -- 0 < ε
   exact h3  -- 完成方向 2 的證明
```

### 詳細證明步驟

#### 方向 1：\((\forall \varepsilon > 0, |a| < \varepsilon) \to a = 0\)

1. **改寫條件**：
   - 假設 \(\forall \varepsilon > 0, |a| < \varepsilon\)
   - 將 \(|a| < \varepsilon\) 改寫為 \(|a| < 0 + \varepsilon\)
   - 這一步是為了應用定理 1.9(1)

2. **應用定理 1.9(1)**：
   - 定理 1.9(1) 說：\((\forall \varepsilon > 0, x < y + \varepsilon) \leftrightarrow x \leq y\)
   - 這裡 \(x = |a|\)，\(y = 0\)
   - 所以從 \(\forall \varepsilon > 0, |a| < 0 + \varepsilon\) 得到 \(|a| \leq 0\)

3. **結合絕對值非負性**：
   - 絕對值總是非負的：\(|a| \geq 0\)
   - 現在有 \(|a| \leq 0\) 和 \(|a| \geq 0\)
   - 根據三歧性（Trichotomy Property），得到 \(|a| = 0\)

4. **應用定理 1.7(1)**：
   - 定理 1.7(1) 說：\(|a| \geq 0 \land |a| = 0 \leftrightarrow a = 0\)
   - 從 \(|a| \geq 0 \land |a| = 0\) 得到 \(a = 0\)

#### 方向 2：\(a = 0 \to (\forall \varepsilon > 0, |a| < \varepsilon)\)

1. **應用定理 1.7(1)**：
   - 假設 \(a = 0\)
   - 使用定理 1.7(1) 的右到左方向，得到 \(|a| \geq 0 \land |a| = 0\)
   - 提取 \(|a| = 0\)

2. **證明全稱命題**：
   - 對於任意 \(\varepsilon > 0\)，需要證明 \(|a| < \varepsilon\)
   - 因為 \(|a| = 0\)，且 \(0 < \varepsilon\)（由 \(\varepsilon > 0\) 得到）
   - 所以 \(|a| = 0 < \varepsilon\)

### 使用的公設和定理

1. **定理 1.9(1)**：
   - `Theorem_1_9_1 x y : (∀ ε > 0, x < y + ε) ↔ x ≤ y`
   - 用於將「小於任意正數」轉換為「小於等於」

2. **絕對值非負性**：
   - `abs_nonneg a : |a| ≥ 0`
   - 絕對值總是非負的

3. **三歧性（等號的對稱性）**：
   - `le_antisymm : x ≤ y → y ≤ x → x = y`
   - 如果 \(x \leq y\) 且 \(y \leq x\)，則 \(x = y\)

4. **定理 1.7(1)**：
   - `Theorem_1_7_1 a : |a| ≥ 0 ∧ |a| = 0 ↔ a = 0`
   - 絕對值為零當且僅當數本身為零

5. **基本算術**：
   - `ring`：簡化環運算
   - 嚴格不等式的傳遞性

### 學習重點

1. **定理的應用**：這個證明展示了如何將一個定理（定理 1.9(1)）應用到另一個問題中。

2. **改寫技巧**：將 \(|a| < \varepsilon\) 改寫為 \(|a| < 0 + \varepsilon\) 是關鍵步驟，使得可以應用定理 1.9(1)。

3. **三歧性的應用**：
   - 從 \(|a| \leq 0\) 和 \(|a| \geq 0\) 得到 \(|a| = 0\)
   - 這是實數三歧性（Trichotomy Property）的應用

4. **全稱命題的證明**：
   - 證明 \(\forall \varepsilon > 0, P(\varepsilon)\) 需要對任意 \(\varepsilon > 0\) 證明 \(P(\varepsilon)\)
   - 在 Lean 中使用 `intro ε hε` 引入任意 \(\varepsilon > 0\)

5. **定理的組合使用**：
   - 這個證明結合了多個之前證明的定理
   - 展示了如何將簡單的定理組合成更複雜的證明

### 相關練習

- 比較這個定理與定理 1.9(1) 和 1.9(2) 的異同
- 證明：\((\forall \varepsilon > 0, |a| \leq \varepsilon) \leftrightarrow a = 0\)
- 思考：為什麼這個定理在分析學中如此重要？（它與極限的定義密切相關）

---

## 例題 1.11：證明 sup [0, 1] = 1

### 問題陳述

**例題 1.11**：設 \(E = [0, 1]\)（閉區間），證明 \(\sup E = 1\)。

這個例題展示了如何證明一個具體集合的上確界。閉區間 \([0, 1]\) 的上確界是 1，這是一個直觀的結果，但需要嚴格證明。

### 證明策略

根據上確界的定義，需要證明兩個部分：

1. **上界性**：證明 1 是 \([0, 1]\) 的上界
   - 需要證明：對所有 \(x \in [0, 1]\)，有 \(x \leq 1\)
   - 這直接從區間的定義得到：如果 \(x \in [0, 1]\)，則 \(x \leq 1\)

2. **最小性**：證明 1 是所有上界中最小的
   - 需要證明：對所有 \([0, 1]\) 的上界 \(M\)，有 \(1 \leq M\)
   - 使用反證法：假設 \(M < 1\)，但 \(1 \in [0, 1]\)，而 \(M < 1\)，這與 \(M\) 是上界矛盾

### Lean 程式碼

```lean
theorem Example_1_11 : is_supremum 1 (Set.Icc 0 1) := by
   constructor  -- 分開 is_supremum 的兩個部分：上界性和最小性
   intro x hx  -- 第一部分：引入 x 和 x ∈ [0, 1]
   exact hx.2  -- 從 x ∈ [0, 1] 得到 x ≤ 1（hx.2 提取第二個條件）
   intro M hM  -- 第二部分：引入 M 和 hM : M 是 [0, 1] 的上界
   by_contra h_not  -- 假設 ¬(1 ≤ M)（反證法）
   push_neg at h_not  -- 將 ¬(1 ≤ M) 轉換為 M < 1
   have h1_in : (1 : ℝ) ∈ Set.Icc (0 : ℝ) 1 := by  -- 證明 1 ∈ [0, 1]
      exact ⟨ by norm_num, by norm_num ⟩  -- 0 ≤ 1 且 1 ≤ 1（norm_num 自動證明）
   have h_contra : 1 ≤ M := hM 1 h1_in  -- 因為 M 是上界，所以 1 ≤ M
   have h : (1 : ℝ) < 1 := lt_of_le_of_lt h_contra h_not  -- 從 1 ≤ M 和 M < 1 得到 1 < 1
   exact lt_irrefl (1 : ℝ) h  -- 1 < 1 矛盾（lt_irrefl 表示一個數不能嚴格小於自己）
```

### 詳細證明步驟

#### 第一部分：證明 1 是 [0, 1] 的上界

1. **引入變數**：
   - `intro x hx`：引入 \(x\) 和假設 \(x \in [0, 1]\)
   - `hx : x ∈ Set.Icc 0 1` 表示 \(0 \leq x \land x \leq 1\)

2. **提取條件**：
   - `exact hx.2`：從 \(hx : 0 \leq x \land x \leq 1\) 提取第二個條件 \(x \leq 1\)
   - 這直接證明了 1 是上界

#### 第二部分：證明 1 是最小的上界

1. **引入上界**：
   - `intro M hM`：引入 \(M\) 和假設 \(M\) 是 \([0, 1]\) 的上界
   - `hM : is_upper_bound M (Set.Icc 0 1)` 表示對所有 \(x \in [0, 1]\)，有 \(x \leq M\)

2. **反證法**：
   - `by_contra h_not`：假設 \(\neg(1 \leq M)\)，即 \(M < 1\)
   - `push_neg at h_not`：將 \(\neg(1 \leq M)\) 轉換為 \(M < 1\)

3. **證明 1 屬於 [0, 1]**：
   - `have h1_in : 1 ∈ Set.Icc 0 1`：需要證明 \(0 \leq 1 \land 1 \leq 1\)
   - `⟨ by norm_num, by norm_num ⟩`：使用 `norm_num` 自動證明這兩個數值不等式

4. **應用上界定義**：
   - `have h_contra : 1 ≤ M := hM 1 h1_in`：因為 \(M\) 是上界，且 \(1 \in [0, 1]\)，所以 \(1 \leq M\)

5. **得到矛盾**：
   - `have h : 1 < 1 := lt_of_le_of_lt h_contra h_not`：從 \(1 \leq M\) 和 \(M < 1\) 得到 \(1 < 1\)
   - `exact lt_irrefl 1 h`：\(1 < 1\) 矛盾（一個數不能嚴格小於自己）

### 使用的定義和定理

1. **集合定義**：
   - `Set.Icc 0 1`：閉區間 \([0, 1] = \{x : \mathbb{R} \mid 0 \leq x \land x \leq 1\}\)

2. **上確界定義**：
   - `is_supremum s E`：\(s\) 是 \(E\) 的上確界，當且僅當：
     - \(s\) 是 \(E\) 的上界
     - 對所有 \(E\) 的上界 \(M\)，有 \(s \leq M\)

3. **邏輯操作**：
   - `constructor`：分開合取命題的兩個部分
   - `by_contra`：反證法
   - `push_neg`：應用 De Morgan 定律轉換否定

4. **不等式定理**：
   - `lt_of_le_of_lt`：從 \(a \leq b\) 和 \(b < c\) 得到 \(a < c\)
   - `lt_irrefl`：\(\neg(a < a)\)（一個數不能嚴格小於自己）

5. **自動證明**：
   - `norm_num`：自動證明數值不等式和等式

### 學習重點

1. **上確界的證明結構**：
   - 證明上確界需要兩個部分：上界性和最小性
   - 使用 `constructor` 分開這兩個目標

2. **從集合定義提取條件**：
   - 如果 \(x \in [0, 1]\)，則 \(x \leq 1\) 已經包含在定義中
   - 使用 `.2` 或 `.right` 提取合取命題的第二個條件

3. **反證法的應用**：
   - 證明最小性時，假設存在更小的上界 \(M < 1\)
   - 利用 \(1 \in [0, 1]\) 和上界定義得到矛盾

4. **自動證明的使用**：
   - `norm_num` 可以自動證明簡單的數值不等式
   - 這大大簡化了證明過程

5. **矛盾的識別**：
   - 從 \(1 \leq M\) 和 \(M < 1\) 得到 \(1 < 1\)
   - 使用 `lt_irrefl` 證明這是不可能的

### 相關練習

- 證明：\(\sup [a, b] = b\)（其中 \(a < b\)）
- 證明：\(\sup (0, 1) = 1\)（開區間）
- 證明：如果 \(E = \{1/n : n \in \mathbb{N}\}\)，則 \(\sup E = 1\)
- 思考：為什麼閉區間 \([0, 1]\) 的上確界是 1，而不是其他值？

---

## 備註 1.12：如果集合有一個上界，則有無窮多個上界

### 問題陳述

**備註 1.12**：如果一個集合有一個上界，則它有無窮多個上界。

這個備註說明了一個重要的觀察：上界不是唯一的。如果 \(M\) 是集合 \(E\) 的上界，那麼任何大於等於 \(M\) 的數都是 \(E\) 的上界。

### 證明策略

要證明這個備註，需要證明：如果 \(M\) 是 \(E\) 的上界，那麼對所有 \(N \geq M\)，\(N\) 也是 \(E\) 的上界。

證明思路：
1. 設 \(M\) 是 \(E\) 的上界
2. 設 \(N \geq M\)
3. 對任意 \(a \in E\)，需要證明 \(a \leq N\)
4. 因為 \(M\) 是上界，所以 \(a \leq M\)
5. 因為 \(M \leq N\)，由傳遞性得到 \(a \leq N\)

### Lean 程式碼

```lean
theorem Remark_1_12 (E : Set ℝ) (M : ℝ) (hM : is_upper_bound M E) :
   ∀ N : ℝ, N ≥ M → is_upper_bound N E := by
   intro N hN a ha  -- 引入 N、N ≥ M、a 和 a ∈ E
   have h1 : a ≤ M := hM a ha  -- 因為 M 是上界，所以 a ≤ M
   exact le_trans h1 hN  -- 從 a ≤ M 和 M ≤ N 得到 a ≤ N（傳遞性）
```

### 詳細證明步驟

1. **引入變數**：
   - `intro N hN a ha`：引入 \(N\)、假設 \(N \geq M\)、引入 \(a\) 和假設 \(a \in E\)
   - 目標是證明 \(a \leq N\)

2. **應用上界定義**：
   - `have h1 : a ≤ M := hM a ha`：因為 \(M\) 是 \(E\) 的上界，且 \(a \in E\)，所以 \(a \leq M\)
   - 這是直接應用 `is_upper_bound` 的定義

3. **使用傳遞性**：
   - `exact le_trans h1 hN`：從 \(a \leq M\)（`h1`）和 \(M \leq N\)（`hN`）得到 \(a \leq N\)
   - `le_trans` 是傳遞性定理：\(a \leq b \to b \leq c \to a \leq c\)

### 使用的定義和定理

1. **上界定義**：
   - `is_upper_bound M E`：\(M\) 是 \(E\) 的上界，當且僅當對所有 \(a \in E\)，有 \(a \leq M\)

2. **傳遞性定理**：
   - `le_trans`：\(\forall a b c : \mathbb{R}, a \leq b \to b \leq c \to a \leq c\)
   - 這是實數序關係的基本性質

### 學習重點

1. **上界的不唯一性**：
   - 如果一個集合有上界，則有無窮多個上界
   - 這是因為任何大於等於某個上界的數都是上界

2. **傳遞性的應用**：
   - 從 \(a \leq M\) 和 \(M \leq N\) 得到 \(a \leq N\)
   - 這是實數序關係的基本性質，在證明中經常使用

3. **全稱量詞的證明**：
   - 證明 \(\forall N : \mathbb{R}, N \geq M \to P(N)\) 需要對任意 \(N \geq M\) 證明 \(P(N)\)
   - 在 Lean 中使用 `intro N hN` 引入任意 \(N\) 和條件 \(N \geq M\)

4. **定義的直接應用**：
   - 如果 \(M\) 是上界，則對所有 \(a \in E\)，有 \(a \leq M\)
   - 這是上界定義的直接應用

### 相關練習

- 證明：如果一個集合有一個下界，則有無窮多個下界
- 思考：為什麼上界有無窮多個，但上確界是唯一的？
- 證明：如果 \(M\) 是 \(E\) 的上界，且 \(M' > M\)，則 \(M'\) 也是 \(E\) 的上界

---

## 備註 1.13：上確界的唯一性

### 問題陳述

**備註 1.13**：如果一個集合有上確界，則它只有一個上確界。

這個備註說明上確界是唯一的，這與上界有無窮多個形成對比。

### 證明策略

要證明唯一性，需要證明：如果 \(s_1\) 和 \(s_2\) 都是 \(E\) 的上確界，則 \(s_1 = s_2\)。

證明思路：
1. 因為 \(s_1\) 是上確界，\(s_2\) 是上界，所以 \(s_1 \leq s_2\)
2. 因為 \(s_2\) 是上確界，\(s_1\) 是上界，所以 \(s_2 \leq s_1\)
3. 由 \(s_1 \leq s_2\) 和 \(s_2 \leq s_1\) 得到 \(s_1 = s_2\)

### Lean 程式碼

```lean
theorem Remark_1_13 (E : Set ℝ) (s1 s2 : ℝ) (hs1 : is_supremum s1 E) (hs2 : is_supremum s2 E) :
   s1 = s2 := by
   have h1 : s1 ≤ s2 := hs1.2 s2 hs2.1  -- s1 是上確界，s2 是上界，所以 s1 ≤ s2
   have h2 : s2 ≤ s1 := hs2.2 s1 hs1.1  -- s2 是上確界，s1 是上界，所以 s2 ≤ s1
   have h4 : s1 = s2 := le_antisymm h1 h2  -- 從 s1 ≤ s2 和 s2 ≤ s1 得到 s1 = s2
   exact h4  -- 完成證明
```

### 詳細證明步驟

1. **應用上確界的性質**：
   - `hs1.2` 是 `is_supremum s1 E` 的第二個部分：對所有上界 \(M\)，有 \(s_1 \leq M\)
   - `hs2.1` 是 `is_supremum s2 E` 的第一個部分：\(s_2\) 是上界
   - 所以 `hs1.2 s2 hs2.1` 表示 \(s_1 \leq s_2\)

2. **對稱地得到另一個不等式**：
   - 同樣地，因為 \(s_2\) 是上確界，\(s_1\) 是上界，所以 \(s_2 \leq s_1\)

3. **使用反對稱性**：
   - `le_antisymm` 表示：如果 \(a \leq b\) 且 \(b \leq a\)，則 \(a = b\)
   - 從 \(s_1 \leq s_2\) 和 \(s_2 \leq s_1\) 得到 \(s_1 = s_2\)

### 使用的定義和定理

1. **上確界定義**：
   - `is_supremum s E` 包含兩個部分：
     - `.1`：\(s\) 是 \(E\) 的上界
     - `.2`：對所有上界 \(M\)，有 \(s \leq M\)

2. **反對稱性定理**：
   - `le_antisymm`：\(\forall a b : \mathbb{R}, a \leq b \to b \leq a \to a = b\)

### 學習重點

1. **唯一性證明的標準方法**：
   - 證明兩個對象相等，通常先證明 \(a \leq b\)，再證明 \(b \leq a\)，最後使用反對稱性

2. **上確界與上界的區別**：
   - 上界有無窮多個，但上確界是唯一的
   - 這是因為上確界是所有上界中最小的

3. **定義的結構化使用**：
   - `is_supremum` 的兩個部分（`.1` 和 `.2`）在證明中都有重要作用

### 相關練習

- 證明：如果一個集合有下確界，則它只有一個下確界
- 思考：為什麼上確界是唯一的，而上界有無窮多個？

---

## 定理 1.14：上確界的逼近性質

### 問題陳述

**定理 1.14**：如果集合 \(E\) 有有限的上確界 \(s = \sup E\)，且 \(\varepsilon > 0\) 是任意正數，則存在點 \(a \in E\)，使得
\[
\sup E - \varepsilon < a \leq \sup E
\]

這個定理說明：上確界可以被集合中的點任意接近（從下方）。

### 證明策略

使用反證法：
1. 假設不存在這樣的 \(a \in E\)
2. 那麼對所有 \(a \in E\)，有 \(a \leq s - \varepsilon\)
3. 所以 \(s - \varepsilon\) 是上界
4. 因為 \(s\) 是上確界，所以 \(s \leq s - \varepsilon\)
5. 這意味著 \(\varepsilon \leq 0\)，與 \(\varepsilon > 0\) 矛盾

### Lean 程式碼

```lean
theorem Theorem_1_14 (E : Set ℝ) (s : ℝ) (hs : is_supremum s E) (ε : ℝ) (hε : ε > 0) :
   ∃ a ∈ E, s - ε < a ∧ a ≤ s := by
   by_contra h_not  -- 假設不存在這樣的 a（反證法）
   have h1 : ∀ a ∈ E, a ≤ s - ε := by  -- 證明對所有 a ∈ E，有 a ≤ s - ε
      intro a ha  -- 引入 a ∈ E
      have h2 : a ≤ s := hs.1 a ha  -- s 是上界，所以 a ≤ s
      by_cases h3 : s - ε < a  -- 分情況：s - ε < a 或 s - ε ≥ a
      · have h4 : s - ε < a ∧ a ≤ s := ⟨ h3, h2 ⟩  -- 如果 s - ε < a，則滿足條件
        exact absurd ⟨ a, ha, h4 ⟩ h_not  -- 與 h_not 矛盾（存在這樣的 a）
      · push_neg at h3  -- s - ε ≥ a，即 a ≤ s - ε
        exact h3  -- 這就是我們要的
   have h5 : is_upper_bound (s - ε) E := h1  -- s - ε 是上界
   have h6 : s ≤ s - ε := hs.2 (s - ε) h5  -- s 是上確界，所以 s ≤ s - ε
   have h7 : ε ≤ 0 := by linarith  -- 從 s ≤ s - ε 得到 ε ≤ 0
   exact not_le_of_gt hε h7  -- ε > 0 與 ε ≤ 0 矛盾
```

### 詳細證明步驟

#### 第一步：反證法假設

1. **假設不存在**：
   - `by_contra h_not`：假設不存在 \(a \in E\) 使得 \(s - \varepsilon < a \leq s\)
   - `h_not : ¬(∃ a ∈ E, s - ε < a ∧ a ≤ s)`

#### 第二步：證明對所有 a ∈ E，有 a ≤ s - ε

2. **引入變數**：
   - `intro a ha`：引入 \(a \in E\)

3. **應用上界定義**：
   - `have h2 : a ≤ s := hs.1 a ha`：因為 \(s\) 是上界，所以 \(a \leq s\)

4. **分情況討論**：
   - `by_cases h3 : s - ε < a`：分兩種情況
     - **情況 1**（`s - ε < a`）：
       - 構造 `⟨h3, h2⟩` 得到 \(s - \varepsilon < a \land a \leq s\)
       - 構造 `⟨a, ha, h4⟩` 得到存在性證明
       - `exact absurd ⟨a, ha, h4⟩ h_not`：與 `h_not` 矛盾
     - **情況 2**（`s - ε ≥ a`）：
       - `push_neg at h3`：將 `¬(s - ε < a)` 轉換為 `a ≤ s - ε`
       - `exact h3`：這就是我們要的結論

#### 第三步：得到矛盾

5. **證明 s - ε 是上界**：
   - `have h5 : is_upper_bound (s - ε) E := h1`：從 `h1` 得到 \(s - \varepsilon\) 是上界

6. **應用上確界的性質**：
   - `have h6 : s ≤ s - ε := hs.2 (s - ε) h5`：因為 \(s\) 是上確界，\(s - \varepsilon\) 是上界，所以 \(s \leq s - \varepsilon\)

7. **推導矛盾**：
   - `have h7 : ε ≤ 0 := by linarith`：從 \(s \leq s - \varepsilon\) 得到 \(\varepsilon \leq 0\)
   - `exact not_le_of_gt hε h7`：\(\varepsilon > 0\) 與 \(\varepsilon \leq 0\) 矛盾

### 使用的定義和定理

1. **上確界定義**：
   - `is_supremum s E` 包含兩個部分：
     - `.1`：\(s\) 是 \(E\) 的上界
     - `.2`：對所有上界 \(M\)，有 \(s \leq M\)

2. **邏輯操作**：
   - `by_contra`：反證法
   - `by_cases`：分情況討論
   - `push_neg`：應用 De Morgan 定律轉換否定
   - `absurd`：從矛盾得到任意結論

3. **不等式定理**：
   - `not_le_of_gt`：從 \(a > b\) 得到 \(\neg(a \leq b)\)
   - `linarith`：線性算術自動證明

### 學習重點

1. **反證法的應用**：
   - 證明存在性時，假設不存在，然後推導矛盾
   - 這是證明存在性的常用方法

2. **分情況討論的技巧**：
   - 使用 `by_cases` 分兩種情況
   - 一種情況得到矛盾，另一種情況得到結論

3. **上確界的逼近性質**：
   - 這個定理說明上確界可以被集合中的點任意接近
   - 這是上確界的重要性質，在分析學中經常使用

4. **構造存在性證明**：
   - 在 Lean 中，存在性證明用 `⟨a, ha, P⟩` 構造
   - 需要提供元素、元素屬於集合的證明，以及性質的證明

### 相關練習

- 證明：如果 \(E\) 有有限的下確界，且 \(\varepsilon > 0\)，則存在 \(a \in E\) 使得 \(\inf E \leq a < \inf E + \varepsilon\)
- 思考：為什麼這個定理在分析學中如此重要？（它與極限和連續性密切相關）

---

## 定理 1.15：整數集合的上確界必為整數

### 問題陳述

**定理 1.15**：如果 \(E \subseteq \mathbb{Z}\) 有上確界，則 \(\sup E \in E\)。特別地，如果一個只包含整數的集合有上確界，那麼這個上確界必須是整數。

**說明**：這個定理說明了一個重要的性質：對於整數集合，如果它有上確界，那麼這個上確界必須是集合中的一個元素。這與一般實數集合不同，一般實數集合的上確界可能不在集合中（例如開區間 \((0, 1)\) 的上確界是 1，但 1 不在開區間中）。

### 證明策略

使用反證法，證明思路如下：

1. **假設結論不成立**：假設 \(\sup E \notin E\)（即上確界不在集合中）
2. **找到第一個整數**：使用定理 1.14，找到一個整數 \(n \in E\)，使得 \(s - 1/2 < n \leq s\)
3. **證明 \(n < s\)**：如果 \(n = s\)，則 \(s\) 在 \(E\) 中，與假設矛盾
4. **找到第二個整數**：再次使用定理 1.14，找到另一個整數 \(m \in E\)，使得 \(n < m \leq s\)
5. **推導矛盾**：
   - 證明 \(0 < m - n < 1\)
   - 但整數的差 \(m - n\) 也是整數
   - 不存在整數 \(k\) 使得 \(0 < k < 1\)（整數的三歧性）
   - 因此得到矛盾

### 完整證明

```lean
theorem Theorem_1_15 (E : Set ℤ) (s : ℝ) (hs : is_supremum s (E.image (Int.cast : ℤ → ℝ))) :
   (s : ℝ) ∈ (E.image (Int.cast : ℤ → ℝ)) := by
   by_contra h_not  -- 反證法：假設 s 不在 E 的像中
   have h1 : ∃ a ∈ E.image (Int.cast : ℤ → ℝ), s - (1/2 : ℝ) < a ∧ a ≤ s :=
      Theorem_1_14 (E.image (Int.cast : ℤ → ℝ)) s hs (1/2 : ℝ) (by norm_num)  -- 使用定理 1.14，取 ε = 1/2
   obtain ⟨a, ha_in, h1_left, h1_right⟩ := h1  -- 分解存在性證明，得到 a ∈ E 的像，且 s - 1/2 < a ≤ s
   obtain ⟨n, hn_in, hn_eq⟩ := ha_in  -- 因為 a 在 E 的像中，存在整數 n ∈ E 使得 a = ↑n
   have h2 : a = (n : ℝ) := hn_eq.symm  -- a 等於整數 n 的實數轉換
   have h3 : a < s := by  -- 證明 a < s（關鍵步驟）
      by_contra h_eq  -- 假設 a ≥ s
      push_neg at h_eq  -- 轉換為 a ≥ s
      have h4 : a = s := le_antisymm h1_right h_eq  -- 從 a ≤ s 和 a ≥ s 得到 a = s
      rw [← h2, h4] at hn_eq  -- 將 a 替換為 s，得到 s = ↑n
      have h5 : s = (n : ℝ) := h4.symm.trans h2  -- s = a = ↑n
      have h6 : (n : ℝ) ∈ E.image (Int.cast : ℤ → ℝ) := ⟨ n, hn_in, rfl ⟩  -- n 在 E 的像中
      rw [← h5] at h6  -- 將 ↑n 替換為 s
      exact h_not h6  -- 與假設矛盾（s 在 E 的像中）
   have h7 : s - a > 0 := sub_pos.mpr h3  -- 從 a < s 得到 s - a > 0
   have h8 : ∃ b ∈ E.image (Int.cast : ℤ → ℝ), a < b ∧ b ≤ s := by  -- 存在另一個整數 b，使得 a < b ≤ s
      have h9 : ∃ b ∈ E.image (Int.cast : ℤ → ℝ), s - (s - a) < b ∧ b ≤ s :=
         Theorem_1_14 (E.image (Int.cast : ℤ → ℝ)) s hs (s - a) h7  -- 使用定理 1.14，取 ε = s - a
      obtain ⟨ b, hb_in, hb_left, hb_right⟩ := h9  -- 分解存在性證明
      have h10 : a = s - (s - a) := by ring  -- 代數恆等式：a = s - (s - a)
      have h11 : a < b := by rw [h10]; exact hb_left  -- 從 s - (s - a) < b 得到 a < b
      use b, hb_in, h11, hb_right  -- 構造存在性證明
   obtain ⟨ b, hb_in, hb_left, hb_right⟩ := h8  -- 分解得到整數 b，滿足 a < b ≤ s
   obtain ⟨ m, hm_in, hm_eq⟩ := hb_in  -- 因為 b 在 E 的像中，存在整數 m ∈ E 使得 b = ↑m
   have h12 : b = (m : ℝ) := hm_eq.symm  -- b 等於整數 m 的實數轉換
   have h13 : 0 < b - a := sub_pos.mpr hb_left  -- 從 a < b 得到 b - a > 0
   have h14 : b - a < 1 := by  -- 證明 b - a < 1（關鍵不等式）
      have h15 : s - (1/2 : ℝ) < a := h1_left  -- 從 h1 得到 s - 1/2 < a
      calc
         b - a
         _ ≤ s - a := sub_le_sub_right hb_right a  -- 從 b ≤ s 得到 b - a ≤ s - a
         _ < 1/2 := by linarith  -- 從 s - 1/2 < a 得到 s - a < 1/2
         _ < 1 := by norm_num  -- 1/2 < 1
   have h16 : b - a = (m - n : ℝ) := by rw [h12, h2]  -- b - a = ↑m - ↑n = ↑(m - n)
   have h17 : (0 : ℝ) < (m - n : ℝ) ∧ (m - n : ℝ) < 1 := by  -- 0 < ↑(m - n) < 1
      constructor
      rw [← h16]; exact h13  -- 從 b - a > 0 得到 ↑(m - n) > 0
      rw [← h16]; exact h14  -- 從 b - a < 1 得到 ↑(m - n) < 1
   have h18 : ¬ (∃ k : ℤ, (0 : ℝ) < (k : ℝ) ∧ (k : ℝ) < 1) := by  -- 不存在整數 k 使得 0 < ↑k < 1
      intro h  -- 假設存在這樣的 k
      obtain ⟨ k, hk_left, hk_right⟩ := h  -- 分解存在性證明
      have h19 : (k : ℤ) ≤ 0 ∨ (k : ℤ) ≥ 1 := by  -- 整數的三歧性：k ≤ 0 或 k ≥ 1
         by_cases h_le : (k : ℤ) ≤ 0  -- 分情況：k ≤ 0 或 k > 0
         left; exact h_le  -- 情況 1：k ≤ 0
         right  -- 情況 2：k > 0
         push_neg at h_le  -- 轉換為 k > 0
         exact Int.add_one_le_of_lt h_le  -- 從 k > 0 得到 k ≥ 1（整數性質）
      cases h19 with
      | inl h_le =>  -- 情況 1：k ≤ 0
         have h20 : (k : ℝ) ≤ 0:= by
            rw [← Int.cast_zero]
            exact Int.cast_le.mpr h_le  -- 整數轉換保序：k ≤ 0 則 ↑k ≤ 0
         linarith  -- 與 hk_left : ↑k > 0 矛盾
      | inr h_ge =>  -- 情況 2：k ≥ 1
         have h21 : (k : ℝ) ≥ 1 := by
            rw [← Int.cast_one]
            exact Int.cast_le.mpr h_ge  -- 整數轉換保序：k ≥ 1 則 ↑k ≥ 1
         linarith  -- 與 hk_right : ↑k < 1 矛盾
   have h22 : (0 : ℝ) < ↑(m - n) := by  -- 證明 0 < ↑(m - n)
      calc
         (0 : ℝ)
         _ < ↑m - ↑n := h17.1  -- 從 h17 得到 0 < ↑m - ↑n
         _ = ↑(m - n) := (Int.cast_sub m n).symm  -- 使用整數轉換的減法性質
   have h23 : ↑(m - n) < (1 : ℝ) := by  -- 證明 ↑(m - n) < 1
      calc
         ↑(m - n)
         _ = ↑m - ↑n := Int.cast_sub m n  -- 使用整數轉換的減法性質
         _ < (1 : ℝ) := h17.2  -- 從 h17 得到 ↑m - ↑n < 1
   exact h18 ⟨m - n, h22, h23⟩  -- 與 h18 矛盾（存在整數 m - n 使得 0 < ↑(m - n) < 1）
```

### 詳細證明步驟

#### 第一步：反證法假設

1. **假設結論不成立**：
   - `by_contra h_not`：假設上確界 \(s\) 不在 \(E\) 的像中
   - 目標是推導出矛盾

#### 第二步：找到第一個整數

2. **應用定理 1.14**：
   - 使用定理 1.14，取 \(\varepsilon = 1/2\)
   - 得到存在 \(a \in E\) 的像，使得 \(s - 1/2 < a \leq s\)
   - 因為 \(a\) 在 \(E\) 的像中，存在整數 \(n \in E\) 使得 \(a = n\)（作為實數）

3. **證明 \(n < s\)**：
   - 如果 \(n = s\)，則 \(s\) 在 \(E\) 中，與假設矛盾
   - 因此必須有 \(n < s\)

#### 第三步：找到第二個整數

4. **再次應用定理 1.14**：
   - 因為 \(s - n > 0\)，使用定理 1.14，取 \(\varepsilon = s - n\)
   - 得到存在另一個點 \(b \in E\) 的像，使得 \(s - (s - n) < b \leq s\)
   - 簡化：\(n < b \leq s\)
   - 因為 \(b\) 在 \(E\) 的像中，存在整數 \(m \in E\) 使得 \(b = m\)（作為實數）

#### 第四步：推導關鍵不等式

5. **證明 \(0 < m - n < 1\)**：
   - 從 \(n < m \leq s\) 得到 \(0 < m - n\)
   - 從 \(s - 1/2 < n\) 和 \(m \leq s\) 得到：
     \[
     m - n \leq s - n < s - (s - 1/2) = 1/2 < 1
     \]
   - 因此 \(0 < m - n < 1\)

#### 第五步：推導矛盾

6. **整數的三歧性**：
   - 對於任意整數 \(k\)，要麼 \(k \leq 0\)，要麼 \(k \geq 1\)
   - 不存在整數 \(k\) 使得 \(0 < k < 1\)

7. **應用到 \(m - n\)**：
   - \(m - n\) 是整數（因為 \(m\) 和 \(n\) 都是整數）
   - 但我們證明了 \(0 < m - n < 1\)
   - 這與整數的三歧性矛盾

8. **完成證明**：
   - 假設導致矛盾，因此原結論成立
   - 即：如果整數集合有上確界，則上確界必須在集合中

### 使用的定義和定理

1. **定理 1.14**：
   - 如果集合有上確界 \(s\)，且 \(\varepsilon > 0\)，則存在 \(a \in E\) 使得 \(s - \varepsilon < a \leq s\)
   - 這是上確界的逼近性質

2. **整數的三歧性**：
   - 對於任意整數 \(k\)，有 \(k \leq 0\) 或 \(k \geq 1\)
   - 不存在整數 \(k\) 使得 \(0 < k < 1\)

3. **整數轉換的性質**：
   - `Int.cast_sub`：\(\uparrow(m - n) = \uparrow m - \uparrow n\)
   - `Int.cast_le`：整數轉換保序
   - `Int.add_one_le_of_lt`：如果整數 \(k > 0\)，則 \(k \geq 1\)

4. **反證法**：
   - `by_contra`：假設結論不成立，推導矛盾

### 學習重點

1. **反證法的應用**：
   - 這個證明展示了如何使用反證法來證明存在性
   - 假設結論不成立，然後推導出邏輯矛盾

2. **整數的特殊性質**：
   - 整數是離散的，任意兩個不同整數之間的距離至少為 1
   - 這與實數的稠密性形成對比

3. **上確界的逼近性質**：
   - 定理 1.14 允許我們找到任意接近上確界的點
   - 對於整數集合，這導致上確界必須是集合中的元素

4. **類型轉換的使用**：
   - 在 Lean 中，需要將整數轉換為實數來使用實數的性質
   - `Int.cast` 用於整數到實數的轉換
   - 需要注意轉換後的性質（如保序性）

5. **代數恆等式的使用**：
   - \(a = s - (s - a)\) 是一個有用的代數恆等式
   - 在證明中經常使用這類恆等式來重組表達式

### 相關練習

- 證明：如果 \(E \subseteq \mathbb{Z}\) 有下確界，則 \(\inf E \in E\)
- 思考：為什麼實數集合的上確界可能不在集合中，而整數集合的上確界必須在集合中？
- 證明：如果 \(E \subseteq \mathbb{N}\)（自然數集合）有上確界，則 \(\sup E \in E\)
- 應用：使用這個定理證明，如果整數序列有上確界，則上確界是序列中的某項

---

## 後續練習題

（此處將添加更多第一章的練習題）

（此處將添加更多第一章的練習題）
